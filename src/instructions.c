/*
 * AUTOGENERATED CODE - jeudi 30 novembre 2017, 18:05:24 (UTC+0100)
 * DON'T EDIT BY HAND !
 */

#include "cpu.h"
#include "utils.h"
#include "GB.h"

static uint16_t pop16(struct s_gb *s_gb)
{
	uint16_t value;

	s_gb->gb_register.sp += 2;
	value = read16bit(s_gb->gb_register.sp, s_gb);

	return value;
}

/* base instruction set */
/* start of op code function definitions */
/* nop [0x00] : No operation is performed. */
static void nop(struct s_gb *s_gb)
{
	/* start of nop manual code */

	/* end of nop manual code */
	/* nothing to do */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld bc,** [0x01] : Loads ** into bc. */
static void ld_bc_xx(struct s_gb *s_gb)
{
	/* start of ld_bc_xx manual code */

	/* end of ld_bc_xx manual code */
	uint16_t src_val = read16bit(s_gb->gb_register.pc + 1, s_gb);
	s_gb->gb_register.bc = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld (bc),a [0x02] : Stores a into the memory location pointed to by bc. */
static void ld_pbc_a(struct s_gb *s_gb)
{
	/* start of ld_pbc_a manual code */

	/* end of ld_pbc_a manual code */
	__typeof__(s_gb->gb_register.a) src_val = s_gb->gb_register.a;
	uint16_t dst_adr = s_gb->gb_register.bc;
	write8bit(dst_adr, src_val, s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* inc bc [0x03] : Adds one to bc. */
static void inc_bc(struct s_gb *s_gb)
{
	/* start of inc_bc manual code */

	/* end of inc_bc manual code */
	if ((s_gb->gb_register.bc & 0x0f) == 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.bc++;

	if (s_gb->gb_register.bc)
		CLEAR_ZERO();
	else
		SET_ZERO();

	CLEAR_NEG();
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* inc b [0x04] : Adds one to b. */
static void inc_b(struct s_gb *s_gb)
{
	/* start of inc_b manual code */

	/* end of inc_b manual code */
	if ((s_gb->gb_register.b & 0x0f) == 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.b++;

	if (s_gb->gb_register.b)
		CLEAR_ZERO();
	else
		SET_ZERO();

	CLEAR_NEG();
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY unaffected */
}

/* dec b [0x05] : Subtracts one from b. */
static void dec_b(struct s_gb *s_gb)
{
	/* start of dec_b manual code */

	/* end of dec_b manual code */
	if (s_gb->gb_register.b & 0x0f)
		CLEAR_HALFC();
	else
		SET_HALFC();

	s_gb->gb_register.b--;

	if (s_gb->gb_register.b)
		CLEAR_ZERO();
	else
		SET_ZERO();

	SET_NEG();
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY unaffected */
}

/* ld b,* [0x06] : Loads * into b. */
static void ld_b_x(struct s_gb *s_gb)
{
	/* start of ld_b_x manual code */

	/* end of ld_b_x manual code */
	uint8_t src_val = read8bit(s_gb->gb_register.pc + 1, s_gb);
	s_gb->gb_register.b = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* rlca [0x07] : The contents of a are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. */
static void rlca(struct s_gb *s_gb)
{
	/* start of rlca manual code */

	/* end of rlca manual code */
	/* ZERO unaffected */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* ld (**),sp [0x08] : Loads ** into sp. */
static void ld_pxx_sp(struct s_gb *s_gb)
{
	/* start of ld_pxx_sp manual code */

	/* end of ld_pxx_sp manual code */
	__typeof__(s_gb->gb_register.sp) src_val = s_gb->gb_register.sp;
	uint16_t dst_adr = read16bit(s_gb->gb_register.pc + 1, s_gb);
	write8bit(dst_adr, src_val, s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* add hl,bc [0x09] : The value of bc is added to hl. */
static void add_hl_bc(struct s_gb *s_gb)
{
	/* start of add_hl_bc manual code */

	/* end of add_hl_bc manual code */
	uint32_t result = s_gb->gb_register.hl + s_gb->gb_register.bc;
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.hl & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.hl = 0xffffu & result;
	/* ZERO unaffected */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* ld a,(bc) [0x0A] : Loads the value pointed to by bc into a. */
static void ld_a_pbc(struct s_gb *s_gb)
{
	/* start of ld_a_pbc manual code */

	/* end of ld_a_pbc manual code */
	uint16_t src_adr = s_gb->gb_register.bc;
	uint8_t src_val = read8bit(src_adr, s_gb);
	s_gb->gb_register.a = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* dec bc [0x0B] : Subtracts one from bc. */
static void dec_bc(struct s_gb *s_gb)
{
	/* start of dec_bc manual code */

	/* end of dec_bc manual code */
	if (s_gb->gb_register.bc & 0x0f)
		CLEAR_HALFC();
	else
		SET_HALFC();

	s_gb->gb_register.bc--;

	if (s_gb->gb_register.bc)
		CLEAR_ZERO();
	else
		SET_ZERO();

	SET_NEG();
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* inc c [0x0C] : Adds one to c. */
static void inc_c(struct s_gb *s_gb)
{
	/* start of inc_c manual code */

	/* end of inc_c manual code */
	if ((s_gb->gb_register.c & 0x0f) == 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.c++;

	if (s_gb->gb_register.c)
		CLEAR_ZERO();
	else
		SET_ZERO();

	CLEAR_NEG();
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY unaffected */
}

/* dec c [0x0D] : Subtracts one from c. */
static void dec_c(struct s_gb *s_gb)
{
	/* start of dec_c manual code */

	/* end of dec_c manual code */
	if (s_gb->gb_register.c & 0x0f)
		CLEAR_HALFC();
	else
		SET_HALFC();

	s_gb->gb_register.c--;

	if (s_gb->gb_register.c)
		CLEAR_ZERO();
	else
		SET_ZERO();

	SET_NEG();
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY unaffected */
}

/* ld c,* [0x0E] : Loads * into c. */
static void ld_c_x(struct s_gb *s_gb)
{
	/* start of ld_c_x manual code */

	/* end of ld_c_x manual code */
	uint8_t src_val = read8bit(s_gb->gb_register.pc + 1, s_gb);
	s_gb->gb_register.c = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* rrca [0x0F] : The contents of a are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. */
static void rrca(struct s_gb *s_gb)
{
	/* start of rrca manual code */

	/* end of rrca manual code */
	/* ZERO unaffected */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* stop [0x10] : Halt CPU & LCD display until button pressed. */
static void stop(struct s_gb *s_gb)
{
	/* start of stop manual code */

	/* end of stop manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld de,** [0x11] : Loads ** into de. */
static void ld_de_xx(struct s_gb *s_gb)
{
	/* start of ld_de_xx manual code */

	/* end of ld_de_xx manual code */
	uint16_t src_val = read16bit(s_gb->gb_register.pc + 1, s_gb);
	s_gb->gb_register.de = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld (de),a [0x12] : Stores a into the memory location pointed to by de. */
static void ld_pde_a(struct s_gb *s_gb)
{
	/* start of ld_pde_a manual code */

	/* end of ld_pde_a manual code */
	__typeof__(s_gb->gb_register.a) src_val = s_gb->gb_register.a;
	uint16_t dst_adr = s_gb->gb_register.de;
	write8bit(dst_adr, src_val, s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* inc de [0x13] : Adds one to de. */
static void inc_de(struct s_gb *s_gb)
{
	/* start of inc_de manual code */

	/* end of inc_de manual code */
	if ((s_gb->gb_register.de & 0x0f) == 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.de++;

	if (s_gb->gb_register.de)
		CLEAR_ZERO();
	else
		SET_ZERO();

	CLEAR_NEG();
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* inc d [0x14] : Adds one to d. */
static void inc_d(struct s_gb *s_gb)
{
	/* start of inc_d manual code */

	/* end of inc_d manual code */
	if ((s_gb->gb_register.d & 0x0f) == 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.d++;

	if (s_gb->gb_register.d)
		CLEAR_ZERO();
	else
		SET_ZERO();

	CLEAR_NEG();
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY unaffected */
}

/* dec d [0x15] : Subtracts one from d. */
static void dec_d(struct s_gb *s_gb)
{
	/* start of dec_d manual code */

	/* end of dec_d manual code */
	if (s_gb->gb_register.d & 0x0f)
		CLEAR_HALFC();
	else
		SET_HALFC();

	s_gb->gb_register.d--;

	if (s_gb->gb_register.d)
		CLEAR_ZERO();
	else
		SET_ZERO();

	SET_NEG();
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY unaffected */
}

/* ld d,* [0x16] : Loads * into d. */
static void ld_d_x(struct s_gb *s_gb)
{
	/* start of ld_d_x manual code */

	/* end of ld_d_x manual code */
	uint8_t src_val = read8bit(s_gb->gb_register.pc + 1, s_gb);
	s_gb->gb_register.d = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* rla [0x17] : The contents of a are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. */
static void rla(struct s_gb *s_gb)
{
	/* start of rla manual code */

	/* end of rla manual code */
	/* ZERO unaffected */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* jr * [0x18] : The signed value * is added to pc. The jump is measured from the start of the instruction opcode. */
static void jr_x(struct s_gb *s_gb)
{
	/* start of jr_x manual code */

	/* end of jr_x manual code */
	s_gb->gb_register.pc++;
	if (FLAGS_ISZERO(s_gb->gb_register.f))
		s_gb->gb_register.pc = s_gb->gb_register.pc + read8bit(s_gb->gb_register.pc, s_gb) + 1;
	else
		s_gb->gb_register.pc += 1; /* size of address */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* add hl,de [0x19] : The value of de is added to hl. */
static void add_hl_de(struct s_gb *s_gb)
{
	/* start of add_hl_de manual code */

	/* end of add_hl_de manual code */
	uint32_t result = s_gb->gb_register.hl + s_gb->gb_register.de;
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.hl & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.hl = 0xffffu & result;
	/* ZERO unaffected */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* ld a,(de) [0x1A] : Loads the value pointed to by de into a. */
static void ld_a_pde(struct s_gb *s_gb)
{
	/* start of ld_a_pde manual code */

	/* end of ld_a_pde manual code */
	uint16_t src_adr = s_gb->gb_register.de;
	uint8_t src_val = read8bit(src_adr, s_gb);
	s_gb->gb_register.a = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* dec de [0x1B] : Subtracts one from de. */
static void dec_de(struct s_gb *s_gb)
{
	/* start of dec_de manual code */

	/* end of dec_de manual code */
	if (s_gb->gb_register.de & 0x0f)
		CLEAR_HALFC();
	else
		SET_HALFC();

	s_gb->gb_register.de--;

	if (s_gb->gb_register.de)
		CLEAR_ZERO();
	else
		SET_ZERO();

	SET_NEG();
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* inc e [0x1C] : Adds one to e. */
static void inc_e(struct s_gb *s_gb)
{
	/* start of inc_e manual code */

	/* end of inc_e manual code */
	if ((s_gb->gb_register.e & 0x0f) == 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.e++;

	if (s_gb->gb_register.e)
		CLEAR_ZERO();
	else
		SET_ZERO();

	CLEAR_NEG();
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY unaffected */
}

/* dec e [0x1D] : Subtracts one from e. */
static void dec_e(struct s_gb *s_gb)
{
	/* start of dec_e manual code */

	/* end of dec_e manual code */
	if (s_gb->gb_register.e & 0x0f)
		CLEAR_HALFC();
	else
		SET_HALFC();

	s_gb->gb_register.e--;

	if (s_gb->gb_register.e)
		CLEAR_ZERO();
	else
		SET_ZERO();

	SET_NEG();
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY unaffected */
}

/* ld e,* [0x1E] : Loads * into e. */
static void ld_e_x(struct s_gb *s_gb)
{
	/* start of ld_e_x manual code */

	/* end of ld_e_x manual code */
	uint8_t src_val = read8bit(s_gb->gb_register.pc + 1, s_gb);
	s_gb->gb_register.e = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* rra [0x1F] : The contents of a are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. */
static void rra(struct s_gb *s_gb)
{
	/* start of rra manual code */

	/* end of rra manual code */
	/* ZERO unaffected */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* jr nz,* [0x20] : If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode. */
static void jr_nz_x(struct s_gb *s_gb)
{
	/* start of jr_nz_x manual code */

	/* end of jr_nz_x manual code */
	s_gb->gb_register.pc++;
	if (!FLAGS_ISZERO(s_gb->gb_register.f))
		s_gb->gb_register.pc = s_gb->gb_register.pc + read8bit(s_gb->gb_register.pc, s_gb) + 1;
	else
		s_gb->gb_register.pc += 1; /* size of address */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld hl,** [0x21] : Loads ** into hl. */
static void ld_hl_xx(struct s_gb *s_gb)
{
	/* start of ld_hl_xx manual code */

	/* end of ld_hl_xx manual code */
	uint16_t src_val = read16bit(s_gb->gb_register.pc + 1, s_gb);
	s_gb->gb_register.hl = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ldi (hl),a [0x22] : Put a into memory location pointed to by hl. Increment hl. */
static void ldi_phl_a(struct s_gb *s_gb)
{
	/* start of ldi_phl_a manual code */

	/* end of ldi_phl_a manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* inc hl [0x23] : Adds one to hl. */
static void inc_hl(struct s_gb *s_gb)
{
	/* start of inc_hl manual code */

	/* end of inc_hl manual code */
	if ((s_gb->gb_register.hl & 0x0f) == 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.hl++;

	if (s_gb->gb_register.hl)
		CLEAR_ZERO();
	else
		SET_ZERO();

	CLEAR_NEG();
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* inc h [0x24] : Adds one to h. */
static void inc_h(struct s_gb *s_gb)
{
	/* start of inc_h manual code */

	/* end of inc_h manual code */
	if ((s_gb->gb_register.h & 0x0f) == 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.h++;

	if (s_gb->gb_register.h)
		CLEAR_ZERO();
	else
		SET_ZERO();

	CLEAR_NEG();
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY unaffected */
}

/* dec h [0x25] : Subtracts one from h. */
static void dec_h(struct s_gb *s_gb)
{
	/* start of dec_h manual code */

	/* end of dec_h manual code */
	if (s_gb->gb_register.h & 0x0f)
		CLEAR_HALFC();
	else
		SET_HALFC();

	s_gb->gb_register.h--;

	if (s_gb->gb_register.h)
		CLEAR_ZERO();
	else
		SET_ZERO();

	SET_NEG();
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY unaffected */
}

/* ld h,* [0x26] : Loads * into h. */
static void ld_h_x(struct s_gb *s_gb)
{
	/* start of ld_h_x manual code */

	/* end of ld_h_x manual code */
	uint8_t src_val = read8bit(s_gb->gb_register.pc + 1, s_gb);
	s_gb->gb_register.h = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* daa [0x27] : Adjusts a for BCD addition and subtraction operations. */
static void daa(struct s_gb *s_gb)
{
	/* start of daa manual code */

	/* end of daa manual code */
	/* ZERO affected as defined */
	/* NEG unaffected */
	/* unknown action on HALFC */
	/* unknown action on CARRY */
}

/* jr z,* [0x28] : If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode. */
static void jr_z_x(struct s_gb *s_gb)
{
	/* start of jr_z_x manual code */

	/* end of jr_z_x manual code */
	s_gb->gb_register.pc++;
	if (FLAGS_ISZERO(s_gb->gb_register.f))
		s_gb->gb_register.pc = s_gb->gb_register.pc + read8bit(s_gb->gb_register.pc, s_gb) + 1;
	else
		s_gb->gb_register.pc += 1; /* size of address */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* add hl,hl [0x29] : The value of hl is added to hl. */
static void add_hl_hl(struct s_gb *s_gb)
{
	/* start of add_hl_hl manual code */

	/* end of add_hl_hl manual code */
	uint32_t result = s_gb->gb_register.hl + s_gb->gb_register.hl;
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.hl & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.hl = 0xffffu & result;
	/* ZERO unaffected */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* ldi a,(hl) [0x2A] : Put the value at adress hl into a. Increment hl. */
static void ldi_a_phl(struct s_gb *s_gb)
{
	/* start of ldi_a_phl manual code */

	/* end of ldi_a_phl manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* dec hl [0x2B] : Subtracts one from hl. */
static void dec_hl(struct s_gb *s_gb)
{
	/* start of dec_hl manual code */

	/* end of dec_hl manual code */
	if (s_gb->gb_register.hl & 0x0f)
		CLEAR_HALFC();
	else
		SET_HALFC();

	s_gb->gb_register.hl--;

	if (s_gb->gb_register.hl)
		CLEAR_ZERO();
	else
		SET_ZERO();

	SET_NEG();
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* inc l [0x2C] : Adds one to l. */
static void inc_l(struct s_gb *s_gb)
{
	/* start of inc_l manual code */

	/* end of inc_l manual code */
	if ((s_gb->gb_register.l & 0x0f) == 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.l++;

	if (s_gb->gb_register.l)
		CLEAR_ZERO();
	else
		SET_ZERO();

	CLEAR_NEG();
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY unaffected */
}

/* dec l [0x2D] : Subtracts one from l. */
static void dec_l(struct s_gb *s_gb)
{
	/* start of dec_l manual code */

	/* end of dec_l manual code */
	if (s_gb->gb_register.l & 0x0f)
		CLEAR_HALFC();
	else
		SET_HALFC();

	s_gb->gb_register.l--;

	if (s_gb->gb_register.l)
		CLEAR_ZERO();
	else
		SET_ZERO();

	SET_NEG();
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY unaffected */
}

/* ld l,* [0x2E] : Loads * into l. */
static void ld_l_x(struct s_gb *s_gb)
{
	/* start of ld_l_x manual code */

	/* end of ld_l_x manual code */
	uint8_t src_val = read8bit(s_gb->gb_register.pc + 1, s_gb);
	s_gb->gb_register.l = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* cpl [0x2F] : The contents of a are inverted (one's complement). */
static void cpl(struct s_gb *s_gb)
{
	/* start of cpl manual code */

	/* end of cpl manual code */
	/* ZERO unaffected */
	/* NEG set */
	SET_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* jr nc,* [0x30] : If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode. */
static void jr_nc_x(struct s_gb *s_gb)
{
	/* start of jr_nc_x manual code */

	/* end of jr_nc_x manual code */
	s_gb->gb_register.pc++;
	if (!FLAGS_ISCARRY(s_gb->gb_register.f))
		s_gb->gb_register.pc = s_gb->gb_register.pc + read8bit(s_gb->gb_register.pc, s_gb) + 1;
	else
		s_gb->gb_register.pc += 1; /* size of address */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld sp,** [0x31] : Loads ** into sp. */
static void ld_sp_xx(struct s_gb *s_gb)
{
	/* start of ld_sp_xx manual code */

	/* end of ld_sp_xx manual code */
	uint16_t src_val = read16bit(s_gb->gb_register.pc + 1, s_gb);
	s_gb->gb_register.sp = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ldd (hl),a [0x32] : Put a into memory adress hl. Decrement hl. */
static void ldd_phl_a(struct s_gb *s_gb)
{
	/* start of ldd_phl_a manual code */

	/* end of ldd_phl_a manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* inc sp [0x33] : Adds one to sp. */
static void inc_sp(struct s_gb *s_gb)
{
	/* start of inc_sp manual code */

	/* end of inc_sp manual code */
	if ((s_gb->gb_register.sp & 0x0f) == 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.sp++;

	if (s_gb->gb_register.sp)
		CLEAR_ZERO();
	else
		SET_ZERO();

	CLEAR_NEG();
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* inc (hl) [0x34] : Adds one to (hl). */
static void inc_phl(struct s_gb *s_gb)
{
	/* start of inc_phl manual code */

	/* end of inc_phl manual code */
	uint8_t value = read8bit(s_gb->gb_register.hl, s_gb);
	if ((value & 0x0f) == 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	value++;

	if (value)
		CLEAR_ZERO();
	else
		SET_ZERO();

	CLEAR_NEG();
	write8bit(s_gb->gb_register.hl, value, s_gb);
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY unaffected */
}

/* dec (hl) [0x35] : Subtracts one from (hl). */
static void dec_phl(struct s_gb *s_gb)
{
	/* start of dec_phl manual code */

	/* end of dec_phl manual code */
	uint8_t value = read8bit(s_gb->gb_register.hl, s_gb);
	if (value & 0x0f)
		CLEAR_HALFC();
	else
		SET_HALFC();

	value--;

	if (value)
		CLEAR_ZERO();
	else
		SET_ZERO();

	SET_NEG();
	write8bit(s_gb->gb_register.hl, value, s_gb);
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY unaffected */
}

/* ld (hl),* [0x36] : Loads * into (hl). */
static void ld_phl_x(struct s_gb *s_gb)
{
	/* start of ld_phl_x manual code */

	/* end of ld_phl_x manual code */
	uint8_t src_val = read8bit(s_gb->gb_register.pc + 1, s_gb);
	uint16_t dst_adr = s_gb->gb_register.hl;
	write8bit(dst_adr, src_val, s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* scf [0x37] : Sets the carry flag. */
static void scf(struct s_gb *s_gb)
{
	/* start of scf manual code */

	/* end of scf manual code */
	/* ZERO unaffected */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY set */
	SET_CARRY();
}

/* jr c,* [0x38] : If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode. */
static void jr_c_x(struct s_gb *s_gb)
{
	/* start of jr_c_x manual code */

	/* end of jr_c_x manual code */
	s_gb->gb_register.pc++;
	if (FLAGS_ISCARRY(s_gb->gb_register.f))
		s_gb->gb_register.pc = s_gb->gb_register.pc + read8bit(s_gb->gb_register.pc, s_gb) + 1;
	else
		s_gb->gb_register.pc += 1; /* size of address */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* add hl,sp [0x39] : The value of hl is added to hl. */
static void add_hl_sp(struct s_gb *s_gb)
{
	/* start of add_hl_sp manual code */

	/* end of add_hl_sp manual code */
	uint32_t result = s_gb->gb_register.hl + s_gb->gb_register.sp;
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.hl & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.hl = 0xffffu & result;
	/* ZERO unaffected */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* ldd a,(hl) [0x3A] : Put value at adress hl into a. Decrement hl. */
static void ldd_a_phl(struct s_gb *s_gb)
{
	/* start of ldd_a_phl manual code */

	/* end of ldd_a_phl manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* dec sp [0x3B] : Subtracts one from sp. */
static void dec_sp(struct s_gb *s_gb)
{
	/* start of dec_sp manual code */

	/* end of dec_sp manual code */
	if (s_gb->gb_register.sp & 0x0f)
		CLEAR_HALFC();
	else
		SET_HALFC();

	s_gb->gb_register.sp--;

	if (s_gb->gb_register.sp)
		CLEAR_ZERO();
	else
		SET_ZERO();

	SET_NEG();
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* inc a [0x3C] : Adds one to a. */
static void inc_a(struct s_gb *s_gb)
{
	/* start of inc_a manual code */

	/* end of inc_a manual code */
	if ((s_gb->gb_register.a & 0x0f) == 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a++;

	if (s_gb->gb_register.a)
		CLEAR_ZERO();
	else
		SET_ZERO();

	CLEAR_NEG();
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY unaffected */
}

/* dec a [0x3D] : Subtracts one from a. */
static void dec_a(struct s_gb *s_gb)
{
	/* start of dec_a manual code */

	/* end of dec_a manual code */
	if (s_gb->gb_register.a & 0x0f)
		CLEAR_HALFC();
	else
		SET_HALFC();

	s_gb->gb_register.a--;

	if (s_gb->gb_register.a)
		CLEAR_ZERO();
	else
		SET_ZERO();

	SET_NEG();
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY unaffected */
}

/* ld a,* [0x3E] : Loads * into a. */
static void ld_a_x(struct s_gb *s_gb)
{
	/* start of ld_a_x manual code */

	/* end of ld_a_x manual code */
	uint8_t src_val = read8bit(s_gb->gb_register.pc + 1, s_gb);
	s_gb->gb_register.a = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ccf [0x3F] : Inverts the carry flag. */
static void ccf(struct s_gb *s_gb)
{
	/* start of ccf manual code */

	/* end of ccf manual code */
	/* ZERO unaffected */
	/* NEG reset */
	CLEAR_NEG();
	/* unknown action on HALFC */
	/* unknown action on CARRY */
}

/* ld b,b [0x40] : The contents of b are loaded into b. */
static void ld_b_b(struct s_gb *s_gb)
{
	/* start of ld_b_b manual code */

	/* end of ld_b_b manual code */
	__typeof__(s_gb->gb_register.b) src_val = s_gb->gb_register.b;
	s_gb->gb_register.b = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld b,c [0x41] : The contents of c are loaded into b. */
static void ld_b_c(struct s_gb *s_gb)
{
	/* start of ld_b_c manual code */

	/* end of ld_b_c manual code */
	__typeof__(s_gb->gb_register.c) src_val = s_gb->gb_register.c;
	s_gb->gb_register.b = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld b,d [0x42] : The contents of d are loaded into b. */
static void ld_b_d(struct s_gb *s_gb)
{
	/* start of ld_b_d manual code */

	/* end of ld_b_d manual code */
	__typeof__(s_gb->gb_register.d) src_val = s_gb->gb_register.d;
	s_gb->gb_register.b = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld b,e [0x43] : The contents of e are loaded into b. */
static void ld_b_e(struct s_gb *s_gb)
{
	/* start of ld_b_e manual code */

	/* end of ld_b_e manual code */
	__typeof__(s_gb->gb_register.e) src_val = s_gb->gb_register.e;
	s_gb->gb_register.b = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld b,h [0x44] : The contents of h are loaded into b. */
static void ld_b_h(struct s_gb *s_gb)
{
	/* start of ld_b_h manual code */

	/* end of ld_b_h manual code */
	__typeof__(s_gb->gb_register.h) src_val = s_gb->gb_register.h;
	s_gb->gb_register.b = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld b,l [0x45] : The contents of l are loaded into b. */
static void ld_b_l(struct s_gb *s_gb)
{
	/* start of ld_b_l manual code */

	/* end of ld_b_l manual code */
	__typeof__(s_gb->gb_register.l) src_val = s_gb->gb_register.l;
	s_gb->gb_register.b = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld b,(hl) [0x46] : The contents of (hl) are loaded into b. */
static void ld_b_phl(struct s_gb *s_gb)
{
	/* start of ld_b_phl manual code */

	/* end of ld_b_phl manual code */
	uint16_t src_adr = s_gb->gb_register.hl;
	uint8_t src_val = read8bit(src_adr, s_gb);
	s_gb->gb_register.b = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld b,a [0x47] : The contents of a are loaded into b. */
static void ld_b_a(struct s_gb *s_gb)
{
	/* start of ld_b_a manual code */

	/* end of ld_b_a manual code */
	__typeof__(s_gb->gb_register.a) src_val = s_gb->gb_register.a;
	s_gb->gb_register.b = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld c,b [0x48] : The contents of b are loaded into c. */
static void ld_c_b(struct s_gb *s_gb)
{
	/* start of ld_c_b manual code */

	/* end of ld_c_b manual code */
	__typeof__(s_gb->gb_register.b) src_val = s_gb->gb_register.b;
	s_gb->gb_register.c = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld c,c [0x49] : The contents of c are loaded into c. */
static void ld_c_c(struct s_gb *s_gb)
{
	/* start of ld_c_c manual code */

	/* end of ld_c_c manual code */
	__typeof__(s_gb->gb_register.c) src_val = s_gb->gb_register.c;
	s_gb->gb_register.c = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld c,d [0x4A] : The contents of d are loaded into c. */
static void ld_c_d(struct s_gb *s_gb)
{
	/* start of ld_c_d manual code */

	/* end of ld_c_d manual code */
	__typeof__(s_gb->gb_register.d) src_val = s_gb->gb_register.d;
	s_gb->gb_register.c = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld c,e [0x4B] : The contents of e are loaded into c. */
static void ld_c_e(struct s_gb *s_gb)
{
	/* start of ld_c_e manual code */

	/* end of ld_c_e manual code */
	__typeof__(s_gb->gb_register.e) src_val = s_gb->gb_register.e;
	s_gb->gb_register.c = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld c,h [0x4C] : The contents of h are loaded into c. */
static void ld_c_h(struct s_gb *s_gb)
{
	/* start of ld_c_h manual code */

	/* end of ld_c_h manual code */
	__typeof__(s_gb->gb_register.h) src_val = s_gb->gb_register.h;
	s_gb->gb_register.c = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld c,l [0x4D] : The contents of l are loaded into c. */
static void ld_c_l(struct s_gb *s_gb)
{
	/* start of ld_c_l manual code */

	/* end of ld_c_l manual code */
	__typeof__(s_gb->gb_register.l) src_val = s_gb->gb_register.l;
	s_gb->gb_register.c = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld c,(hl) [0x4E] : The contents of (hl) are loaded into c. */
static void ld_c_phl(struct s_gb *s_gb)
{
	/* start of ld_c_phl manual code */

	/* end of ld_c_phl manual code */
	uint16_t src_adr = s_gb->gb_register.hl;
	uint8_t src_val = read8bit(src_adr, s_gb);
	s_gb->gb_register.c = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld c,a [0x4F] : The contents of a are loaded into c. */
static void ld_c_a(struct s_gb *s_gb)
{
	/* start of ld_c_a manual code */

	/* end of ld_c_a manual code */
	__typeof__(s_gb->gb_register.a) src_val = s_gb->gb_register.a;
	s_gb->gb_register.c = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld d,b [0x50] : The contents of b are loaded into d. */
static void ld_d_b(struct s_gb *s_gb)
{
	/* start of ld_d_b manual code */

	/* end of ld_d_b manual code */
	__typeof__(s_gb->gb_register.b) src_val = s_gb->gb_register.b;
	s_gb->gb_register.d = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld d,c [0x51] : The contents of c are loaded into d. */
static void ld_d_c(struct s_gb *s_gb)
{
	/* start of ld_d_c manual code */

	/* end of ld_d_c manual code */
	__typeof__(s_gb->gb_register.c) src_val = s_gb->gb_register.c;
	s_gb->gb_register.d = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld d,d [0x52] : The contents of d are loaded into d. */
static void ld_d_d(struct s_gb *s_gb)
{
	/* start of ld_d_d manual code */

	/* end of ld_d_d manual code */
	__typeof__(s_gb->gb_register.d) src_val = s_gb->gb_register.d;
	s_gb->gb_register.d = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld d,e [0x53] : The contents of e are loaded into d. */
static void ld_d_e(struct s_gb *s_gb)
{
	/* start of ld_d_e manual code */

	/* end of ld_d_e manual code */
	__typeof__(s_gb->gb_register.e) src_val = s_gb->gb_register.e;
	s_gb->gb_register.d = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld d,h [0x54] : The contents of h are loaded into d. */
static void ld_d_h(struct s_gb *s_gb)
{
	/* start of ld_d_h manual code */

	/* end of ld_d_h manual code */
	__typeof__(s_gb->gb_register.h) src_val = s_gb->gb_register.h;
	s_gb->gb_register.d = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld d,l [0x55] : The contents of l are loaded into d. */
static void ld_d_l(struct s_gb *s_gb)
{
	/* start of ld_d_l manual code */

	/* end of ld_d_l manual code */
	__typeof__(s_gb->gb_register.l) src_val = s_gb->gb_register.l;
	s_gb->gb_register.d = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld d,(hl) [0x56] : The contents of (hl) are loaded into d. */
static void ld_d_phl(struct s_gb *s_gb)
{
	/* start of ld_d_phl manual code */

	/* end of ld_d_phl manual code */
	uint16_t src_adr = s_gb->gb_register.hl;
	uint8_t src_val = read8bit(src_adr, s_gb);
	s_gb->gb_register.d = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld d,a [0x57] : The contents of a are loaded into d. */
static void ld_d_a(struct s_gb *s_gb)
{
	/* start of ld_d_a manual code */

	/* end of ld_d_a manual code */
	__typeof__(s_gb->gb_register.a) src_val = s_gb->gb_register.a;
	s_gb->gb_register.d = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld e,b [0x58] : The contents of b are loaded into e. */
static void ld_e_b(struct s_gb *s_gb)
{
	/* start of ld_e_b manual code */

	/* end of ld_e_b manual code */
	__typeof__(s_gb->gb_register.b) src_val = s_gb->gb_register.b;
	s_gb->gb_register.e = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld e,c [0x59] : The contents of c are loaded into e. */
static void ld_e_c(struct s_gb *s_gb)
{
	/* start of ld_e_c manual code */

	/* end of ld_e_c manual code */
	__typeof__(s_gb->gb_register.c) src_val = s_gb->gb_register.c;
	s_gb->gb_register.e = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld e,d [0x5A] : The contents of d are loaded into e. */
static void ld_e_d(struct s_gb *s_gb)
{
	/* start of ld_e_d manual code */

	/* end of ld_e_d manual code */
	__typeof__(s_gb->gb_register.d) src_val = s_gb->gb_register.d;
	s_gb->gb_register.e = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld e,e [0x5B] : The contents of e are loaded into e. */
static void ld_e_e(struct s_gb *s_gb)
{
	/* start of ld_e_e manual code */

	/* end of ld_e_e manual code */
	__typeof__(s_gb->gb_register.e) src_val = s_gb->gb_register.e;
	s_gb->gb_register.e = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld e,h [0x5C] : The contents of h are loaded into e. */
static void ld_e_h(struct s_gb *s_gb)
{
	/* start of ld_e_h manual code */

	/* end of ld_e_h manual code */
	__typeof__(s_gb->gb_register.h) src_val = s_gb->gb_register.h;
	s_gb->gb_register.e = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld e,l [0x5D] : The contents of l are loaded into e. */
static void ld_e_l(struct s_gb *s_gb)
{
	/* start of ld_e_l manual code */

	/* end of ld_e_l manual code */
	__typeof__(s_gb->gb_register.l) src_val = s_gb->gb_register.l;
	s_gb->gb_register.e = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld e,(hl) [0x5E] : The contents of (hl) are loaded into e. */
static void ld_e_phl(struct s_gb *s_gb)
{
	/* start of ld_e_phl manual code */

	/* end of ld_e_phl manual code */
	uint16_t src_adr = s_gb->gb_register.hl;
	uint8_t src_val = read8bit(src_adr, s_gb);
	s_gb->gb_register.e = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld e,a [0x5F] : The contents of a are loaded into e. */
static void ld_e_a(struct s_gb *s_gb)
{
	/* start of ld_e_a manual code */

	/* end of ld_e_a manual code */
	__typeof__(s_gb->gb_register.a) src_val = s_gb->gb_register.a;
	s_gb->gb_register.e = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld h,b [0x60] : The contents of b are loaded into h. */
static void ld_h_b(struct s_gb *s_gb)
{
	/* start of ld_h_b manual code */

	/* end of ld_h_b manual code */
	__typeof__(s_gb->gb_register.b) src_val = s_gb->gb_register.b;
	s_gb->gb_register.h = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld h,c [0x61] : The contents of c are loaded into h. */
static void ld_h_c(struct s_gb *s_gb)
{
	/* start of ld_h_c manual code */

	/* end of ld_h_c manual code */
	__typeof__(s_gb->gb_register.c) src_val = s_gb->gb_register.c;
	s_gb->gb_register.h = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld h,d [0x62] : The contents of d are loaded into h. */
static void ld_h_d(struct s_gb *s_gb)
{
	/* start of ld_h_d manual code */

	/* end of ld_h_d manual code */
	__typeof__(s_gb->gb_register.d) src_val = s_gb->gb_register.d;
	s_gb->gb_register.h = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld h,e [0x63] : The contents of e are loaded into h. */
static void ld_h_e(struct s_gb *s_gb)
{
	/* start of ld_h_e manual code */

	/* end of ld_h_e manual code */
	__typeof__(s_gb->gb_register.e) src_val = s_gb->gb_register.e;
	s_gb->gb_register.h = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld h,h [0x64] : The contents of h are loaded into h. */
static void ld_h_h(struct s_gb *s_gb)
{
	/* start of ld_h_h manual code */

	/* end of ld_h_h manual code */
	__typeof__(s_gb->gb_register.h) src_val = s_gb->gb_register.h;
	s_gb->gb_register.h = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld h,l [0x65] : The contents of l are loaded into h. */
static void ld_h_l(struct s_gb *s_gb)
{
	/* start of ld_h_l manual code */

	/* end of ld_h_l manual code */
	__typeof__(s_gb->gb_register.l) src_val = s_gb->gb_register.l;
	s_gb->gb_register.h = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld h,(hl) [0x66] : The contents of (hl) are loaded into h. */
static void ld_h_phl(struct s_gb *s_gb)
{
	/* start of ld_h_phl manual code */

	/* end of ld_h_phl manual code */
	uint16_t src_adr = s_gb->gb_register.hl;
	uint8_t src_val = read8bit(src_adr, s_gb);
	s_gb->gb_register.h = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld h,a [0x67] : The contents of a are loaded into h. */
static void ld_h_a(struct s_gb *s_gb)
{
	/* start of ld_h_a manual code */

	/* end of ld_h_a manual code */
	__typeof__(s_gb->gb_register.a) src_val = s_gb->gb_register.a;
	s_gb->gb_register.h = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld l,b [0x68] : The contents of b are loaded into l. */
static void ld_l_b(struct s_gb *s_gb)
{
	/* start of ld_l_b manual code */

	/* end of ld_l_b manual code */
	__typeof__(s_gb->gb_register.b) src_val = s_gb->gb_register.b;
	s_gb->gb_register.l = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld l,c [0x69] : The contents of c are loaded into l. */
static void ld_l_c(struct s_gb *s_gb)
{
	/* start of ld_l_c manual code */

	/* end of ld_l_c manual code */
	__typeof__(s_gb->gb_register.c) src_val = s_gb->gb_register.c;
	s_gb->gb_register.l = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld l,d [0x6A] : The contents of d are loaded into l. */
static void ld_l_d(struct s_gb *s_gb)
{
	/* start of ld_l_d manual code */

	/* end of ld_l_d manual code */
	__typeof__(s_gb->gb_register.d) src_val = s_gb->gb_register.d;
	s_gb->gb_register.l = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld l,e [0x6B] : The contents of e are loaded into l. */
static void ld_l_e(struct s_gb *s_gb)
{
	/* start of ld_l_e manual code */

	/* end of ld_l_e manual code */
	__typeof__(s_gb->gb_register.e) src_val = s_gb->gb_register.e;
	s_gb->gb_register.l = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld l,h [0x6C] : The contents of h are loaded into l. */
static void ld_l_h(struct s_gb *s_gb)
{
	/* start of ld_l_h manual code */

	/* end of ld_l_h manual code */
	__typeof__(s_gb->gb_register.h) src_val = s_gb->gb_register.h;
	s_gb->gb_register.l = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld l,l [0x6D] : The contents of l are loaded into l. */
static void ld_l_l(struct s_gb *s_gb)
{
	/* start of ld_l_l manual code */

	/* end of ld_l_l manual code */
	__typeof__(s_gb->gb_register.l) src_val = s_gb->gb_register.l;
	s_gb->gb_register.l = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld l,(hl) [0x6E] : The contents of (hl) are loaded into l. */
static void ld_l_phl(struct s_gb *s_gb)
{
	/* start of ld_l_phl manual code */

	/* end of ld_l_phl manual code */
	uint16_t src_adr = s_gb->gb_register.hl;
	uint8_t src_val = read8bit(src_adr, s_gb);
	s_gb->gb_register.l = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld l,a [0x6F] : The contents of a are loaded into l. */
static void ld_l_a(struct s_gb *s_gb)
{
	/* start of ld_l_a manual code */

	/* end of ld_l_a manual code */
	__typeof__(s_gb->gb_register.a) src_val = s_gb->gb_register.a;
	s_gb->gb_register.l = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld (hl),b [0x70] : The contents of b are loaded into (hl). */
static void ld_phl_b(struct s_gb *s_gb)
{
	/* start of ld_phl_b manual code */

	/* end of ld_phl_b manual code */
	__typeof__(s_gb->gb_register.b) src_val = s_gb->gb_register.b;
	uint16_t dst_adr = s_gb->gb_register.hl;
	write8bit(dst_adr, src_val, s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld (hl),c [0x71] : The contents of c are loaded into (hl). */
static void ld_phl_c(struct s_gb *s_gb)
{
	/* start of ld_phl_c manual code */

	/* end of ld_phl_c manual code */
	__typeof__(s_gb->gb_register.c) src_val = s_gb->gb_register.c;
	uint16_t dst_adr = s_gb->gb_register.hl;
	write8bit(dst_adr, src_val, s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld (hl),d [0x72] : The contents of d are loaded into (hl). */
static void ld_phl_d(struct s_gb *s_gb)
{
	/* start of ld_phl_d manual code */

	/* end of ld_phl_d manual code */
	__typeof__(s_gb->gb_register.d) src_val = s_gb->gb_register.d;
	uint16_t dst_adr = s_gb->gb_register.hl;
	write8bit(dst_adr, src_val, s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld (hl),e [0x73] : The contents of e are loaded into (hl). */
static void ld_phl_e(struct s_gb *s_gb)
{
	/* start of ld_phl_e manual code */

	/* end of ld_phl_e manual code */
	__typeof__(s_gb->gb_register.e) src_val = s_gb->gb_register.e;
	uint16_t dst_adr = s_gb->gb_register.hl;
	write8bit(dst_adr, src_val, s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld (hl),h [0x74] : The contents of h are loaded into (hl). */
static void ld_phl_h(struct s_gb *s_gb)
{
	/* start of ld_phl_h manual code */

	/* end of ld_phl_h manual code */
	__typeof__(s_gb->gb_register.h) src_val = s_gb->gb_register.h;
	uint16_t dst_adr = s_gb->gb_register.hl;
	write8bit(dst_adr, src_val, s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld (hl),l [0x75] : The contents of l are loaded into (hl). */
static void ld_phl_l(struct s_gb *s_gb)
{
	/* start of ld_phl_l manual code */

	/* end of ld_phl_l manual code */
	__typeof__(s_gb->gb_register.l) src_val = s_gb->gb_register.l;
	uint16_t dst_adr = s_gb->gb_register.hl;
	write8bit(dst_adr, src_val, s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* halt [0x76] : Suspends CPU operation until an interrupt or reset occurs. */
static void halt(struct s_gb *s_gb)
{
	/* start of halt manual code */

	/* end of halt manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld (hl),a [0x77] : The contents of a are loaded into (hl). */
static void ld_phl_a(struct s_gb *s_gb)
{
	/* start of ld_phl_a manual code */

	/* end of ld_phl_a manual code */
	__typeof__(s_gb->gb_register.a) src_val = s_gb->gb_register.a;
	uint16_t dst_adr = s_gb->gb_register.hl;
	write8bit(dst_adr, src_val, s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld a,b [0x78] : The contents of b are loaded into a. */
static void ld_a_b(struct s_gb *s_gb)
{
	/* start of ld_a_b manual code */

	/* end of ld_a_b manual code */
	__typeof__(s_gb->gb_register.b) src_val = s_gb->gb_register.b;
	s_gb->gb_register.a = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld a,c [0x79] : The contents of c are loaded into a. */
static void ld_a_c(struct s_gb *s_gb)
{
	/* start of ld_a_c manual code */

	/* end of ld_a_c manual code */
	__typeof__(s_gb->gb_register.c) src_val = s_gb->gb_register.c;
	s_gb->gb_register.a = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld a,d [0x7A] : The contents of d are loaded into a. */
static void ld_a_d(struct s_gb *s_gb)
{
	/* start of ld_a_d manual code */

	/* end of ld_a_d manual code */
	__typeof__(s_gb->gb_register.d) src_val = s_gb->gb_register.d;
	s_gb->gb_register.a = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld a,e [0x7B] : The contents of e are loaded into a. */
static void ld_a_e(struct s_gb *s_gb)
{
	/* start of ld_a_e manual code */

	/* end of ld_a_e manual code */
	__typeof__(s_gb->gb_register.e) src_val = s_gb->gb_register.e;
	s_gb->gb_register.a = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld a,h [0x7C] : The contents of h are loaded into a. */
static void ld_a_h(struct s_gb *s_gb)
{
	/* start of ld_a_h manual code */

	/* end of ld_a_h manual code */
	__typeof__(s_gb->gb_register.h) src_val = s_gb->gb_register.h;
	s_gb->gb_register.a = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld a,l [0x7D] : The contents of l are loaded into a. */
static void ld_a_l(struct s_gb *s_gb)
{
	/* start of ld_a_l manual code */

	/* end of ld_a_l manual code */
	__typeof__(s_gb->gb_register.l) src_val = s_gb->gb_register.l;
	s_gb->gb_register.a = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld a,(hl) [0x7E] : The contents of (hl) are loaded into a. */
static void ld_a_phl(struct s_gb *s_gb)
{
	/* start of ld_a_phl manual code */

	/* end of ld_a_phl manual code */
	uint16_t src_adr = s_gb->gb_register.hl;
	uint8_t src_val = read8bit(src_adr, s_gb);
	s_gb->gb_register.a = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld a,a [0x7F] : The contents of a are loaded into a. */
static void ld_a_a(struct s_gb *s_gb)
{
	/* start of ld_a_a manual code */

	/* end of ld_a_a manual code */
	__typeof__(s_gb->gb_register.a) src_val = s_gb->gb_register.a;
	s_gb->gb_register.a = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* add a,b [0x80] : Adds b to a. */
static void add_a_b(struct s_gb *s_gb)
{
	/* start of add_a_b manual code */

	/* end of add_a_b manual code */
	uint32_t result = s_gb->gb_register.a + s_gb->gb_register.b;
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.a & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a = 0xffffu & result;
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* add a,c [0x81] : Adds c to a. */
static void add_a_c(struct s_gb *s_gb)
{
	/* start of add_a_c manual code */

	/* end of add_a_c manual code */
	uint32_t result = s_gb->gb_register.a + s_gb->gb_register.c;
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.a & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a = 0xffffu & result;
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* add a,d [0x82] : Adds d to a. */
static void add_a_d(struct s_gb *s_gb)
{
	/* start of add_a_d manual code */

	/* end of add_a_d manual code */
	uint32_t result = s_gb->gb_register.a + s_gb->gb_register.d;
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.a & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a = 0xffffu & result;
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* add a,e [0x83] : Adds e to a. */
static void add_a_e(struct s_gb *s_gb)
{
	/* start of add_a_e manual code */

	/* end of add_a_e manual code */
	uint32_t result = s_gb->gb_register.a + s_gb->gb_register.e;
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.a & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a = 0xffffu & result;
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* add a,h [0x84] : Adds h to a. */
static void add_a_h(struct s_gb *s_gb)
{
	/* start of add_a_h manual code */

	/* end of add_a_h manual code */
	uint32_t result = s_gb->gb_register.a + s_gb->gb_register.h;
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.a & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a = 0xffffu & result;
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* add a,l [0x85] : Adds l to a. */
static void add_a_l(struct s_gb *s_gb)
{
	/* start of add_a_l manual code */

	/* end of add_a_l manual code */
	uint32_t result = s_gb->gb_register.a + s_gb->gb_register.l;
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.a & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a = 0xffffu & result;
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* add a,(hl) [0x86] : Adds (hl) to a. */
static void add_a_phl(struct s_gb *s_gb)
{
	/* start of add_a_phl manual code */

	/* end of add_a_phl manual code */
	uint32_t result = s_gb->gb_register.a + read16bit(s_gb->gb_register.hl, s_gb);
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.a & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a = 0xffffu & result;
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* add a,a [0x87] : Adds a to a. */
static void add_a_a(struct s_gb *s_gb)
{
	/* start of add_a_a manual code */

	/* end of add_a_a manual code */
	uint32_t result = s_gb->gb_register.a + s_gb->gb_register.a;
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.a & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a = 0xffffu & result;
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* adc a,b [0x88] : Adds b and the carry flag to a. */
static void adc_a_b(struct s_gb *s_gb)
{
	/* start of adc_a_b manual code */

	/* end of adc_a_b manual code */
	uint32_t result = s_gb->gb_register.a + s_gb->gb_register.b;
	result += FLAGS_ISCARRY(s_gb->gb_register.f);
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.a & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a = 0xffffu & result;
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* adc a,c [0x89] : Adds c and the carry flag to a. */
static void adc_a_c(struct s_gb *s_gb)
{
	/* start of adc_a_c manual code */

	/* end of adc_a_c manual code */
	uint32_t result = s_gb->gb_register.a + s_gb->gb_register.c;
	result += FLAGS_ISCARRY(s_gb->gb_register.f);
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.a & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a = 0xffffu & result;
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* adc a,d [0x8A] : Adds d and the carry flag to a. */
static void adc_a_d(struct s_gb *s_gb)
{
	/* start of adc_a_d manual code */

	/* end of adc_a_d manual code */
	uint32_t result = s_gb->gb_register.a + s_gb->gb_register.d;
	result += FLAGS_ISCARRY(s_gb->gb_register.f);
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.a & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a = 0xffffu & result;
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* adc a,e [0x8B] : Adds e and the carry flag to a. */
static void adc_a_e(struct s_gb *s_gb)
{
	/* start of adc_a_e manual code */

	/* end of adc_a_e manual code */
	uint32_t result = s_gb->gb_register.a + s_gb->gb_register.e;
	result += FLAGS_ISCARRY(s_gb->gb_register.f);
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.a & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a = 0xffffu & result;
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* adc a,h [0x8C] : Adds h and the carry flag to a. */
static void adc_a_h(struct s_gb *s_gb)
{
	/* start of adc_a_h manual code */

	/* end of adc_a_h manual code */
	uint32_t result = s_gb->gb_register.a + s_gb->gb_register.h;
	result += FLAGS_ISCARRY(s_gb->gb_register.f);
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.a & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a = 0xffffu & result;
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* adc a,l [0x8D] : Adds l and the carry flag to a. */
static void adc_a_l(struct s_gb *s_gb)
{
	/* start of adc_a_l manual code */

	/* end of adc_a_l manual code */
	uint32_t result = s_gb->gb_register.a + s_gb->gb_register.l;
	result += FLAGS_ISCARRY(s_gb->gb_register.f);
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.a & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a = 0xffffu & result;
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* adc a,(hl) [0x8E] : Adds (hl) and the carry flag to a. */
static void adc_a_phl(struct s_gb *s_gb)
{
	/* start of adc_a_phl manual code */

	/* end of adc_a_phl manual code */
	uint32_t result = s_gb->gb_register.a + read16bit(s_gb->gb_register.hl, s_gb);
	result += FLAGS_ISCARRY(s_gb->gb_register.f);
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.a & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a = 0xffffu & result;
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* adc a,a [0x8F] : Adds a and the carry flag to a. */
static void adc_a_a(struct s_gb *s_gb)
{
	/* start of adc_a_a manual code */

	/* end of adc_a_a manual code */
	uint32_t result = s_gb->gb_register.a + s_gb->gb_register.a;
	result += FLAGS_ISCARRY(s_gb->gb_register.f);
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.a & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a = 0xffffu & result;
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* sub b [0x90] : Subtracts b from a. */
static void sub_b(struct s_gb *s_gb)
{
	/* start of sub_b manual code */

	/* end of sub_b manual code */

	if (s_gb->gb_register.b > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((s_gb->gb_register.b & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	if (s_gb->gb_register.a == s_gb->gb_register.b)
		SET_ZERO();
	else
		CLEAR_ZERO();

	s_gb->gb_register.a -= s_gb->gb_register.b;
	/* ZERO affected as defined */
	/* NEG set */
	SET_NEG();
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* sub c [0x91] : Subtracts c from a. */
static void sub_c(struct s_gb *s_gb)
{
	/* start of sub_c manual code */

	/* end of sub_c manual code */

	if (s_gb->gb_register.c > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((s_gb->gb_register.c & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	if (s_gb->gb_register.a == s_gb->gb_register.c)
		SET_ZERO();
	else
		CLEAR_ZERO();

	s_gb->gb_register.a -= s_gb->gb_register.c;
	/* ZERO affected as defined */
	/* NEG set */
	SET_NEG();
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* sub d [0x92] : Subtracts d from a. */
static void sub_d(struct s_gb *s_gb)
{
	/* start of sub_d manual code */

	/* end of sub_d manual code */

	if (s_gb->gb_register.d > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((s_gb->gb_register.d & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	if (s_gb->gb_register.a == s_gb->gb_register.d)
		SET_ZERO();
	else
		CLEAR_ZERO();

	s_gb->gb_register.a -= s_gb->gb_register.d;
	/* ZERO affected as defined */
	/* NEG set */
	SET_NEG();
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* sub e [0x93] : Subtracts e from a. */
static void sub_e(struct s_gb *s_gb)
{
	/* start of sub_e manual code */

	/* end of sub_e manual code */

	if (s_gb->gb_register.e > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((s_gb->gb_register.e & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	if (s_gb->gb_register.a == s_gb->gb_register.e)
		SET_ZERO();
	else
		CLEAR_ZERO();

	s_gb->gb_register.a -= s_gb->gb_register.e;
	/* ZERO affected as defined */
	/* NEG set */
	SET_NEG();
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* sub h [0x94] : Subtracts h from a. */
static void sub_h(struct s_gb *s_gb)
{
	/* start of sub_h manual code */

	/* end of sub_h manual code */

	if (s_gb->gb_register.h > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((s_gb->gb_register.h & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	if (s_gb->gb_register.a == s_gb->gb_register.h)
		SET_ZERO();
	else
		CLEAR_ZERO();

	s_gb->gb_register.a -= s_gb->gb_register.h;
	/* ZERO affected as defined */
	/* NEG set */
	SET_NEG();
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* sub l [0x95] : Subtracts l from a. */
static void sub_l(struct s_gb *s_gb)
{
	/* start of sub_l manual code */

	/* end of sub_l manual code */

	if (s_gb->gb_register.l > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((s_gb->gb_register.l & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	if (s_gb->gb_register.a == s_gb->gb_register.l)
		SET_ZERO();
	else
		CLEAR_ZERO();

	s_gb->gb_register.a -= s_gb->gb_register.l;
	/* ZERO affected as defined */
	/* NEG set */
	SET_NEG();
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* sub (hl) [0x96] : Subtracts (hl) from a. */
static void sub_phl(struct s_gb *s_gb)
{
	/* start of sub_phl manual code */

	/* end of sub_phl manual code */
	uint8_t value = read8bit(s_gb->gb_register.hl, s_gb);

	if (value > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((value & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	if (s_gb->gb_register.a == value)
		SET_ZERO();
	else
		CLEAR_ZERO();

	s_gb->gb_register.a -= value;
	/* ZERO affected as defined */
	/* NEG set */
	SET_NEG();
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* sub a [0x97] : Subtracts a from a. */
static void sub_a(struct s_gb *s_gb)
{
	/* start of sub_a manual code */

	/* end of sub_a manual code */
	s_gb->gb_register.a = 0;
	/* ZERO set */
	SET_ZERO();
	/* NEG set */
	SET_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* sbc b [0x98] : Subtracts b and the carry flag from a. */
static void sbc_b(struct s_gb *s_gb)
{
	/* start of sbc_b manual code */

	/* end of sbc_b manual code */
	uint8_t value = s_gb->gb_register.b;
	value += FLAGS_ISCARRY(s_gb->gb_register.f);
	if (value > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((value & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a -= value;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG set */
	SET_NEG();
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* sbc c [0x99] : Subtracts c and the carry flag from a. */
static void sbc_c(struct s_gb *s_gb)
{
	/* start of sbc_c manual code */

	/* end of sbc_c manual code */
	uint8_t value = s_gb->gb_register.c;
	value += FLAGS_ISCARRY(s_gb->gb_register.f);
	if (value > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((value & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a -= value;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG set */
	SET_NEG();
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* sbc d [0x9A] : Subtracts d and the carry flag from a. */
static void sbc_d(struct s_gb *s_gb)
{
	/* start of sbc_d manual code */

	/* end of sbc_d manual code */
	uint8_t value = s_gb->gb_register.d;
	value += FLAGS_ISCARRY(s_gb->gb_register.f);
	if (value > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((value & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a -= value;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG set */
	SET_NEG();
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* sbc e [0x9B] : Subtracts e and the carry flag from a. */
static void sbc_e(struct s_gb *s_gb)
{
	/* start of sbc_e manual code */

	/* end of sbc_e manual code */
	uint8_t value = s_gb->gb_register.e;
	value += FLAGS_ISCARRY(s_gb->gb_register.f);
	if (value > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((value & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a -= value;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG set */
	SET_NEG();
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* sbc h [0x9C] : Subtracts h and the carry flag from a. */
static void sbc_h(struct s_gb *s_gb)
{
	/* start of sbc_h manual code */

	/* end of sbc_h manual code */
	uint8_t value = s_gb->gb_register.h;
	value += FLAGS_ISCARRY(s_gb->gb_register.f);
	if (value > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((value & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a -= value;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG set */
	SET_NEG();
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* sbc l [0x9D] : Subtracts l and the carry flag from a. */
static void sbc_l(struct s_gb *s_gb)
{
	/* start of sbc_l manual code */

	/* end of sbc_l manual code */
	uint8_t value = s_gb->gb_register.l;
	value += FLAGS_ISCARRY(s_gb->gb_register.f);
	if (value > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((value & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a -= value;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG set */
	SET_NEG();
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* sbc (hl) [0x9E] : Subtracts (hl) and the carry flag from a. */
static void sbc_phl(struct s_gb *s_gb)
{
	/* start of sbc_phl manual code */

	/* end of sbc_phl manual code */
	uint8_t value = read8bit(s_gb->gb_register.hl, s_gb);
	value += FLAGS_ISCARRY(s_gb->gb_register.f);
	if (value > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((value & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a -= value;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG set */
	SET_NEG();
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* sbc a [0x9F] : Subtracts a and the carry flag from a. */
static void sbc_a(struct s_gb *s_gb)
{
	/* start of sbc_a manual code */

	/* end of sbc_a manual code */
	uint8_t value = s_gb->gb_register.a;
	value += FLAGS_ISCARRY(s_gb->gb_register.f);
	if (value > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((value & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a -= value;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG set */
	SET_NEG();
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* and b [0xA0] : Bitwise AND on a with b. */
static void and_b(struct s_gb *s_gb)
{
	/* start of and_b manual code */

	/* end of and_b manual code */

	s_gb->gb_register.a &= s_gb->gb_register.b;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* and c [0xA1] : Bitwise AND on a with c. */
static void and_c(struct s_gb *s_gb)
{
	/* start of and_c manual code */

	/* end of and_c manual code */

	s_gb->gb_register.a &= s_gb->gb_register.c;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* and d [0xA2] : Bitwise AND on a with d. */
static void and_d(struct s_gb *s_gb)
{
	/* start of and_d manual code */

	/* end of and_d manual code */

	s_gb->gb_register.a &= s_gb->gb_register.d;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* and e [0xA3] : Bitwise AND on a with e. */
static void and_e(struct s_gb *s_gb)
{
	/* start of and_e manual code */

	/* end of and_e manual code */

	s_gb->gb_register.a &= s_gb->gb_register.e;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* and h [0xA4] : Bitwise AND on a with h. */
static void and_h(struct s_gb *s_gb)
{
	/* start of and_h manual code */

	/* end of and_h manual code */

	s_gb->gb_register.a &= s_gb->gb_register.h;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* and l [0xA5] : Bitwise AND on a with l. */
static void and_l(struct s_gb *s_gb)
{
	/* start of and_l manual code */

	/* end of and_l manual code */

	s_gb->gb_register.a &= s_gb->gb_register.l;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* and (hl) [0xA6] : Bitwise AND on a with (hl). */
static void and_phl(struct s_gb *s_gb)
{
	/* start of and_phl manual code */

	/* end of and_phl manual code */
	uint8_t value = read8bit(s_gb->gb_register.hl, s_gb);

	s_gb->gb_register.a &= value;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* and a [0xA7] : Bitwise AND on a with a. */
static void and_a(struct s_gb *s_gb)
{
	/* start of and_a manual code */

	/* end of and_a manual code */

	s_gb->gb_register.a &= s_gb->gb_register.a;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* xor b [0xA8] : Bitwise XOR on a with b. */
static void xor_b(struct s_gb *s_gb)
{
	/* start of xor_b manual code */

	/* end of xor_b manual code */

	s_gb->gb_register.a ^= s_gb->gb_register.b;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* xor c [0xA9] : Bitwise XOR on a with c. */
static void xor_c(struct s_gb *s_gb)
{
	/* start of xor_c manual code */

	/* end of xor_c manual code */

	s_gb->gb_register.a ^= s_gb->gb_register.c;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* xor d [0xAA] : Bitwise XOR on a with d. */
static void xor_d(struct s_gb *s_gb)
{
	/* start of xor_d manual code */

	/* end of xor_d manual code */

	s_gb->gb_register.a ^= s_gb->gb_register.d;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* xor e [0xAB] : Bitwise XOR on a with e. */
static void xor_e(struct s_gb *s_gb)
{
	/* start of xor_e manual code */

	/* end of xor_e manual code */

	s_gb->gb_register.a ^= s_gb->gb_register.e;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* xor h [0xAC] : Bitwise XOR on a with h. */
static void xor_h(struct s_gb *s_gb)
{
	/* start of xor_h manual code */

	/* end of xor_h manual code */

	s_gb->gb_register.a ^= s_gb->gb_register.h;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* xor l [0xAD] : Bitwise XOR on a with l. */
static void xor_l(struct s_gb *s_gb)
{
	/* start of xor_l manual code */

	/* end of xor_l manual code */

	s_gb->gb_register.a ^= s_gb->gb_register.l;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* xor (hl) [0xAE] : Bitwise XOR on a with (hl). */
static void xor_phl(struct s_gb *s_gb)
{
	/* start of xor_phl manual code */

	/* end of xor_phl manual code */
	uint8_t value = read8bit(s_gb->gb_register.hl, s_gb);

	s_gb->gb_register.a ^= value;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* xor a [0xAF] : Bitwise XOR on a with a. */
static void xor_a(struct s_gb *s_gb)
{
	/* start of xor_a manual code */

	/* end of xor_a manual code */

	s_gb->gb_register.a ^= s_gb->gb_register.a;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* or b [0xB0] : Bitwise OR on a with b. */
static void or_b(struct s_gb *s_gb)
{
	/* start of or_b manual code */

	/* end of or_b manual code */

	s_gb->gb_register.a |= s_gb->gb_register.b;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* or c [0xB1] : Bitwise OR on a with c. */
static void or_c(struct s_gb *s_gb)
{
	/* start of or_c manual code */

	/* end of or_c manual code */

	s_gb->gb_register.a |= s_gb->gb_register.c;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* or d [0xB2] : Bitwise OR on a with d. */
static void or_d(struct s_gb *s_gb)
{
	/* start of or_d manual code */

	/* end of or_d manual code */

	s_gb->gb_register.a |= s_gb->gb_register.d;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* or e [0xB3] : Bitwise OR on a with e. */
static void or_e(struct s_gb *s_gb)
{
	/* start of or_e manual code */

	/* end of or_e manual code */

	s_gb->gb_register.a |= s_gb->gb_register.e;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* or h [0xB4] : Bitwise OR on a with h. */
static void or_h(struct s_gb *s_gb)
{
	/* start of or_h manual code */

	/* end of or_h manual code */

	s_gb->gb_register.a |= s_gb->gb_register.h;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* or l [0xB5] : Bitwise OR on a with l. */
static void or_l(struct s_gb *s_gb)
{
	/* start of or_l manual code */

	/* end of or_l manual code */

	s_gb->gb_register.a |= s_gb->gb_register.l;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* or (hl) [0xB6] : Bitwise OR on a with (hl). */
static void or_phl(struct s_gb *s_gb)
{
	/* start of or_phl manual code */

	/* end of or_phl manual code */
	uint8_t value = read8bit(s_gb->gb_register.hl, s_gb);

	s_gb->gb_register.a |= value;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* or a [0xB7] : Bitwise OR on a with a. */
static void or_a(struct s_gb *s_gb)
{
	/* start of or_a manual code */

	/* end of or_a manual code */

	s_gb->gb_register.a |= s_gb->gb_register.a;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* cp b [0xB8] : Subtracts b from a and affects flags according to the result. a is not modified. */
static void cp_b(struct s_gb *s_gb)
{
	/* start of cp_b manual code */

	/* end of cp_b manual code */

	if (s_gb->gb_register.b > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((s_gb->gb_register.b & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	if (s_gb->gb_register.a == s_gb->gb_register.b)
		SET_ZERO();
	else
		CLEAR_ZERO();

	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* cp c [0xB9] : Subtracts c from a and affects flags according to the result. a is not modified. */
static void cp_c(struct s_gb *s_gb)
{
	/* start of cp_c manual code */

	/* end of cp_c manual code */

	if (s_gb->gb_register.c > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((s_gb->gb_register.c & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	if (s_gb->gb_register.a == s_gb->gb_register.c)
		SET_ZERO();
	else
		CLEAR_ZERO();

	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* cp d [0xBA] : Subtracts d from a and affects flags according to the result. a is not modified. */
static void cp_d(struct s_gb *s_gb)
{
	/* start of cp_d manual code */

	/* end of cp_d manual code */

	if (s_gb->gb_register.d > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((s_gb->gb_register.d & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	if (s_gb->gb_register.a == s_gb->gb_register.d)
		SET_ZERO();
	else
		CLEAR_ZERO();

	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* cp e [0xBB] : Subtracts e from a and affects flags according to the result. a is not modified. */
static void cp_e(struct s_gb *s_gb)
{
	/* start of cp_e manual code */

	/* end of cp_e manual code */

	if (s_gb->gb_register.e > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((s_gb->gb_register.e & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	if (s_gb->gb_register.a == s_gb->gb_register.e)
		SET_ZERO();
	else
		CLEAR_ZERO();

	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* cp h [0xBC] : Subtracts h from a and affects flags according to the result. a is not modified. */
static void cp_h(struct s_gb *s_gb)
{
	/* start of cp_h manual code */

	/* end of cp_h manual code */

	if (s_gb->gb_register.h > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((s_gb->gb_register.h & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	if (s_gb->gb_register.a == s_gb->gb_register.h)
		SET_ZERO();
	else
		CLEAR_ZERO();

	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* cp l [0xBD] : Subtracts l from a and affects flags according to the result. a is not modified. */
static void cp_l(struct s_gb *s_gb)
{
	/* start of cp_l manual code */

	/* end of cp_l manual code */

	if (s_gb->gb_register.l > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((s_gb->gb_register.l & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	if (s_gb->gb_register.a == s_gb->gb_register.l)
		SET_ZERO();
	else
		CLEAR_ZERO();

	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* cp (hl) [0xBE] : Subtracts (hl) from a and affects flags according to the result. a is not modified. */
static void cp_phl(struct s_gb *s_gb)
{
	/* start of cp_phl manual code */

	/* end of cp_phl manual code */
	uint8_t value = read8bit(s_gb->gb_register.hl, s_gb);

	if (value > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((value & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	if (s_gb->gb_register.a == value)
		SET_ZERO();
	else
		CLEAR_ZERO();

	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* cp a [0xBF] : Subtracts a from a and affects flags according to the result. a is not modified. */
static void cp_a(struct s_gb *s_gb)
{
	/* start of cp_a manual code */

	/* end of cp_a manual code */
	s_gb->gb_register.a = 0;
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* ret nz [0xC0] : If condition cc is true, the top stack entry is popped into pc. */
static void ret_nz(struct s_gb *s_gb)
{
	/* start of ret_nz manual code */

	/* end of ret_nz manual code */
	s_gb->gb_register.pc++;
	if (!FLAGS_ISZERO(s_gb->gb_register.f))
		s_gb->gb_register.pc = pop16(s_gb);
	else
		s_gb->gb_register.pc += 0; /* size of address */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* pop bc [0xC1] : The memory location pointed to by sp is stored into c and sp is incremented. The memory location pointed to by sp is stored into b and sp is incremented again. */
static void pop_bc(struct s_gb *s_gb)
{
	/* start of pop_bc manual code */

	/* end of pop_bc manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* jp nz,** [0xC2] : If condition cc is true, ** is copied to pc. */
static void jp_nz_xx(struct s_gb *s_gb)
{
	/* start of jp_nz_xx manual code */

	/* end of jp_nz_xx manual code */
	s_gb->gb_register.pc++;
	if (!FLAGS_ISZERO(s_gb->gb_register.f))
		s_gb->gb_register.pc = read16bit(s_gb->gb_register.pc, s_gb);
	else
		s_gb->gb_register.pc += 2; /* size of address */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* jp ** [0xC3] : ** is copied to pc. */
static void jp_xx(struct s_gb *s_gb)
{
	/* start of jp_xx manual code */

	/* end of jp_xx manual code */
	s_gb->gb_register.pc = read16bit(s_gb->gb_register.pc, s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* call nz,** [0xC4] : If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **. */
static void call_nz_xx(struct s_gb *s_gb)
{
	/* start of call_nz_xx manual code */

	/* end of call_nz_xx manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* push bc [0xC5] : sp is decremented and b is stored into the memory location pointed to by sp. sp is decremented again and c is stored into the memory location pointed to by sp. */
static void push_bc(struct s_gb *s_gb)
{
	/* start of push_bc manual code */

	/* end of push_bc manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* add a,* [0xC6] : Adds * to a. */
static void add_a_x(struct s_gb *s_gb)
{
	/* start of add_a_x manual code */

	/* end of add_a_x manual code */
	uint32_t result = s_gb->gb_register.a + read8bit(s_gb->gb_register.pc + 1, s_gb);
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.a & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a = 0xffffu & result;
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* rst 00h [0xC7] : The current pc value plus one is pushed onto the stack, then is loaded with 00h. */
static void rst_00h(struct s_gb *s_gb)
{
	/* start of rst_00h manual code */

	/* end of rst_00h manual code */
	s_gb->gb_register.sp -= 2;
	write16bitToAddr(s_gb->gb_register.sp, s_gb->gb_register.pc, s_gb);
	s_gb->gb_register.pc = 0x00;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ret z [0xC8] : If condition cc is true, the top stack entry is popped into pc. */
static void ret_z(struct s_gb *s_gb)
{
	/* start of ret_z manual code */

	/* end of ret_z manual code */
	s_gb->gb_register.pc++;
	if (FLAGS_ISZERO(s_gb->gb_register.f))
		s_gb->gb_register.pc = pop16(s_gb);
	else
		s_gb->gb_register.pc += 0; /* size of address */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ret [0xC9] : The top stack entry is popped into pc. */
static void ret(struct s_gb *s_gb)
{
	/* start of ret manual code */

	/* end of ret manual code */
	s_gb->gb_register.pc = pop16(s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* jp z,** [0xCA] : If condition cc is true, ** is copied to pc. */
static void jp_z_xx(struct s_gb *s_gb)
{
	/* start of jp_z_xx manual code */

	/* end of jp_z_xx manual code */
	s_gb->gb_register.pc++;
	if (FLAGS_ISZERO(s_gb->gb_register.f))
		s_gb->gb_register.pc = read16bit(s_gb->gb_register.pc, s_gb);
	else
		s_gb->gb_register.pc += 2; /* size of address */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* exec 0xCB [0xCB] : execute instruction in subtable 0xCB */
static void exec_0xCB(struct s_gb *s_gb)
{
	/* start of exec_0xCB manual code */

	/* end of exec_0xCB manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* call z,** [0xCC] : If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **. */
static void call_z_xx(struct s_gb *s_gb)
{
	/* start of call_z_xx manual code */

	/* end of call_z_xx manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* call ** [0xCD] : Push address of next instruction onto the stack and then jump to address **. */
static void call_xx(struct s_gb *s_gb)
{
	/* start of call_xx manual code */

	/* end of call_xx manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* adc a,* [0xCE] : Adds * and the carry flag to a. */
static void adc_a_x(struct s_gb *s_gb)
{
	/* start of adc_a_x manual code */

	/* end of adc_a_x manual code */
	uint32_t result = s_gb->gb_register.a + read8bit(s_gb->gb_register.pc + 1, s_gb);
	result += FLAGS_ISCARRY(s_gb->gb_register.f);
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.a & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a = 0xffffu & result;
	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* rst 08h [0xCF] : The current pc value plus one is pushed onto the stack, then is loaded with 08h. */
static void rst_08h(struct s_gb *s_gb)
{
	/* start of rst_08h manual code */

	/* end of rst_08h manual code */
	s_gb->gb_register.sp -= 2;
	write16bitToAddr(s_gb->gb_register.sp, s_gb->gb_register.pc, s_gb);
	s_gb->gb_register.pc = 0x08;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ret nc [0xD0] : If condition cc is true, the top stack entry is popped into pc. */
static void ret_nc(struct s_gb *s_gb)
{
	/* start of ret_nc manual code */

	/* end of ret_nc manual code */
	s_gb->gb_register.pc++;
	if (!FLAGS_ISCARRY(s_gb->gb_register.f))
		s_gb->gb_register.pc = pop16(s_gb);
	else
		s_gb->gb_register.pc += 0; /* size of address */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* pop de [0xD1] : The memory location pointed to by sp is stored into e and sp is incremented. The memory location pointed to by sp is stored into d and sp is incremented again. */
static void pop_de(struct s_gb *s_gb)
{
	/* start of pop_de manual code */

	/* end of pop_de manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* jp nc,** [0xD2] : If condition cc is true, ** is copied to pc. */
static void jp_nc_xx(struct s_gb *s_gb)
{
	/* start of jp_nc_xx manual code */

	/* end of jp_nc_xx manual code */
	s_gb->gb_register.pc++;
	if (!FLAGS_ISCARRY(s_gb->gb_register.f))
		s_gb->gb_register.pc = read16bit(s_gb->gb_register.pc, s_gb);
	else
		s_gb->gb_register.pc += 2; /* size of address */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* und [0xD3] : Undefined. */
static void und(struct s_gb *s_gb)
{
	/* start of und manual code */

	/* end of und manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* call nc,** [0xD4] : If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **. */
static void call_nc_xx(struct s_gb *s_gb)
{
	/* start of call_nc_xx manual code */

	/* end of call_nc_xx manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* push de [0xD5] : sp is decremented and d is stored into the memory location pointed to by sp. sp is decremented again and e is stored into the memory location pointed to by sp. */
static void push_de(struct s_gb *s_gb)
{
	/* start of push_de manual code */

	/* end of push_de manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* sub * [0xD6] : Subtracts * from a. */
static void sub_x(struct s_gb *s_gb)
{
	/* start of sub_x manual code */

	/* end of sub_x manual code */
	uint8_t value = read8bit(s_gb->gb_register.pc + 1, s_gb);

	if (value > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((value & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	if (s_gb->gb_register.a == value)
		SET_ZERO();
	else
		CLEAR_ZERO();

	s_gb->gb_register.a -= value;
	/* ZERO affected as defined */
	/* NEG set */
	SET_NEG();
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* rst 10h [0xD7] : The current pc value plus one is pushed onto the stack, then is loaded with 10h. */
static void rst_10h(struct s_gb *s_gb)
{
	/* start of rst_10h manual code */

	/* end of rst_10h manual code */
	s_gb->gb_register.sp -= 2;
	write16bitToAddr(s_gb->gb_register.sp, s_gb->gb_register.pc, s_gb);
	s_gb->gb_register.pc = 0x10;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ret c [0xD8] : If condition cc is true, the top stack entry is popped into pc. */
static void ret_c(struct s_gb *s_gb)
{
	/* start of ret_c manual code */

	/* end of ret_c manual code */
	s_gb->gb_register.pc++;
	if (FLAGS_ISCARRY(s_gb->gb_register.f))
		s_gb->gb_register.pc = pop16(s_gb);
	else
		s_gb->gb_register.pc += 0; /* size of address */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* reti [0xD9] : Pop two bytes from stack & jump to that address then enable interupts. */
static void reti(struct s_gb *s_gb)
{
	/* start of reti manual code */

	/* end of reti manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* jp c,** [0xDA] : If condition cc is true, ** is copied to pc. */
static void jp_c_xx(struct s_gb *s_gb)
{
	/* start of jp_c_xx manual code */

	/* end of jp_c_xx manual code */
	s_gb->gb_register.pc++;
	if (FLAGS_ISCARRY(s_gb->gb_register.f))
		s_gb->gb_register.pc = read16bit(s_gb->gb_register.pc, s_gb);
	else
		s_gb->gb_register.pc += 2; /* size of address */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* call c,** [0xDC] : If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **. */
static void call_c_xx(struct s_gb *s_gb)
{
	/* start of call_c_xx manual code */

	/* end of call_c_xx manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* sbc * [0xDE] : Subtracts * and the carry flag from a. */
static void sbc_x(struct s_gb *s_gb)
{
	/* start of sbc_x manual code */

	/* end of sbc_x manual code */
	uint8_t value = read8bit(s_gb->gb_register.pc + 1, s_gb);
	value += FLAGS_ISCARRY(s_gb->gb_register.f);
	if (value > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((value & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.a -= value;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG set */
	SET_NEG();
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* rst 18h [0xDF] : The current pc value plus one is pushed onto the stack, then is loaded with 18h. */
static void rst_18h(struct s_gb *s_gb)
{
	/* start of rst_18h manual code */

	/* end of rst_18h manual code */
	s_gb->gb_register.sp -= 2;
	write16bitToAddr(s_gb->gb_register.sp, s_gb->gb_register.pc, s_gb);
	s_gb->gb_register.pc = 0x18;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld (*),a [0xE0] : Put a into memory address $FF00 + n. */
static void ld_px_a(struct s_gb *s_gb)
{
	/* start of ld_px_a manual code */

	/* end of ld_px_a manual code */
	__typeof__(s_gb->gb_register.a) src_val = s_gb->gb_register.a;
	uint16_t dst_adr = 0xFF00u + read8bit(s_gb->gb_register.pc + 1, s_gb);
	write8bit(dst_adr, src_val, s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* pop hl [0xE1] : The memory location pointed to by sp is stored into l and sp is incremented. The memory location pointed to by sp is stored into h and sp is incremented again. */
static void pop_hl(struct s_gb *s_gb)
{
	/* start of pop_hl manual code */

	/* end of pop_hl manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld (c),a [0xE2] : Put a into address $FF00 + register c. */
static void ld_pc_a(struct s_gb *s_gb)
{
	/* start of ld_pc_a manual code */

	/* end of ld_pc_a manual code */
	__typeof__(s_gb->gb_register.a) src_val = s_gb->gb_register.a;
	uint16_t dst_adr = 0xFF00u + s_gb->gb_register.c;
	write8bit(dst_adr, src_val, s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* push hl [0xE5] : sp is decremented and h is stored into the memory location pointed to by sp. sp is decremented again and l is stored into the memory location pointed to by sp. */
static void push_hl(struct s_gb *s_gb)
{
	/* start of push_hl manual code */

	/* end of push_hl manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* and * [0xE6] : Bitwise AND on a with *. */
static void and_x(struct s_gb *s_gb)
{
	/* start of and_x manual code */

	/* end of and_x manual code */
	uint8_t value = read8bit(s_gb->gb_register.pc + 1, s_gb);

	s_gb->gb_register.a &= value;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* rst 20h [0xE7] : The current pc value plus one is pushed onto the stack, then is loaded with 20h. */
static void rst_20h(struct s_gb *s_gb)
{
	/* start of rst_20h manual code */

	/* end of rst_20h manual code */
	s_gb->gb_register.sp -= 2;
	write16bitToAddr(s_gb->gb_register.sp, s_gb->gb_register.pc, s_gb);
	s_gb->gb_register.pc = 0x20;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* add sp,* [0xE8] : If condition cc is true, the top stack entry is popped into pc. */
static void add_sp_x(struct s_gb *s_gb)
{
	/* start of add_sp_x manual code */

	/* end of add_sp_x manual code */
	uint32_t result = s_gb->gb_register.sp + read8bit(s_gb->gb_register.pc + 1, s_gb);
	if (result & 0xffff0000)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if (((s_gb->gb_register.sp & 0x0f) + (result & 0x0f)) > 0x0f)
		SET_HALFC();
	else
		CLEAR_HALFC();

	s_gb->gb_register.sp = 0xffffu & result;
	/* ZERO reset */
	CLEAR_ZERO();
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* jp (hl) [0xE9] : Loads the value of hl into pc. */
static void jp_phl(struct s_gb *s_gb)
{
	/* start of jp_phl manual code */

	/* end of jp_phl manual code */
	s_gb->gb_register.pc = read16bit(s_gb->gb_register.hl, s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld (**),a [0xEA] : Put a into memory location **. */
static void ld_pxx_a(struct s_gb *s_gb)
{
	/* start of ld_pxx_a manual code */

	/* end of ld_pxx_a manual code */
	__typeof__(s_gb->gb_register.a) src_val = s_gb->gb_register.a;
	uint16_t dst_adr = read16bit(s_gb->gb_register.pc + 1, s_gb);
	write8bit(dst_adr, src_val, s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* xor * [0xEE] : Bitwise XOR on a with *. */
static void xor_x(struct s_gb *s_gb)
{
	/* start of xor_x manual code */

	/* end of xor_x manual code */
	uint8_t value = read8bit(s_gb->gb_register.pc + 1, s_gb);

	s_gb->gb_register.a ^= value;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* rst 28h [0xEF] : The current pc value plus one is pushed onto the stack, then is loaded with 28h. */
static void rst_28h(struct s_gb *s_gb)
{
	/* start of rst_28h manual code */

	/* end of rst_28h manual code */
	s_gb->gb_register.sp -= 2;
	write16bitToAddr(s_gb->gb_register.sp, s_gb->gb_register.pc, s_gb);
	s_gb->gb_register.pc = 0x28;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld a,(*) [0xF0] : Put memory address $FF00 + * into a. */
static void ld_a_px(struct s_gb *s_gb)
{
	/* start of ld_a_px manual code */

	/* end of ld_a_px manual code */
	uint16_t src_adr = 0xFF00u + read8bit(s_gb->gb_register.pc + 1, s_gb);
	uint8_t src_val = read8bit(src_adr, s_gb);
	s_gb->gb_register.a = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* pop af [0xF1] : The memory location pointed to by sp is stored into f and sp is incremented. The memory location pointed to by sp is stored into a and sp is incremented again. */
static void pop_af(struct s_gb *s_gb)
{
	/* start of pop_af manual code */

	/* end of pop_af manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld a,(c) [0xF2] : Put memory address $FF00 + c into a. */
static void ld_a_pc(struct s_gb *s_gb)
{
	/* start of ld_a_pc manual code */

	/* end of ld_a_pc manual code */
	uint16_t src_adr = 0xFF00u + s_gb->gb_register.c;
	uint8_t src_val = read8bit(src_adr, s_gb);
	s_gb->gb_register.a = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* di [0xF3] : Disable interrupts but not immediately. Interrupts are disabled after instruction after DI is executed. */
static void di(struct s_gb *s_gb)
{
	/* start of di manual code */

	/* end of di manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* push af [0xF5] : sp is decremented and a is stored into the memory location pointed to by sp. sp is decremented again and f is stored into the memory location pointed to by sp. */
static void push_af(struct s_gb *s_gb)
{
	/* start of push_af manual code */

	/* end of push_af manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* or * [0xF6] : Bitwise OR on a with *. */
static void or_x(struct s_gb *s_gb)
{
	/* start of or_x manual code */

	/* end of or_x manual code */
	uint8_t value = read8bit(s_gb->gb_register.pc + 1, s_gb);

	s_gb->gb_register.a |= value;

	if (s_gb->gb_register.a != 0)
		CLEAR_ZERO();
	else
		SET_ZERO();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY reset */
	CLEAR_CARRY();
}

/* rst 30h [0xF7] : The current pc value plus one is pushed onto the stack, then is loaded with 30h. */
static void rst_30h(struct s_gb *s_gb)
{
	/* start of rst_30h manual code */

	/* end of rst_30h manual code */
	s_gb->gb_register.sp -= 2;
	write16bitToAddr(s_gb->gb_register.sp, s_gb->gb_register.pc, s_gb);
	s_gb->gb_register.pc = 0x30;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ldhl sp,* [0xF8] : Put SP + * effective address into HL. */
static void ldhl_sp_x(struct s_gb *s_gb)
{
	/* start of ldhl_sp_x manual code */

	/* end of ldhl_sp_x manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld sp,hl [0xF9] : Loads the value of hl into sp. */
static void ld_sp_hl(struct s_gb *s_gb)
{
	/* start of ld_sp_hl manual code */

	/* end of ld_sp_hl manual code */
	__typeof__(s_gb->gb_register.hl) src_val = s_gb->gb_register.hl;
	s_gb->gb_register.sp = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ld a,(**) [0xFA] : Put value at address ** into a. */
static void ld_a_pxx(struct s_gb *s_gb)
{
	/* start of ld_a_pxx manual code */

	/* end of ld_a_pxx manual code */
	uint16_t src_adr = read16bit(s_gb->gb_register.pc + 1, s_gb);
	uint8_t src_val = read8bit(src_adr, s_gb);
	s_gb->gb_register.a = src_val;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* ei [0xFB] : Enable interrupts. This instruction enables interrupts but not immediately. Interrupts are enabled after instruction after EI is executed. */
static void ei(struct s_gb *s_gb)
{
	/* start of ei manual code */

	/* end of ei manual code */
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* cp * [0xFE] : Subtracts * from a and affects flags according to the result. a is not modified. */
static void cp_x(struct s_gb *s_gb)
{
	/* start of cp_x manual code */

	/* end of cp_x manual code */
	uint8_t value = read8bit(s_gb->gb_register.pc + 1, s_gb);

	if (value > s_gb->gb_register.a)
		SET_CARRY();
	else
		CLEAR_CARRY();

	if ((value & 0x0f) > (s_gb->gb_register.a & 0x0f))
		SET_HALFC();
	else
		CLEAR_HALFC();

	if (s_gb->gb_register.a == value)
		SET_ZERO();
	else
		CLEAR_ZERO();

	/* ZERO affected as defined */
	/* NEG affected as defined */
	/* HALFC affected as defined */
	/* CARRY affected as defined */
}

/* rst 38h [0xFF] : The current pc value plus one is pushed onto the stack, then is loaded with 38h. */
static void rst_38h(struct s_gb *s_gb)
{
	/* start of rst_38h manual code */

	/* end of rst_38h manual code */
	s_gb->gb_register.sp -= 2;
	write16bitToAddr(s_gb->gb_register.sp, s_gb->gb_register.pc, s_gb);
	s_gb->gb_register.pc = 0x38;
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

const struct s_cpu_z80 instructions_base[] = {
	[0x00] = {
		.opcode = 0x00,
		.value = "nop",
		.doc = "No operation is performed.",
		.cycles = 4,
		.size = 1,
		.func = nop,
	},
	[0x01] = {
		.opcode = 0x01,
		.value = "ld bc,**",
		.doc = "Loads ** into bc.",
		.cycles = 12,
		.size = 3,
		.func = ld_bc_xx,
	},
	[0x02] = {
		.opcode = 0x02,
		.value = "ld (bc),a",
		.doc = "Stores a into the memory location pointed to by bc.",
		.cycles = 8,
		.size = 1,
		.func = ld_pbc_a,
	},
	[0x03] = {
		.opcode = 0x03,
		.value = "inc bc",
		.doc = "Adds one to bc.",
		.cycles = 8,
		.size = 1,
		.func = inc_bc,
	},
	[0x04] = {
		.opcode = 0x04,
		.value = "inc b",
		.doc = "Adds one to b.",
		.cycles = 4,
		.size = 1,
		.func = inc_b,
	},
	[0x05] = {
		.opcode = 0x05,
		.value = "dec b",
		.doc = "Subtracts one from b.",
		.cycles = 4,
		.size = 1,
		.func = dec_b,
	},
	[0x06] = {
		.opcode = 0x06,
		.value = "ld b,*",
		.doc = "Loads * into b.",
		.cycles = 8,
		.size = 2,
		.func = ld_b_x,
	},
	[0x07] = {
		.opcode = 0x07,
		.value = "rlca",
		.doc = "The contents of a are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.",
		.cycles = 4,
		.size = 1,
		.func = rlca,
	},
	[0x08] = {
		.opcode = 0x08,
		.value = "ld (**),sp",
		.doc = "Loads ** into sp.",
		.cycles = 20,
		.size = 3,
		.func = ld_pxx_sp,
	},
	[0x09] = {
		.opcode = 0x09,
		.value = "add hl,bc",
		.doc = "The value of bc is added to hl.",
		.cycles = 8,
		.size = 1,
		.func = add_hl_bc,
	},
	[0x0A] = {
		.opcode = 0x0A,
		.value = "ld a,(bc)",
		.doc = "Loads the value pointed to by bc into a.",
		.cycles = 8,
		.size = 1,
		.func = ld_a_pbc,
	},
	[0x0B] = {
		.opcode = 0x0B,
		.value = "dec bc",
		.doc = "Subtracts one from bc.",
		.cycles = 8,
		.size = 1,
		.func = dec_bc,
	},
	[0x0C] = {
		.opcode = 0x0C,
		.value = "inc c",
		.doc = "Adds one to c.",
		.cycles = 4,
		.size = 1,
		.func = inc_c,
	},
	[0x0D] = {
		.opcode = 0x0D,
		.value = "dec c",
		.doc = "Subtracts one from c.",
		.cycles = 4,
		.size = 1,
		.func = dec_c,
	},
	[0x0E] = {
		.opcode = 0x0E,
		.value = "ld c,*",
		.doc = "Loads * into c.",
		.cycles = 8,
		.size = 2,
		.func = ld_c_x,
	},
	[0x0F] = {
		.opcode = 0x0F,
		.value = "rrca",
		.doc = "The contents of a are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.",
		.cycles = 4,
		.size = 1,
		.func = rrca,
	},
	[0x10] = {
		.opcode = 0x10,
		.value = "stop",
		.doc = "Halt CPU & LCD display until button pressed.",
		.cycles = 4,
		.size = 2,
		.func = stop,
	},
	[0x11] = {
		.opcode = 0x11,
		.value = "ld de,**",
		.doc = "Loads ** into de.",
		.cycles = 12,
		.size = 3,
		.func = ld_de_xx,
	},
	[0x12] = {
		.opcode = 0x12,
		.value = "ld (de),a",
		.doc = "Stores a into the memory location pointed to by de.",
		.cycles = 8,
		.size = 1,
		.func = ld_pde_a,
	},
	[0x13] = {
		.opcode = 0x13,
		.value = "inc de",
		.doc = "Adds one to de.",
		.cycles = 8,
		.size = 1,
		.func = inc_de,
	},
	[0x14] = {
		.opcode = 0x14,
		.value = "inc d",
		.doc = "Adds one to d.",
		.cycles = 4,
		.size = 1,
		.func = inc_d,
	},
	[0x15] = {
		.opcode = 0x15,
		.value = "dec d",
		.doc = "Subtracts one from d.",
		.cycles = 4,
		.size = 1,
		.func = dec_d,
	},
	[0x16] = {
		.opcode = 0x16,
		.value = "ld d,*",
		.doc = "Loads * into d.",
		.cycles = 8,
		.size = 2,
		.func = ld_d_x,
	},
	[0x17] = {
		.opcode = 0x17,
		.value = "rla",
		.doc = "The contents of a are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.",
		.cycles = 4,
		.size = 1,
		.func = rla,
	},
	[0x18] = {
		.opcode = 0x18,
		.value = "jr *",
		.doc = "The signed value * is added to pc. The jump is measured from the start of the instruction opcode.",
		.cycles = 8,
		.size = 0,
		.func = jr_x,
	},
	[0x19] = {
		.opcode = 0x19,
		.value = "add hl,de",
		.doc = "The value of de is added to hl.",
		.cycles = 8,
		.size = 1,
		.func = add_hl_de,
	},
	[0x1A] = {
		.opcode = 0x1A,
		.value = "ld a,(de)",
		.doc = "Loads the value pointed to by de into a.",
		.cycles = 8,
		.size = 1,
		.func = ld_a_pde,
	},
	[0x1B] = {
		.opcode = 0x1B,
		.value = "dec de",
		.doc = "Subtracts one from de.",
		.cycles = 8,
		.size = 1,
		.func = dec_de,
	},
	[0x1C] = {
		.opcode = 0x1C,
		.value = "inc e",
		.doc = "Adds one to e.",
		.cycles = 4,
		.size = 1,
		.func = inc_e,
	},
	[0x1D] = {
		.opcode = 0x1D,
		.value = "dec e",
		.doc = "Subtracts one from e.",
		.cycles = 4,
		.size = 1,
		.func = dec_e,
	},
	[0x1E] = {
		.opcode = 0x1E,
		.value = "ld e,*",
		.doc = "Loads * into e.",
		.cycles = 8,
		.size = 2,
		.func = ld_e_x,
	},
	[0x1F] = {
		.opcode = 0x1F,
		.value = "rra",
		.doc = "The contents of a are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.",
		.cycles = 4,
		.size = 1,
		.func = rra,
	},
	[0x20] = {
		.opcode = 0x20,
		.value = "jr nz,*",
		.doc = "If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode.",
		.cycles = 8,
		.size = 0,
		.func = jr_nz_x,
	},
	[0x21] = {
		.opcode = 0x21,
		.value = "ld hl,**",
		.doc = "Loads ** into hl.",
		.cycles = 12,
		.size = 3,
		.func = ld_hl_xx,
	},
	[0x22] = {
		.opcode = 0x22,
		.value = "ldi (hl),a",
		.doc = "Put a into memory location pointed to by hl. Increment hl.",
		.cycles = 8,
		.size = 3,
		.func = ldi_phl_a,
	},
	[0x23] = {
		.opcode = 0x23,
		.value = "inc hl",
		.doc = "Adds one to hl.",
		.cycles = 8,
		.size = 1,
		.func = inc_hl,
	},
	[0x24] = {
		.opcode = 0x24,
		.value = "inc h",
		.doc = "Adds one to h.",
		.cycles = 4,
		.size = 1,
		.func = inc_h,
	},
	[0x25] = {
		.opcode = 0x25,
		.value = "dec h",
		.doc = "Subtracts one from h.",
		.cycles = 4,
		.size = 1,
		.func = dec_h,
	},
	[0x26] = {
		.opcode = 0x26,
		.value = "ld h,*",
		.doc = "Loads * into h.",
		.cycles = 8,
		.size = 2,
		.func = ld_h_x,
	},
	[0x27] = {
		.opcode = 0x27,
		.value = "daa",
		.doc = "Adjusts a for BCD addition and subtraction operations.",
		.cycles = 4,
		.size = 1,
		.func = daa,
	},
	[0x28] = {
		.opcode = 0x28,
		.value = "jr z,*",
		.doc = "If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode.",
		.cycles = 8,
		.size = 0,
		.func = jr_z_x,
	},
	[0x29] = {
		.opcode = 0x29,
		.value = "add hl,hl",
		.doc = "The value of hl is added to hl.",
		.cycles = 8,
		.size = 1,
		.func = add_hl_hl,
	},
	[0x2A] = {
		.opcode = 0x2A,
		.value = "ldi a,(hl)",
		.doc = "Put the value at adress hl into a. Increment hl.",
		.cycles = 8,
		.size = 3,
		.func = ldi_a_phl,
	},
	[0x2B] = {
		.opcode = 0x2B,
		.value = "dec hl",
		.doc = "Subtracts one from hl.",
		.cycles = 8,
		.size = 1,
		.func = dec_hl,
	},
	[0x2C] = {
		.opcode = 0x2C,
		.value = "inc l",
		.doc = "Adds one to l.",
		.cycles = 4,
		.size = 1,
		.func = inc_l,
	},
	[0x2D] = {
		.opcode = 0x2D,
		.value = "dec l",
		.doc = "Subtracts one from l.",
		.cycles = 4,
		.size = 1,
		.func = dec_l,
	},
	[0x2E] = {
		.opcode = 0x2E,
		.value = "ld l,*",
		.doc = "Loads * into l.",
		.cycles = 8,
		.size = 2,
		.func = ld_l_x,
	},
	[0x2F] = {
		.opcode = 0x2F,
		.value = "cpl",
		.doc = "The contents of a are inverted (one's complement).",
		.cycles = 4,
		.size = 1,
		.func = cpl,
	},
	[0x30] = {
		.opcode = 0x30,
		.value = "jr nc,*",
		.doc = "If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode.",
		.cycles = 8,
		.size = 0,
		.func = jr_nc_x,
	},
	[0x31] = {
		.opcode = 0x31,
		.value = "ld sp,**",
		.doc = "Loads ** into sp.",
		.cycles = 12,
		.size = 3,
		.func = ld_sp_xx,
	},
	[0x32] = {
		.opcode = 0x32,
		.value = "ldd (hl),a",
		.doc = "Put a into memory adress hl. Decrement hl.",
		.cycles = 8,
		.size = 3,
		.func = ldd_phl_a,
	},
	[0x33] = {
		.opcode = 0x33,
		.value = "inc sp",
		.doc = "Adds one to sp.",
		.cycles = 8,
		.size = 1,
		.func = inc_sp,
	},
	[0x34] = {
		.opcode = 0x34,
		.value = "inc (hl)",
		.doc = "Adds one to (hl).",
		.cycles = 12,
		.size = 1,
		.func = inc_phl,
	},
	[0x35] = {
		.opcode = 0x35,
		.value = "dec (hl)",
		.doc = "Subtracts one from (hl).",
		.cycles = 12,
		.size = 1,
		.func = dec_phl,
	},
	[0x36] = {
		.opcode = 0x36,
		.value = "ld (hl),*",
		.doc = "Loads * into (hl).",
		.cycles = 12,
		.size = 2,
		.func = ld_phl_x,
	},
	[0x37] = {
		.opcode = 0x37,
		.value = "scf",
		.doc = "Sets the carry flag.",
		.cycles = 4,
		.size = 1,
		.func = scf,
	},
	[0x38] = {
		.opcode = 0x38,
		.value = "jr c,*",
		.doc = "If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode.",
		.cycles = 8,
		.size = 0,
		.func = jr_c_x,
	},
	[0x39] = {
		.opcode = 0x39,
		.value = "add hl,sp",
		.doc = "The value of hl is added to hl.",
		.cycles = 8,
		.size = 1,
		.func = add_hl_sp,
	},
	[0x3A] = {
		.opcode = 0x3A,
		.value = "ldd a,(hl)",
		.doc = "Put value at adress hl into a. Decrement hl.",
		.cycles = 8,
		.size = 3,
		.func = ldd_a_phl,
	},
	[0x3B] = {
		.opcode = 0x3B,
		.value = "dec sp",
		.doc = "Subtracts one from sp.",
		.cycles = 8,
		.size = 1,
		.func = dec_sp,
	},
	[0x3C] = {
		.opcode = 0x3C,
		.value = "inc a",
		.doc = "Adds one to a.",
		.cycles = 4,
		.size = 1,
		.func = inc_a,
	},
	[0x3D] = {
		.opcode = 0x3D,
		.value = "dec a",
		.doc = "Subtracts one from a.",
		.cycles = 4,
		.size = 1,
		.func = dec_a,
	},
	[0x3E] = {
		.opcode = 0x3E,
		.value = "ld a,*",
		.doc = "Loads * into a.",
		.cycles = 8,
		.size = 2,
		.func = ld_a_x,
	},
	[0x3F] = {
		.opcode = 0x3F,
		.value = "ccf",
		.doc = "Inverts the carry flag.",
		.cycles = 4,
		.size = 1,
		.func = ccf,
	},
	[0x40] = {
		.opcode = 0x40,
		.value = "ld b,b",
		.doc = "The contents of b are loaded into b.",
		.cycles = 4,
		.size = 1,
		.func = ld_b_b,
	},
	[0x41] = {
		.opcode = 0x41,
		.value = "ld b,c",
		.doc = "The contents of c are loaded into b.",
		.cycles = 4,
		.size = 1,
		.func = ld_b_c,
	},
	[0x42] = {
		.opcode = 0x42,
		.value = "ld b,d",
		.doc = "The contents of d are loaded into b.",
		.cycles = 4,
		.size = 1,
		.func = ld_b_d,
	},
	[0x43] = {
		.opcode = 0x43,
		.value = "ld b,e",
		.doc = "The contents of e are loaded into b.",
		.cycles = 4,
		.size = 1,
		.func = ld_b_e,
	},
	[0x44] = {
		.opcode = 0x44,
		.value = "ld b,h",
		.doc = "The contents of h are loaded into b.",
		.cycles = 4,
		.size = 1,
		.func = ld_b_h,
	},
	[0x45] = {
		.opcode = 0x45,
		.value = "ld b,l",
		.doc = "The contents of l are loaded into b.",
		.cycles = 4,
		.size = 1,
		.func = ld_b_l,
	},
	[0x46] = {
		.opcode = 0x46,
		.value = "ld b,(hl)",
		.doc = "The contents of (hl) are loaded into b.",
		.cycles = 8,
		.size = 1,
		.func = ld_b_phl,
	},
	[0x47] = {
		.opcode = 0x47,
		.value = "ld b,a",
		.doc = "The contents of a are loaded into b.",
		.cycles = 4,
		.size = 1,
		.func = ld_b_a,
	},
	[0x48] = {
		.opcode = 0x48,
		.value = "ld c,b",
		.doc = "The contents of b are loaded into c.",
		.cycles = 4,
		.size = 1,
		.func = ld_c_b,
	},
	[0x49] = {
		.opcode = 0x49,
		.value = "ld c,c",
		.doc = "The contents of c are loaded into c.",
		.cycles = 4,
		.size = 1,
		.func = ld_c_c,
	},
	[0x4A] = {
		.opcode = 0x4A,
		.value = "ld c,d",
		.doc = "The contents of d are loaded into c.",
		.cycles = 4,
		.size = 1,
		.func = ld_c_d,
	},
	[0x4B] = {
		.opcode = 0x4B,
		.value = "ld c,e",
		.doc = "The contents of e are loaded into c.",
		.cycles = 4,
		.size = 1,
		.func = ld_c_e,
	},
	[0x4C] = {
		.opcode = 0x4C,
		.value = "ld c,h",
		.doc = "The contents of h are loaded into c.",
		.cycles = 4,
		.size = 1,
		.func = ld_c_h,
	},
	[0x4D] = {
		.opcode = 0x4D,
		.value = "ld c,l",
		.doc = "The contents of l are loaded into c.",
		.cycles = 4,
		.size = 1,
		.func = ld_c_l,
	},
	[0x4E] = {
		.opcode = 0x4E,
		.value = "ld c,(hl)",
		.doc = "The contents of (hl) are loaded into c.",
		.cycles = 8,
		.size = 1,
		.func = ld_c_phl,
	},
	[0x4F] = {
		.opcode = 0x4F,
		.value = "ld c,a",
		.doc = "The contents of a are loaded into c.",
		.cycles = 4,
		.size = 1,
		.func = ld_c_a,
	},
	[0x50] = {
		.opcode = 0x50,
		.value = "ld d,b",
		.doc = "The contents of b are loaded into d.",
		.cycles = 4,
		.size = 1,
		.func = ld_d_b,
	},
	[0x51] = {
		.opcode = 0x51,
		.value = "ld d,c",
		.doc = "The contents of c are loaded into d.",
		.cycles = 4,
		.size = 1,
		.func = ld_d_c,
	},
	[0x52] = {
		.opcode = 0x52,
		.value = "ld d,d",
		.doc = "The contents of d are loaded into d.",
		.cycles = 4,
		.size = 1,
		.func = ld_d_d,
	},
	[0x53] = {
		.opcode = 0x53,
		.value = "ld d,e",
		.doc = "The contents of e are loaded into d.",
		.cycles = 4,
		.size = 1,
		.func = ld_d_e,
	},
	[0x54] = {
		.opcode = 0x54,
		.value = "ld d,h",
		.doc = "The contents of h are loaded into d.",
		.cycles = 4,
		.size = 1,
		.func = ld_d_h,
	},
	[0x55] = {
		.opcode = 0x55,
		.value = "ld d,l",
		.doc = "The contents of l are loaded into d.",
		.cycles = 4,
		.size = 1,
		.func = ld_d_l,
	},
	[0x56] = {
		.opcode = 0x56,
		.value = "ld d,(hl)",
		.doc = "The contents of (hl) are loaded into d.",
		.cycles = 8,
		.size = 1,
		.func = ld_d_phl,
	},
	[0x57] = {
		.opcode = 0x57,
		.value = "ld d,a",
		.doc = "The contents of a are loaded into d.",
		.cycles = 4,
		.size = 1,
		.func = ld_d_a,
	},
	[0x58] = {
		.opcode = 0x58,
		.value = "ld e,b",
		.doc = "The contents of b are loaded into e.",
		.cycles = 4,
		.size = 1,
		.func = ld_e_b,
	},
	[0x59] = {
		.opcode = 0x59,
		.value = "ld e,c",
		.doc = "The contents of c are loaded into e.",
		.cycles = 4,
		.size = 1,
		.func = ld_e_c,
	},
	[0x5A] = {
		.opcode = 0x5A,
		.value = "ld e,d",
		.doc = "The contents of d are loaded into e.",
		.cycles = 4,
		.size = 1,
		.func = ld_e_d,
	},
	[0x5B] = {
		.opcode = 0x5B,
		.value = "ld e,e",
		.doc = "The contents of e are loaded into e.",
		.cycles = 4,
		.size = 1,
		.func = ld_e_e,
	},
	[0x5C] = {
		.opcode = 0x5C,
		.value = "ld e,h",
		.doc = "The contents of h are loaded into e.",
		.cycles = 4,
		.size = 1,
		.func = ld_e_h,
	},
	[0x5D] = {
		.opcode = 0x5D,
		.value = "ld e,l",
		.doc = "The contents of l are loaded into e.",
		.cycles = 4,
		.size = 1,
		.func = ld_e_l,
	},
	[0x5E] = {
		.opcode = 0x5E,
		.value = "ld e,(hl)",
		.doc = "The contents of (hl) are loaded into e.",
		.cycles = 8,
		.size = 1,
		.func = ld_e_phl,
	},
	[0x5F] = {
		.opcode = 0x5F,
		.value = "ld e,a",
		.doc = "The contents of a are loaded into e.",
		.cycles = 4,
		.size = 1,
		.func = ld_e_a,
	},
	[0x60] = {
		.opcode = 0x60,
		.value = "ld h,b",
		.doc = "The contents of b are loaded into h.",
		.cycles = 4,
		.size = 1,
		.func = ld_h_b,
	},
	[0x61] = {
		.opcode = 0x61,
		.value = "ld h,c",
		.doc = "The contents of c are loaded into h.",
		.cycles = 4,
		.size = 1,
		.func = ld_h_c,
	},
	[0x62] = {
		.opcode = 0x62,
		.value = "ld h,d",
		.doc = "The contents of d are loaded into h.",
		.cycles = 4,
		.size = 1,
		.func = ld_h_d,
	},
	[0x63] = {
		.opcode = 0x63,
		.value = "ld h,e",
		.doc = "The contents of e are loaded into h.",
		.cycles = 4,
		.size = 1,
		.func = ld_h_e,
	},
	[0x64] = {
		.opcode = 0x64,
		.value = "ld h,h",
		.doc = "The contents of h are loaded into h.",
		.cycles = 4,
		.size = 1,
		.func = ld_h_h,
	},
	[0x65] = {
		.opcode = 0x65,
		.value = "ld h,l",
		.doc = "The contents of l are loaded into h.",
		.cycles = 4,
		.size = 1,
		.func = ld_h_l,
	},
	[0x66] = {
		.opcode = 0x66,
		.value = "ld h,(hl)",
		.doc = "The contents of (hl) are loaded into h.",
		.cycles = 8,
		.size = 1,
		.func = ld_h_phl,
	},
	[0x67] = {
		.opcode = 0x67,
		.value = "ld h,a",
		.doc = "The contents of a are loaded into h.",
		.cycles = 4,
		.size = 1,
		.func = ld_h_a,
	},
	[0x68] = {
		.opcode = 0x68,
		.value = "ld l,b",
		.doc = "The contents of b are loaded into l.",
		.cycles = 4,
		.size = 1,
		.func = ld_l_b,
	},
	[0x69] = {
		.opcode = 0x69,
		.value = "ld l,c",
		.doc = "The contents of c are loaded into l.",
		.cycles = 4,
		.size = 1,
		.func = ld_l_c,
	},
	[0x6A] = {
		.opcode = 0x6A,
		.value = "ld l,d",
		.doc = "The contents of d are loaded into l.",
		.cycles = 4,
		.size = 1,
		.func = ld_l_d,
	},
	[0x6B] = {
		.opcode = 0x6B,
		.value = "ld l,e",
		.doc = "The contents of e are loaded into l.",
		.cycles = 4,
		.size = 1,
		.func = ld_l_e,
	},
	[0x6C] = {
		.opcode = 0x6C,
		.value = "ld l,h",
		.doc = "The contents of h are loaded into l.",
		.cycles = 4,
		.size = 1,
		.func = ld_l_h,
	},
	[0x6D] = {
		.opcode = 0x6D,
		.value = "ld l,l",
		.doc = "The contents of l are loaded into l.",
		.cycles = 4,
		.size = 1,
		.func = ld_l_l,
	},
	[0x6E] = {
		.opcode = 0x6E,
		.value = "ld l,(hl)",
		.doc = "The contents of (hl) are loaded into l.",
		.cycles = 8,
		.size = 1,
		.func = ld_l_phl,
	},
	[0x6F] = {
		.opcode = 0x6F,
		.value = "ld l,a",
		.doc = "The contents of a are loaded into l.",
		.cycles = 4,
		.size = 1,
		.func = ld_l_a,
	},
	[0x70] = {
		.opcode = 0x70,
		.value = "ld (hl),b",
		.doc = "The contents of b are loaded into (hl).",
		.cycles = 8,
		.size = 1,
		.func = ld_phl_b,
	},
	[0x71] = {
		.opcode = 0x71,
		.value = "ld (hl),c",
		.doc = "The contents of c are loaded into (hl).",
		.cycles = 8,
		.size = 1,
		.func = ld_phl_c,
	},
	[0x72] = {
		.opcode = 0x72,
		.value = "ld (hl),d",
		.doc = "The contents of d are loaded into (hl).",
		.cycles = 8,
		.size = 1,
		.func = ld_phl_d,
	},
	[0x73] = {
		.opcode = 0x73,
		.value = "ld (hl),e",
		.doc = "The contents of e are loaded into (hl).",
		.cycles = 8,
		.size = 1,
		.func = ld_phl_e,
	},
	[0x74] = {
		.opcode = 0x74,
		.value = "ld (hl),h",
		.doc = "The contents of h are loaded into (hl).",
		.cycles = 8,
		.size = 1,
		.func = ld_phl_h,
	},
	[0x75] = {
		.opcode = 0x75,
		.value = "ld (hl),l",
		.doc = "The contents of l are loaded into (hl).",
		.cycles = 8,
		.size = 1,
		.func = ld_phl_l,
	},
	[0x76] = {
		.opcode = 0x76,
		.value = "halt",
		.doc = "Suspends CPU operation until an interrupt or reset occurs.",
		.cycles = 4,
		.size = 1,
		.func = halt,
	},
	[0x77] = {
		.opcode = 0x77,
		.value = "ld (hl),a",
		.doc = "The contents of a are loaded into (hl).",
		.cycles = 8,
		.size = 1,
		.func = ld_phl_a,
	},
	[0x78] = {
		.opcode = 0x78,
		.value = "ld a,b",
		.doc = "The contents of b are loaded into a.",
		.cycles = 4,
		.size = 1,
		.func = ld_a_b,
	},
	[0x79] = {
		.opcode = 0x79,
		.value = "ld a,c",
		.doc = "The contents of c are loaded into a.",
		.cycles = 4,
		.size = 1,
		.func = ld_a_c,
	},
	[0x7A] = {
		.opcode = 0x7A,
		.value = "ld a,d",
		.doc = "The contents of d are loaded into a.",
		.cycles = 4,
		.size = 1,
		.func = ld_a_d,
	},
	[0x7B] = {
		.opcode = 0x7B,
		.value = "ld a,e",
		.doc = "The contents of e are loaded into a.",
		.cycles = 4,
		.size = 1,
		.func = ld_a_e,
	},
	[0x7C] = {
		.opcode = 0x7C,
		.value = "ld a,h",
		.doc = "The contents of h are loaded into a.",
		.cycles = 4,
		.size = 1,
		.func = ld_a_h,
	},
	[0x7D] = {
		.opcode = 0x7D,
		.value = "ld a,l",
		.doc = "The contents of l are loaded into a.",
		.cycles = 4,
		.size = 1,
		.func = ld_a_l,
	},
	[0x7E] = {
		.opcode = 0x7E,
		.value = "ld a,(hl)",
		.doc = "The contents of (hl) are loaded into a.",
		.cycles = 8,
		.size = 1,
		.func = ld_a_phl,
	},
	[0x7F] = {
		.opcode = 0x7F,
		.value = "ld a,a",
		.doc = "The contents of a are loaded into a.",
		.cycles = 4,
		.size = 1,
		.func = ld_a_a,
	},
	[0x80] = {
		.opcode = 0x80,
		.value = "add a,b",
		.doc = "Adds b to a.",
		.cycles = 4,
		.size = 1,
		.func = add_a_b,
	},
	[0x81] = {
		.opcode = 0x81,
		.value = "add a,c",
		.doc = "Adds c to a.",
		.cycles = 4,
		.size = 1,
		.func = add_a_c,
	},
	[0x82] = {
		.opcode = 0x82,
		.value = "add a,d",
		.doc = "Adds d to a.",
		.cycles = 4,
		.size = 1,
		.func = add_a_d,
	},
	[0x83] = {
		.opcode = 0x83,
		.value = "add a,e",
		.doc = "Adds e to a.",
		.cycles = 4,
		.size = 1,
		.func = add_a_e,
	},
	[0x84] = {
		.opcode = 0x84,
		.value = "add a,h",
		.doc = "Adds h to a.",
		.cycles = 4,
		.size = 1,
		.func = add_a_h,
	},
	[0x85] = {
		.opcode = 0x85,
		.value = "add a,l",
		.doc = "Adds l to a.",
		.cycles = 4,
		.size = 1,
		.func = add_a_l,
	},
	[0x86] = {
		.opcode = 0x86,
		.value = "add a,(hl)",
		.doc = "Adds (hl) to a.",
		.cycles = 8,
		.size = 1,
		.func = add_a_phl,
	},
	[0x87] = {
		.opcode = 0x87,
		.value = "add a,a",
		.doc = "Adds a to a.",
		.cycles = 4,
		.size = 1,
		.func = add_a_a,
	},
	[0x88] = {
		.opcode = 0x88,
		.value = "adc a,b",
		.doc = "Adds b and the carry flag to a.",
		.cycles = 4,
		.size = 1,
		.func = adc_a_b,
	},
	[0x89] = {
		.opcode = 0x89,
		.value = "adc a,c",
		.doc = "Adds c and the carry flag to a.",
		.cycles = 4,
		.size = 1,
		.func = adc_a_c,
	},
	[0x8A] = {
		.opcode = 0x8A,
		.value = "adc a,d",
		.doc = "Adds d and the carry flag to a.",
		.cycles = 4,
		.size = 1,
		.func = adc_a_d,
	},
	[0x8B] = {
		.opcode = 0x8B,
		.value = "adc a,e",
		.doc = "Adds e and the carry flag to a.",
		.cycles = 4,
		.size = 1,
		.func = adc_a_e,
	},
	[0x8C] = {
		.opcode = 0x8C,
		.value = "adc a,h",
		.doc = "Adds h and the carry flag to a.",
		.cycles = 4,
		.size = 1,
		.func = adc_a_h,
	},
	[0x8D] = {
		.opcode = 0x8D,
		.value = "adc a,l",
		.doc = "Adds l and the carry flag to a.",
		.cycles = 4,
		.size = 1,
		.func = adc_a_l,
	},
	[0x8E] = {
		.opcode = 0x8E,
		.value = "adc a,(hl)",
		.doc = "Adds (hl) and the carry flag to a.",
		.cycles = 8,
		.size = 1,
		.func = adc_a_phl,
	},
	[0x8F] = {
		.opcode = 0x8F,
		.value = "adc a,a",
		.doc = "Adds a and the carry flag to a.",
		.cycles = 4,
		.size = 1,
		.func = adc_a_a,
	},
	[0x90] = {
		.opcode = 0x90,
		.value = "sub b",
		.doc = "Subtracts b from a.",
		.cycles = 4,
		.size = 1,
		.func = sub_b,
	},
	[0x91] = {
		.opcode = 0x91,
		.value = "sub c",
		.doc = "Subtracts c from a.",
		.cycles = 4,
		.size = 1,
		.func = sub_c,
	},
	[0x92] = {
		.opcode = 0x92,
		.value = "sub d",
		.doc = "Subtracts d from a.",
		.cycles = 4,
		.size = 1,
		.func = sub_d,
	},
	[0x93] = {
		.opcode = 0x93,
		.value = "sub e",
		.doc = "Subtracts e from a.",
		.cycles = 4,
		.size = 1,
		.func = sub_e,
	},
	[0x94] = {
		.opcode = 0x94,
		.value = "sub h",
		.doc = "Subtracts h from a.",
		.cycles = 4,
		.size = 1,
		.func = sub_h,
	},
	[0x95] = {
		.opcode = 0x95,
		.value = "sub l",
		.doc = "Subtracts l from a.",
		.cycles = 4,
		.size = 1,
		.func = sub_l,
	},
	[0x96] = {
		.opcode = 0x96,
		.value = "sub (hl)",
		.doc = "Subtracts (hl) from a.",
		.cycles = 8,
		.size = 1,
		.func = sub_phl,
	},
	[0x97] = {
		.opcode = 0x97,
		.value = "sub a",
		.doc = "Subtracts a from a.",
		.cycles = 4,
		.size = 1,
		.func = sub_a,
	},
	[0x98] = {
		.opcode = 0x98,
		.value = "sbc b",
		.doc = "Subtracts b and the carry flag from a.",
		.cycles = 4,
		.size = 1,
		.func = sbc_b,
	},
	[0x99] = {
		.opcode = 0x99,
		.value = "sbc c",
		.doc = "Subtracts c and the carry flag from a.",
		.cycles = 4,
		.size = 1,
		.func = sbc_c,
	},
	[0x9A] = {
		.opcode = 0x9A,
		.value = "sbc d",
		.doc = "Subtracts d and the carry flag from a.",
		.cycles = 4,
		.size = 1,
		.func = sbc_d,
	},
	[0x9B] = {
		.opcode = 0x9B,
		.value = "sbc e",
		.doc = "Subtracts e and the carry flag from a.",
		.cycles = 4,
		.size = 1,
		.func = sbc_e,
	},
	[0x9C] = {
		.opcode = 0x9C,
		.value = "sbc h",
		.doc = "Subtracts h and the carry flag from a.",
		.cycles = 4,
		.size = 1,
		.func = sbc_h,
	},
	[0x9D] = {
		.opcode = 0x9D,
		.value = "sbc l",
		.doc = "Subtracts l and the carry flag from a.",
		.cycles = 4,
		.size = 1,
		.func = sbc_l,
	},
	[0x9E] = {
		.opcode = 0x9E,
		.value = "sbc (hl)",
		.doc = "Subtracts (hl) and the carry flag from a.",
		.cycles = 8,
		.size = 1,
		.func = sbc_phl,
	},
	[0x9F] = {
		.opcode = 0x9F,
		.value = "sbc a",
		.doc = "Subtracts a and the carry flag from a.",
		.cycles = 4,
		.size = 1,
		.func = sbc_a,
	},
	[0xA0] = {
		.opcode = 0xA0,
		.value = "and b",
		.doc = "Bitwise AND on a with b.",
		.cycles = 4,
		.size = 1,
		.func = and_b,
	},
	[0xA1] = {
		.opcode = 0xA1,
		.value = "and c",
		.doc = "Bitwise AND on a with c.",
		.cycles = 4,
		.size = 1,
		.func = and_c,
	},
	[0xA2] = {
		.opcode = 0xA2,
		.value = "and d",
		.doc = "Bitwise AND on a with d.",
		.cycles = 4,
		.size = 1,
		.func = and_d,
	},
	[0xA3] = {
		.opcode = 0xA3,
		.value = "and e",
		.doc = "Bitwise AND on a with e.",
		.cycles = 4,
		.size = 1,
		.func = and_e,
	},
	[0xA4] = {
		.opcode = 0xA4,
		.value = "and h",
		.doc = "Bitwise AND on a with h.",
		.cycles = 4,
		.size = 1,
		.func = and_h,
	},
	[0xA5] = {
		.opcode = 0xA5,
		.value = "and l",
		.doc = "Bitwise AND on a with l.",
		.cycles = 4,
		.size = 1,
		.func = and_l,
	},
	[0xA6] = {
		.opcode = 0xA6,
		.value = "and (hl)",
		.doc = "Bitwise AND on a with (hl).",
		.cycles = 8,
		.size = 1,
		.func = and_phl,
	},
	[0xA7] = {
		.opcode = 0xA7,
		.value = "and a",
		.doc = "Bitwise AND on a with a.",
		.cycles = 4,
		.size = 1,
		.func = and_a,
	},
	[0xA8] = {
		.opcode = 0xA8,
		.value = "xor b",
		.doc = "Bitwise XOR on a with b.",
		.cycles = 4,
		.size = 1,
		.func = xor_b,
	},
	[0xA9] = {
		.opcode = 0xA9,
		.value = "xor c",
		.doc = "Bitwise XOR on a with c.",
		.cycles = 4,
		.size = 1,
		.func = xor_c,
	},
	[0xAA] = {
		.opcode = 0xAA,
		.value = "xor d",
		.doc = "Bitwise XOR on a with d.",
		.cycles = 4,
		.size = 1,
		.func = xor_d,
	},
	[0xAB] = {
		.opcode = 0xAB,
		.value = "xor e",
		.doc = "Bitwise XOR on a with e.",
		.cycles = 4,
		.size = 1,
		.func = xor_e,
	},
	[0xAC] = {
		.opcode = 0xAC,
		.value = "xor h",
		.doc = "Bitwise XOR on a with h.",
		.cycles = 4,
		.size = 1,
		.func = xor_h,
	},
	[0xAD] = {
		.opcode = 0xAD,
		.value = "xor l",
		.doc = "Bitwise XOR on a with l.",
		.cycles = 4,
		.size = 1,
		.func = xor_l,
	},
	[0xAE] = {
		.opcode = 0xAE,
		.value = "xor (hl)",
		.doc = "Bitwise XOR on a with (hl).",
		.cycles = 8,
		.size = 1,
		.func = xor_phl,
	},
	[0xAF] = {
		.opcode = 0xAF,
		.value = "xor a",
		.doc = "Bitwise XOR on a with a.",
		.cycles = 4,
		.size = 1,
		.func = xor_a,
	},
	[0xB0] = {
		.opcode = 0xB0,
		.value = "or b",
		.doc = "Bitwise OR on a with b.",
		.cycles = 4,
		.size = 1,
		.func = or_b,
	},
	[0xB1] = {
		.opcode = 0xB1,
		.value = "or c",
		.doc = "Bitwise OR on a with c.",
		.cycles = 4,
		.size = 1,
		.func = or_c,
	},
	[0xB2] = {
		.opcode = 0xB2,
		.value = "or d",
		.doc = "Bitwise OR on a with d.",
		.cycles = 4,
		.size = 1,
		.func = or_d,
	},
	[0xB3] = {
		.opcode = 0xB3,
		.value = "or e",
		.doc = "Bitwise OR on a with e.",
		.cycles = 4,
		.size = 1,
		.func = or_e,
	},
	[0xB4] = {
		.opcode = 0xB4,
		.value = "or h",
		.doc = "Bitwise OR on a with h.",
		.cycles = 4,
		.size = 1,
		.func = or_h,
	},
	[0xB5] = {
		.opcode = 0xB5,
		.value = "or l",
		.doc = "Bitwise OR on a with l.",
		.cycles = 4,
		.size = 1,
		.func = or_l,
	},
	[0xB6] = {
		.opcode = 0xB6,
		.value = "or (hl)",
		.doc = "Bitwise OR on a with (hl).",
		.cycles = 8,
		.size = 1,
		.func = or_phl,
	},
	[0xB7] = {
		.opcode = 0xB7,
		.value = "or a",
		.doc = "Bitwise OR on a with a.",
		.cycles = 4,
		.size = 1,
		.func = or_a,
	},
	[0xB8] = {
		.opcode = 0xB8,
		.value = "cp b",
		.doc = "Subtracts b from a and affects flags according to the result. a is not modified.",
		.cycles = 4,
		.size = 1,
		.func = cp_b,
	},
	[0xB9] = {
		.opcode = 0xB9,
		.value = "cp c",
		.doc = "Subtracts c from a and affects flags according to the result. a is not modified.",
		.cycles = 4,
		.size = 1,
		.func = cp_c,
	},
	[0xBA] = {
		.opcode = 0xBA,
		.value = "cp d",
		.doc = "Subtracts d from a and affects flags according to the result. a is not modified.",
		.cycles = 4,
		.size = 1,
		.func = cp_d,
	},
	[0xBB] = {
		.opcode = 0xBB,
		.value = "cp e",
		.doc = "Subtracts e from a and affects flags according to the result. a is not modified.",
		.cycles = 4,
		.size = 1,
		.func = cp_e,
	},
	[0xBC] = {
		.opcode = 0xBC,
		.value = "cp h",
		.doc = "Subtracts h from a and affects flags according to the result. a is not modified.",
		.cycles = 4,
		.size = 1,
		.func = cp_h,
	},
	[0xBD] = {
		.opcode = 0xBD,
		.value = "cp l",
		.doc = "Subtracts l from a and affects flags according to the result. a is not modified.",
		.cycles = 4,
		.size = 1,
		.func = cp_l,
	},
	[0xBE] = {
		.opcode = 0xBE,
		.value = "cp (hl)",
		.doc = "Subtracts (hl) from a and affects flags according to the result. a is not modified.",
		.cycles = 8,
		.size = 1,
		.func = cp_phl,
	},
	[0xBF] = {
		.opcode = 0xBF,
		.value = "cp a",
		.doc = "Subtracts a from a and affects flags according to the result. a is not modified.",
		.cycles = 4,
		.size = 1,
		.func = cp_a,
	},
	[0xC0] = {
		.opcode = 0xC0,
		.value = "ret nz",
		.doc = "If condition cc is true, the top stack entry is popped into pc.",
		.cycles = 8,
		.size = 0,
		.func = ret_nz,
	},
	[0xC1] = {
		.opcode = 0xC1,
		.value = "pop bc",
		.doc = "The memory location pointed to by sp is stored into c and sp is incremented. The memory location pointed to by sp is stored into b and sp is incremented again.",
		.cycles = 12,
		.size = 1,
		.func = pop_bc,
	},
	[0xC2] = {
		.opcode = 0xC2,
		.value = "jp nz,**",
		.doc = "If condition cc is true, ** is copied to pc.",
		.cycles = 12,
		.size = 0,
		.func = jp_nz_xx,
	},
	[0xC3] = {
		.opcode = 0xC3,
		.value = "jp **",
		.doc = "** is copied to pc.",
		.cycles = 12,
		.size = 0,
		.func = jp_xx,
	},
	[0xC4] = {
		.opcode = 0xC4,
		.value = "call nz,**",
		.doc = "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.",
		.cycles = 12,
		.size = 3,
		.func = call_nz_xx,
	},
	[0xC5] = {
		.opcode = 0xC5,
		.value = "push bc",
		.doc = "sp is decremented and b is stored into the memory location pointed to by sp. sp is decremented again and c is stored into the memory location pointed to by sp.",
		.cycles = 12,
		.size = 1,
		.func = push_bc,
	},
	[0xC6] = {
		.opcode = 0xC6,
		.value = "add a,*",
		.doc = "Adds * to a.",
		.cycles = 8,
		.size = 2,
		.func = add_a_x,
	},
	[0xC7] = {
		.opcode = 0xC7,
		.value = "rst 00h",
		.doc = "The current pc value plus one is pushed onto the stack, then is loaded with 00h.",
		.cycles = 32,
		.size = 0,
		.func = rst_00h,
	},
	[0xC8] = {
		.opcode = 0xC8,
		.value = "ret z",
		.doc = "If condition cc is true, the top stack entry is popped into pc.",
		.cycles = 8,
		.size = 0,
		.func = ret_z,
	},
	[0xC9] = {
		.opcode = 0xC9,
		.value = "ret",
		.doc = "The top stack entry is popped into pc.",
		.cycles = 8,
		.size = 0,
		.func = ret,
	},
	[0xCA] = {
		.opcode = 0xCA,
		.value = "jp z,**",
		.doc = "If condition cc is true, ** is copied to pc.",
		.cycles = 12,
		.size = 0,
		.func = jp_z_xx,
	},
	[0xCB] = {
		.opcode = 0xCB,
		.value = "exec 0xCB",
		.doc = "execute instruction in subtable 0xCB",
		.cycles = 0,
		.size = 2,
		.func = exec_0xCB,
	},
	[0xCC] = {
		.opcode = 0xCC,
		.value = "call z,**",
		.doc = "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.",
		.cycles = 12,
		.size = 3,
		.func = call_z_xx,
	},
	[0xCD] = {
		.opcode = 0xCD,
		.value = "call **",
		.doc = "Push address of next instruction onto the stack and then jump to address **.",
		.cycles = 12,
		.size = 3,
		.func = call_xx,
	},
	[0xCE] = {
		.opcode = 0xCE,
		.value = "adc a,*",
		.doc = "Adds * and the carry flag to a.",
		.cycles = 8,
		.size = 2,
		.func = adc_a_x,
	},
	[0xCF] = {
		.opcode = 0xCF,
		.value = "rst 08h",
		.doc = "The current pc value plus one is pushed onto the stack, then is loaded with 08h.",
		.cycles = 32,
		.size = 0,
		.func = rst_08h,
	},
	[0xD0] = {
		.opcode = 0xD0,
		.value = "ret nc",
		.doc = "If condition cc is true, the top stack entry is popped into pc.",
		.cycles = 7,
		.size = 0,
		.func = ret_nc,
	},
	[0xD1] = {
		.opcode = 0xD1,
		.value = "pop de",
		.doc = "The memory location pointed to by sp is stored into e and sp is incremented. The memory location pointed to by sp is stored into d and sp is incremented again.",
		.cycles = 12,
		.size = 1,
		.func = pop_de,
	},
	[0xD2] = {
		.opcode = 0xD2,
		.value = "jp nc,**",
		.doc = "If condition cc is true, ** is copied to pc.",
		.cycles = 12,
		.size = 0,
		.func = jp_nc_xx,
	},
	[0xD3] = {
		.opcode = 0xD3,
		.value = "und",
		.doc = "Undefined.",
		.cycles = 4,
		.size = 1,
		.func = und,
	},
	[0xD4] = {
		.opcode = 0xD4,
		.value = "call nc,**",
		.doc = "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.",
		.cycles = 12,
		.size = 3,
		.func = call_nc_xx,
	},
	[0xD5] = {
		.opcode = 0xD5,
		.value = "push de",
		.doc = "sp is decremented and d is stored into the memory location pointed to by sp. sp is decremented again and e is stored into the memory location pointed to by sp.",
		.cycles = 16,
		.size = 1,
		.func = push_de,
	},
	[0xD6] = {
		.opcode = 0xD6,
		.value = "sub *",
		.doc = "Subtracts * from a.",
		.cycles = 8,
		.size = 2,
		.func = sub_x,
	},
	[0xD7] = {
		.opcode = 0xD7,
		.value = "rst 10h",
		.doc = "The current pc value plus one is pushed onto the stack, then is loaded with 10h.",
		.cycles = 32,
		.size = 0,
		.func = rst_10h,
	},
	[0xD8] = {
		.opcode = 0xD8,
		.value = "ret c",
		.doc = "If condition cc is true, the top stack entry is popped into pc.",
		.cycles = 8,
		.size = 0,
		.func = ret_c,
	},
	[0xD9] = {
		.opcode = 0xD9,
		.value = "reti",
		.doc = "Pop two bytes from stack & jump to that address then enable interupts.",
		.cycles = 8,
		.size = 3,
		.func = reti,
	},
	[0xDA] = {
		.opcode = 0xDA,
		.value = "jp c,**",
		.doc = "If condition cc is true, ** is copied to pc.",
		.cycles = 12,
		.size = 0,
		.func = jp_c_xx,
	},
	[0xDB] = {
		.opcode = 0xDB,
		.value = "und",
		.doc = "Undefined.",
		.cycles = 4,
		.size = 1,
		.func = und,
	},
	[0xDC] = {
		.opcode = 0xDC,
		.value = "call c,**",
		.doc = "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.",
		.cycles = 12,
		.size = 3,
		.func = call_c_xx,
	},
	[0xDD] = {
		.opcode = 0xDD,
		.value = "und",
		.doc = "Undefined.",
		.cycles = 4,
		.size = 1,
		.func = und,
	},
	[0xDE] = {
		.opcode = 0xDE,
		.value = "sbc *",
		.doc = "Subtracts * and the carry flag from a.",
		.cycles = 8,
		.size = 2,
		.func = sbc_x,
	},
	[0xDF] = {
		.opcode = 0xDF,
		.value = "rst 18h",
		.doc = "The current pc value plus one is pushed onto the stack, then is loaded with 18h.",
		.cycles = 32,
		.size = 0,
		.func = rst_18h,
	},
	[0xE0] = {
		.opcode = 0xE0,
		.value = "ld (*),a",
		.doc = "Put a into memory address $FF00 + n.",
		.cycles = 12,
		.size = 2,
		.func = ld_px_a,
	},
	[0xE1] = {
		.opcode = 0xE1,
		.value = "pop hl",
		.doc = "The memory location pointed to by sp is stored into l and sp is incremented. The memory location pointed to by sp is stored into h and sp is incremented again.",
		.cycles = 12,
		.size = 1,
		.func = pop_hl,
	},
	[0xE2] = {
		.opcode = 0xE2,
		.value = "ld (c),a",
		.doc = "Put a into address $FF00 + register c.",
		.cycles = 8,
		.size = 1,
		.func = ld_pc_a,
	},
	[0xE3] = {
		.opcode = 0xE3,
		.value = "und",
		.doc = "Undefined.",
		.cycles = 4,
		.size = 1,
		.func = und,
	},
	[0xE4] = {
		.opcode = 0xE4,
		.value = "und",
		.doc = "Undefined.",
		.cycles = 4,
		.size = 1,
		.func = und,
	},
	[0xE5] = {
		.opcode = 0xE5,
		.value = "push hl",
		.doc = "sp is decremented and h is stored into the memory location pointed to by sp. sp is decremented again and l is stored into the memory location pointed to by sp.",
		.cycles = 16,
		.size = 1,
		.func = push_hl,
	},
	[0xE6] = {
		.opcode = 0xE6,
		.value = "and *",
		.doc = "Bitwise AND on a with *.",
		.cycles = 8,
		.size = 2,
		.func = and_x,
	},
	[0xE7] = {
		.opcode = 0xE7,
		.value = "rst 20h",
		.doc = "The current pc value plus one is pushed onto the stack, then is loaded with 20h.",
		.cycles = 32,
		.size = 0,
		.func = rst_20h,
	},
	[0xE8] = {
		.opcode = 0xE8,
		.value = "add sp,*",
		.doc = "If condition cc is true, the top stack entry is popped into pc.",
		.cycles = 16,
		.size = 2,
		.func = add_sp_x,
	},
	[0xE9] = {
		.opcode = 0xE9,
		.value = "jp (hl)",
		.doc = "Loads the value of hl into pc.",
		.cycles = 4,
		.size = 0,
		.func = jp_phl,
	},
	[0xEA] = {
		.opcode = 0xEA,
		.value = "ld (**),a",
		.doc = "Put a into memory location **.",
		.cycles = 16,
		.size = 3,
		.func = ld_pxx_a,
	},
	[0xEB] = {
		.opcode = 0xEB,
		.value = "und",
		.doc = "Undefined.",
		.cycles = 4,
		.size = 1,
		.func = und,
	},
	[0xEC] = {
		.opcode = 0xEC,
		.value = "und",
		.doc = "Undefined.",
		.cycles = 4,
		.size = 1,
		.func = und,
	},
	[0xED] = {
		.opcode = 0xED,
		.value = "und",
		.doc = "Undefined.",
		.cycles = 4,
		.size = 1,
		.func = und,
	},
	[0xEE] = {
		.opcode = 0xEE,
		.value = "xor *",
		.doc = "Bitwise XOR on a with *.",
		.cycles = 8,
		.size = 2,
		.func = xor_x,
	},
	[0xEF] = {
		.opcode = 0xEF,
		.value = "rst 28h",
		.doc = "The current pc value plus one is pushed onto the stack, then is loaded with 28h.",
		.cycles = 32,
		.size = 0,
		.func = rst_28h,
	},
	[0xF0] = {
		.opcode = 0xF0,
		.value = "ld a,(*)",
		.doc = "Put memory address $FF00 + * into a.",
		.cycles = 12,
		.size = 1,
		.func = ld_a_px,
	},
	[0xF1] = {
		.opcode = 0xF1,
		.value = "pop af",
		.doc = "The memory location pointed to by sp is stored into f and sp is incremented. The memory location pointed to by sp is stored into a and sp is incremented again.",
		.cycles = 12,
		.size = 1,
		.func = pop_af,
	},
	[0xF2] = {
		.opcode = 0xF2,
		.value = "ld a,(c)",
		.doc = "Put memory address $FF00 + c into a.",
		.cycles = 12,
		.size = 1,
		.func = ld_a_pc,
	},
	[0xF3] = {
		.opcode = 0xF3,
		.value = "di",
		.doc = "Disable interrupts but not immediately. Interrupts are disabled after instruction after DI is executed.",
		.cycles = 4,
		.size = 1,
		.func = di,
	},
	[0xF4] = {
		.opcode = 0xF4,
		.value = "und",
		.doc = "Undefined.",
		.cycles = 4,
		.size = 1,
		.func = und,
	},
	[0xF5] = {
		.opcode = 0xF5,
		.value = "push af",
		.doc = "sp is decremented and a is stored into the memory location pointed to by sp. sp is decremented again and f is stored into the memory location pointed to by sp.",
		.cycles = 16,
		.size = 1,
		.func = push_af,
	},
	[0xF6] = {
		.opcode = 0xF6,
		.value = "or *",
		.doc = "Bitwise OR on a with *.",
		.cycles = 8,
		.size = 2,
		.func = or_x,
	},
	[0xF7] = {
		.opcode = 0xF7,
		.value = "rst 30h",
		.doc = "The current pc value plus one is pushed onto the stack, then is loaded with 30h.",
		.cycles = 32,
		.size = 0,
		.func = rst_30h,
	},
	[0xF8] = {
		.opcode = 0xF8,
		.value = "ldhl sp,*",
		.doc = "Put SP + * effective address into HL.",
		.cycles = 12,
		.size = 1,
		.func = ldhl_sp_x,
	},
	[0xF9] = {
		.opcode = 0xF9,
		.value = "ld sp,hl",
		.doc = "Loads the value of hl into sp.",
		.cycles = 8,
		.size = 1,
		.func = ld_sp_hl,
	},
	[0xFA] = {
		.opcode = 0xFA,
		.value = "ld a,(**)",
		.doc = "Put value at address ** into a.",
		.cycles = 16,
		.size = 3,
		.func = ld_a_pxx,
	},
	[0xFB] = {
		.opcode = 0xFB,
		.value = "ei",
		.doc = "Enable interrupts. This instruction enables interrupts but not immediately. Interrupts are enabled after instruction after EI is executed.",
		.cycles = 4,
		.size = 1,
		.func = ei,
	},
	[0xFC] = {
		.opcode = 0xFC,
		.value = "und",
		.doc = "Undefined.",
		.cycles = 4,
		.size = 1,
		.func = und,
	},
	[0xFD] = {
		.opcode = 0xFD,
		.value = "und",
		.doc = "Undefined.",
		.cycles = 4,
		.size = 1,
		.func = und,
	},
	[0xFE] = {
		.opcode = 0xFE,
		.value = "cp *",
		.doc = "Subtracts * from a and affects flags according to the result. a is not modified.",
		.cycles = 8,
		.size = 2,
		.func = cp_x,
	},
	[0xFF] = {
		.opcode = 0xFF,
		.value = "rst 38h",
		.doc = "The current pc value plus one is pushed onto the stack, then is loaded with 38h.",
		.cycles = 32,
		.size = 0,
		.func = rst_38h,
	},
};

/* start of op code function definitions */
/* rlc b [0x00] : The contents of b are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. */
static void cb_rlc_b(struct s_gb *s_gb)
{
	/* start of cb_rlc_b manual code */

	/* end of cb_rlc_b manual code */
	bool lone_bit;
	uint8_t value;

	value = s_gb->gb_register.b;
	lone_bit = BIT(7, value);
	if (lone_bit)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	value += lone_bit;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.b = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rlc c [0x01] : The contents of c are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. */
static void cb_rlc_c(struct s_gb *s_gb)
{
	/* start of cb_rlc_c manual code */

	/* end of cb_rlc_c manual code */
	bool lone_bit;
	uint8_t value;

	value = s_gb->gb_register.c;
	lone_bit = BIT(7, value);
	if (lone_bit)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	value += lone_bit;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.c = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rlc d [0x02] : The contents of d are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. */
static void cb_rlc_d(struct s_gb *s_gb)
{
	/* start of cb_rlc_d manual code */

	/* end of cb_rlc_d manual code */
	bool lone_bit;
	uint8_t value;

	value = s_gb->gb_register.d;
	lone_bit = BIT(7, value);
	if (lone_bit)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	value += lone_bit;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.d = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rlc e [0x03] : The contents of e are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. */
static void cb_rlc_e(struct s_gb *s_gb)
{
	/* start of cb_rlc_e manual code */

	/* end of cb_rlc_e manual code */
	bool lone_bit;
	uint8_t value;

	value = s_gb->gb_register.e;
	lone_bit = BIT(7, value);
	if (lone_bit)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	value += lone_bit;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.e = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rlc h [0x04] : The contents of h are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. */
static void cb_rlc_h(struct s_gb *s_gb)
{
	/* start of cb_rlc_h manual code */

	/* end of cb_rlc_h manual code */
	bool lone_bit;
	uint8_t value;

	value = s_gb->gb_register.h;
	lone_bit = BIT(7, value);
	if (lone_bit)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	value += lone_bit;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.h = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rlc l [0x05] : The contents of l are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. */
static void cb_rlc_l(struct s_gb *s_gb)
{
	/* start of cb_rlc_l manual code */

	/* end of cb_rlc_l manual code */
	bool lone_bit;
	uint8_t value;

	value = s_gb->gb_register.l;
	lone_bit = BIT(7, value);
	if (lone_bit)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	value += lone_bit;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.l = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rlc (hl) [0x06] : The contents of (hl) are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. */
static void cb_rlc_phl(struct s_gb *s_gb)
{
	/* start of cb_rlc_phl manual code */

	/* end of cb_rlc_phl manual code */
	bool lone_bit;
	uint8_t value;

	value = read8bit(s_gb->gb_register.hl, s_gb);
	lone_bit = BIT(7, value);
	if (lone_bit)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	value += lone_bit;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	write8bit(s_gb->gb_register.hl, value, s_gb);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rlc a [0x07] : The contents of a are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. */
static void cb_rlc_a(struct s_gb *s_gb)
{
	/* start of cb_rlc_a manual code */

	/* end of cb_rlc_a manual code */
	bool lone_bit;
	uint8_t value;

	value = s_gb->gb_register.a;
	lone_bit = BIT(7, value);
	if (lone_bit)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	value += lone_bit;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.a = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rrc b [0x08] : The contents of b are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. */
static void cb_rrc_b(struct s_gb *s_gb)
{
	/* start of cb_rrc_b manual code */

	/* end of cb_rrc_b manual code */
	bool lone_bit;
	uint8_t value;

	value = s_gb->gb_register.b;
	lone_bit = BIT(0, value);
	if (lone_bit)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	value += (lone_bit << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.b = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rrc c [0x09] : The contents of c are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. */
static void cb_rrc_c(struct s_gb *s_gb)
{
	/* start of cb_rrc_c manual code */

	/* end of cb_rrc_c manual code */
	bool lone_bit;
	uint8_t value;

	value = s_gb->gb_register.c;
	lone_bit = BIT(0, value);
	if (lone_bit)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	value += (lone_bit << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.c = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rrc d [0x0A] : The contents of d are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. */
static void cb_rrc_d(struct s_gb *s_gb)
{
	/* start of cb_rrc_d manual code */

	/* end of cb_rrc_d manual code */
	bool lone_bit;
	uint8_t value;

	value = s_gb->gb_register.d;
	lone_bit = BIT(0, value);
	if (lone_bit)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	value += (lone_bit << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.d = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rrc e [0x0B] : The contents of e are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. */
static void cb_rrc_e(struct s_gb *s_gb)
{
	/* start of cb_rrc_e manual code */

	/* end of cb_rrc_e manual code */
	bool lone_bit;
	uint8_t value;

	value = s_gb->gb_register.e;
	lone_bit = BIT(0, value);
	if (lone_bit)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	value += (lone_bit << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.e = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rrc h [0x0C] : The contents of h are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. */
static void cb_rrc_h(struct s_gb *s_gb)
{
	/* start of cb_rrc_h manual code */

	/* end of cb_rrc_h manual code */
	bool lone_bit;
	uint8_t value;

	value = s_gb->gb_register.h;
	lone_bit = BIT(0, value);
	if (lone_bit)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	value += (lone_bit << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.h = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rrc l [0x0D] : The contents of l are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. */
static void cb_rrc_l(struct s_gb *s_gb)
{
	/* start of cb_rrc_l manual code */

	/* end of cb_rrc_l manual code */
	bool lone_bit;
	uint8_t value;

	value = s_gb->gb_register.l;
	lone_bit = BIT(0, value);
	if (lone_bit)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	value += (lone_bit << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.l = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rrc (hl) [0x0E] : The contents of (hl) are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. */
static void cb_rrc_phl(struct s_gb *s_gb)
{
	/* start of cb_rrc_phl manual code */

	/* end of cb_rrc_phl manual code */
	bool lone_bit;
	uint8_t value;

	value = read8bit(s_gb->gb_register.hl, s_gb);
	lone_bit = BIT(0, value);
	if (lone_bit)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	value += (lone_bit << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	write8bit(s_gb->gb_register.hl, value, s_gb);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rrc a [0x0F] : The contents of a are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. */
static void cb_rrc_a(struct s_gb *s_gb)
{
	/* start of cb_rrc_a manual code */

	/* end of cb_rrc_a manual code */
	bool lone_bit;
	uint8_t value;

	value = s_gb->gb_register.a;
	lone_bit = BIT(0, value);
	if (lone_bit)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	value += (lone_bit << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.a = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rl b [0x10] : The contents of b are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. */
static void cb_rl_b(struct s_gb *s_gb)
{
	/* start of cb_rl_b manual code */

	/* end of cb_rl_b manual code */
	bool carry;
	uint8_t value;

	carry = FLAGS_ISSET(s_gb->gb_register.f, FLAGS_CARRY);
	value = s_gb->gb_register.b;
	if (BIT(7, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	value += carry;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.b = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rl c [0x11] : The contents of c are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. */
static void cb_rl_c(struct s_gb *s_gb)
{
	/* start of cb_rl_c manual code */

	/* end of cb_rl_c manual code */
	bool carry;
	uint8_t value;

	carry = FLAGS_ISSET(s_gb->gb_register.f, FLAGS_CARRY);
	value = s_gb->gb_register.c;
	if (BIT(7, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	value += carry;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.c = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rl d [0x12] : The contents of d are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. */
static void cb_rl_d(struct s_gb *s_gb)
{
	/* start of cb_rl_d manual code */

	/* end of cb_rl_d manual code */
	bool carry;
	uint8_t value;

	carry = FLAGS_ISSET(s_gb->gb_register.f, FLAGS_CARRY);
	value = s_gb->gb_register.d;
	if (BIT(7, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	value += carry;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.d = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rl e [0x13] : The contents of e are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. */
static void cb_rl_e(struct s_gb *s_gb)
{
	/* start of cb_rl_e manual code */

	/* end of cb_rl_e manual code */
	bool carry;
	uint8_t value;

	carry = FLAGS_ISSET(s_gb->gb_register.f, FLAGS_CARRY);
	value = s_gb->gb_register.e;
	if (BIT(7, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	value += carry;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.e = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rl h [0x14] : The contents of h are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. */
static void cb_rl_h(struct s_gb *s_gb)
{
	/* start of cb_rl_h manual code */

	/* end of cb_rl_h manual code */
	bool carry;
	uint8_t value;

	carry = FLAGS_ISSET(s_gb->gb_register.f, FLAGS_CARRY);
	value = s_gb->gb_register.h;
	if (BIT(7, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	value += carry;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.h = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rl l [0x15] : The contents of l are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. */
static void cb_rl_l(struct s_gb *s_gb)
{
	/* start of cb_rl_l manual code */

	/* end of cb_rl_l manual code */
	bool carry;
	uint8_t value;

	carry = FLAGS_ISSET(s_gb->gb_register.f, FLAGS_CARRY);
	value = s_gb->gb_register.l;
	if (BIT(7, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	value += carry;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.l = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rl (hl) [0x16] : The contents of (hl) are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. */
static void cb_rl_phl(struct s_gb *s_gb)
{
	/* start of cb_rl_phl manual code */

	/* end of cb_rl_phl manual code */
	bool carry;
	uint8_t value;

	carry = FLAGS_ISSET(s_gb->gb_register.f, FLAGS_CARRY);
	value = read8bit(s_gb->gb_register.hl, s_gb);
	if (BIT(7, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	value += carry;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	write8bit(s_gb->gb_register.hl, value, s_gb);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rl a [0x17] : The contents of a are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. */
static void cb_rl_a(struct s_gb *s_gb)
{
	/* start of cb_rl_a manual code */

	/* end of cb_rl_a manual code */
	bool carry;
	uint8_t value;

	carry = FLAGS_ISSET(s_gb->gb_register.f, FLAGS_CARRY);
	value = s_gb->gb_register.a;
	if (BIT(7, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	value += carry;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.a = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rr b [0x18] : The contents of b are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. */
static void cb_rr_b(struct s_gb *s_gb)
{
	/* start of cb_rr_b manual code */

	/* end of cb_rr_b manual code */
	bool carry;
	uint8_t value;

	carry = FLAGS_ISSET(s_gb->gb_register.f, FLAGS_CARRY);
	value = s_gb->gb_register.b;
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	value += (carry << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.b = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rr c [0x19] : The contents of c are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. */
static void cb_rr_c(struct s_gb *s_gb)
{
	/* start of cb_rr_c manual code */

	/* end of cb_rr_c manual code */
	bool carry;
	uint8_t value;

	carry = FLAGS_ISSET(s_gb->gb_register.f, FLAGS_CARRY);
	value = s_gb->gb_register.c;
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	value += (carry << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.c = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rr d [0x1A] : The contents of d are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. */
static void cb_rr_d(struct s_gb *s_gb)
{
	/* start of cb_rr_d manual code */

	/* end of cb_rr_d manual code */
	bool carry;
	uint8_t value;

	carry = FLAGS_ISSET(s_gb->gb_register.f, FLAGS_CARRY);
	value = s_gb->gb_register.d;
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	value += (carry << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.d = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rr e [0x1B] : The contents of e are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. */
static void cb_rr_e(struct s_gb *s_gb)
{
	/* start of cb_rr_e manual code */

	/* end of cb_rr_e manual code */
	bool carry;
	uint8_t value;

	carry = FLAGS_ISSET(s_gb->gb_register.f, FLAGS_CARRY);
	value = s_gb->gb_register.e;
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	value += (carry << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.e = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rr h [0x1C] : The contents of h are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. */
static void cb_rr_h(struct s_gb *s_gb)
{
	/* start of cb_rr_h manual code */

	/* end of cb_rr_h manual code */
	bool carry;
	uint8_t value;

	carry = FLAGS_ISSET(s_gb->gb_register.f, FLAGS_CARRY);
	value = s_gb->gb_register.h;
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	value += (carry << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.h = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rr l [0x1D] : The contents of l are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. */
static void cb_rr_l(struct s_gb *s_gb)
{
	/* start of cb_rr_l manual code */

	/* end of cb_rr_l manual code */
	bool carry;
	uint8_t value;

	carry = FLAGS_ISSET(s_gb->gb_register.f, FLAGS_CARRY);
	value = s_gb->gb_register.l;
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	value += (carry << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.l = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rr (hl) [0x1E] : The contents of (hl) are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. */
static void cb_rr_phl(struct s_gb *s_gb)
{
	/* start of cb_rr_phl manual code */

	/* end of cb_rr_phl manual code */
	bool carry;
	uint8_t value;

	carry = FLAGS_ISSET(s_gb->gb_register.f, FLAGS_CARRY);
	value = read8bit(s_gb->gb_register.hl, s_gb);
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	value += (carry << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	write8bit(s_gb->gb_register.hl, value, s_gb);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* rr a [0x1F] : The contents of a are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. */
static void cb_rr_a(struct s_gb *s_gb)
{
	/* start of cb_rr_a manual code */

	/* end of cb_rr_a manual code */
	bool carry;
	uint8_t value;

	carry = FLAGS_ISSET(s_gb->gb_register.f, FLAGS_CARRY);
	value = s_gb->gb_register.a;
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	value += (carry << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.a = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* sla b [0x20] : The contents of b are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. */
static void cb_sla_b(struct s_gb *s_gb)
{
	/* start of cb_sla_b manual code */

	/* end of cb_sla_b manual code */
	uint8_t value;

	value = s_gb->gb_register.b;
	if (BIT(7, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.b = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* sla c [0x21] : The contents of c are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. */
static void cb_sla_c(struct s_gb *s_gb)
{
	/* start of cb_sla_c manual code */

	/* end of cb_sla_c manual code */
	uint8_t value;

	value = s_gb->gb_register.c;
	if (BIT(7, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.c = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* sla d [0x22] : The contents of d are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. */
static void cb_sla_d(struct s_gb *s_gb)
{
	/* start of cb_sla_d manual code */

	/* end of cb_sla_d manual code */
	uint8_t value;

	value = s_gb->gb_register.d;
	if (BIT(7, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.d = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* sla e [0x23] : The contents of e are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. */
static void cb_sla_e(struct s_gb *s_gb)
{
	/* start of cb_sla_e manual code */

	/* end of cb_sla_e manual code */
	uint8_t value;

	value = s_gb->gb_register.e;
	if (BIT(7, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.e = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* sla h [0x24] : The contents of h are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. */
static void cb_sla_h(struct s_gb *s_gb)
{
	/* start of cb_sla_h manual code */

	/* end of cb_sla_h manual code */
	uint8_t value;

	value = s_gb->gb_register.h;
	if (BIT(7, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.h = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* sla l [0x25] : The contents of l are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. */
static void cb_sla_l(struct s_gb *s_gb)
{
	/* start of cb_sla_l manual code */

	/* end of cb_sla_l manual code */
	uint8_t value;

	value = s_gb->gb_register.l;
	if (BIT(7, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.l = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* sla (hl) [0x26] : The contents of (hl) are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. */
static void cb_sla_phl(struct s_gb *s_gb)
{
	/* start of cb_sla_phl manual code */

	/* end of cb_sla_phl manual code */
	uint8_t value;

	value = read8bit(s_gb->gb_register.hl, s_gb);
	if (BIT(7, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	write8bit(s_gb->gb_register.hl, value, s_gb);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* sla a [0x27] : The contents of a are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. */
static void cb_sla_a(struct s_gb *s_gb)
{
	/* start of cb_sla_a manual code */

	/* end of cb_sla_a manual code */
	uint8_t value;

	value = s_gb->gb_register.a;
	if (BIT(7, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value <<= 1;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.a = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* sra b [0x28] : The contents of b are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. */
static void cb_sra_b(struct s_gb *s_gb)
{
	/* start of cb_sra_b manual code */

	/* end of cb_sra_b manual code */
	uint8_t value;
	bool bit7;

	value = s_gb->gb_register.b;
	bit7 = BIT(7, value);
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	if (bit7)
		FLAGS_SET(value, (1 << 7));
	else
		FLAGS_CLEAR(value, (1 << 7));
	s_gb->gb_register.b = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* sra c [0x29] : The contents of c are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. */
static void cb_sra_c(struct s_gb *s_gb)
{
	/* start of cb_sra_c manual code */

	/* end of cb_sra_c manual code */
	uint8_t value;
	bool bit7;

	value = s_gb->gb_register.c;
	bit7 = BIT(7, value);
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	if (bit7)
		FLAGS_SET(value, (1 << 7));
	else
		FLAGS_CLEAR(value, (1 << 7));
	s_gb->gb_register.c = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* sra d [0x2A] : The contents of d are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. */
static void cb_sra_d(struct s_gb *s_gb)
{
	/* start of cb_sra_d manual code */

	/* end of cb_sra_d manual code */
	uint8_t value;
	bool bit7;

	value = s_gb->gb_register.d;
	bit7 = BIT(7, value);
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	if (bit7)
		FLAGS_SET(value, (1 << 7));
	else
		FLAGS_CLEAR(value, (1 << 7));
	s_gb->gb_register.d = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* sra e [0x2B] : The contents of e are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. */
static void cb_sra_e(struct s_gb *s_gb)
{
	/* start of cb_sra_e manual code */

	/* end of cb_sra_e manual code */
	uint8_t value;
	bool bit7;

	value = s_gb->gb_register.e;
	bit7 = BIT(7, value);
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	if (bit7)
		FLAGS_SET(value, (1 << 7));
	else
		FLAGS_CLEAR(value, (1 << 7));
	s_gb->gb_register.e = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* sra h [0x2C] : The contents of h are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. */
static void cb_sra_h(struct s_gb *s_gb)
{
	/* start of cb_sra_h manual code */

	/* end of cb_sra_h manual code */
	uint8_t value;
	bool bit7;

	value = s_gb->gb_register.h;
	bit7 = BIT(7, value);
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	if (bit7)
		FLAGS_SET(value, (1 << 7));
	else
		FLAGS_CLEAR(value, (1 << 7));
	s_gb->gb_register.h = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* sra l [0x2D] : The contents of l are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. */
static void cb_sra_l(struct s_gb *s_gb)
{
	/* start of cb_sra_l manual code */

	/* end of cb_sra_l manual code */
	uint8_t value;
	bool bit7;

	value = s_gb->gb_register.l;
	bit7 = BIT(7, value);
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	if (bit7)
		FLAGS_SET(value, (1 << 7));
	else
		FLAGS_CLEAR(value, (1 << 7));
	s_gb->gb_register.l = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* sra (hl) [0x2E] : The contents of (hl) are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. */
static void cb_sra_phl(struct s_gb *s_gb)
{
	/* start of cb_sra_phl manual code */

	/* end of cb_sra_phl manual code */
	uint8_t value;
	bool bit7;

	value = read8bit(s_gb->gb_register.hl, s_gb);
	bit7 = BIT(7, value);
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	if (bit7)
		FLAGS_SET(value, (1 << 7));
	else
		FLAGS_CLEAR(value, (1 << 7));
	write8bit(s_gb->gb_register.hl, value, s_gb);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* sra a [0x2F] : The contents of a are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. */
static void cb_sra_a(struct s_gb *s_gb)
{
	/* start of cb_sra_a manual code */

	/* end of cb_sra_a manual code */
	uint8_t value;
	bool bit7;

	value = s_gb->gb_register.a;
	bit7 = BIT(7, value);
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	if (bit7)
		FLAGS_SET(value, (1 << 7));
	else
		FLAGS_CLEAR(value, (1 << 7));
	s_gb->gb_register.a = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* swap b [0x30] : Swap upper and lower nibbles of b. */
static void cb_swap_b(struct s_gb *s_gb)
{
	/* start of cb_swap_b manual code */

	/* end of cb_swap_b manual code */
	/* sll opcodes are replaced with nibble swapping for gb */
	uint8_t value;

	value = s_gb->gb_register.b;
	value = ((value & 0xf) << 4) | ((value & 0xf0) >> 4);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.b = value;
	CLEAR_CARRY();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* swap c [0x31] : Swap upper and lower nibbles of c. */
static void cb_swap_c(struct s_gb *s_gb)
{
	/* start of cb_swap_c manual code */

	/* end of cb_swap_c manual code */
	/* sll opcodes are replaced with nibble swapping for gb */
	uint8_t value;

	value = s_gb->gb_register.c;
	value = ((value & 0xf) << 4) | ((value & 0xf0) >> 4);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.c = value;
	CLEAR_CARRY();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* swap d [0x32] : Swap upper and lower nibbles of d. */
static void cb_swap_d(struct s_gb *s_gb)
{
	/* start of cb_swap_d manual code */

	/* end of cb_swap_d manual code */
	/* sll opcodes are replaced with nibble swapping for gb */
	uint8_t value;

	value = s_gb->gb_register.d;
	value = ((value & 0xf) << 4) | ((value & 0xf0) >> 4);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.d = value;
	CLEAR_CARRY();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* swap e [0x33] : Swap upper and lower nibbles of e. */
static void cb_swap_e(struct s_gb *s_gb)
{
	/* start of cb_swap_e manual code */

	/* end of cb_swap_e manual code */
	/* sll opcodes are replaced with nibble swapping for gb */
	uint8_t value;

	value = s_gb->gb_register.e;
	value = ((value & 0xf) << 4) | ((value & 0xf0) >> 4);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.e = value;
	CLEAR_CARRY();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* swap h [0x34] : Swap upper and lower nibbles of h. */
static void cb_swap_h(struct s_gb *s_gb)
{
	/* start of cb_swap_h manual code */

	/* end of cb_swap_h manual code */
	/* sll opcodes are replaced with nibble swapping for gb */
	uint8_t value;

	value = s_gb->gb_register.h;
	value = ((value & 0xf) << 4) | ((value & 0xf0) >> 4);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.h = value;
	CLEAR_CARRY();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* swap l [0x35] : Swap upper and lower nibbles of l. */
static void cb_swap_l(struct s_gb *s_gb)
{
	/* start of cb_swap_l manual code */

	/* end of cb_swap_l manual code */
	/* sll opcodes are replaced with nibble swapping for gb */
	uint8_t value;

	value = s_gb->gb_register.l;
	value = ((value & 0xf) << 4) | ((value & 0xf0) >> 4);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.l = value;
	CLEAR_CARRY();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* swap (hl) [0x36] : Swap upper and lower nibbles of (hl). */
static void cb_swap_phl(struct s_gb *s_gb)
{
	/* start of cb_swap_phl manual code */

	/* end of cb_swap_phl manual code */
	/* sll opcodes are replaced with nibble swapping for gb */
	uint8_t value;

	value = read8bit(s_gb->gb_register.hl, s_gb);
	value = ((value & 0xf) << 4) | ((value & 0xf0) >> 4);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	write8bit(s_gb->gb_register.hl, value, s_gb);
	CLEAR_CARRY();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* swap a [0x37] : Swap upper and lower nibbles of a. */
static void cb_swap_a(struct s_gb *s_gb)
{
	/* start of cb_swap_a manual code */

	/* end of cb_swap_a manual code */
	/* sll opcodes are replaced with nibble swapping for gb */
	uint8_t value;

	value = s_gb->gb_register.a;
	value = ((value & 0xf) << 4) | ((value & 0xf0) >> 4);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.a = value;
	CLEAR_CARRY();
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* srl b [0x38] : The contents of b are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. */
static void cb_srl_b(struct s_gb *s_gb)
{
	/* start of cb_srl_b manual code */

	/* end of cb_srl_b manual code */
	uint8_t value;

	value = s_gb->gb_register.b;
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	FLAGS_CLEAR(value, 1 << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.b = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* srl c [0x39] : The contents of c are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. */
static void cb_srl_c(struct s_gb *s_gb)
{
	/* start of cb_srl_c manual code */

	/* end of cb_srl_c manual code */
	uint8_t value;

	value = s_gb->gb_register.c;
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	FLAGS_CLEAR(value, 1 << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.c = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* srl d [0x3A] : The contents of d are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. */
static void cb_srl_d(struct s_gb *s_gb)
{
	/* start of cb_srl_d manual code */

	/* end of cb_srl_d manual code */
	uint8_t value;

	value = s_gb->gb_register.d;
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	FLAGS_CLEAR(value, 1 << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.d = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* srl e [0x3B] : The contents of e are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. */
static void cb_srl_e(struct s_gb *s_gb)
{
	/* start of cb_srl_e manual code */

	/* end of cb_srl_e manual code */
	uint8_t value;

	value = s_gb->gb_register.e;
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	FLAGS_CLEAR(value, 1 << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.e = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* srl h [0x3C] : The contents of h are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. */
static void cb_srl_h(struct s_gb *s_gb)
{
	/* start of cb_srl_h manual code */

	/* end of cb_srl_h manual code */
	uint8_t value;

	value = s_gb->gb_register.h;
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	FLAGS_CLEAR(value, 1 << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.h = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* srl l [0x3D] : The contents of l are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. */
static void cb_srl_l(struct s_gb *s_gb)
{
	/* start of cb_srl_l manual code */

	/* end of cb_srl_l manual code */
	uint8_t value;

	value = s_gb->gb_register.l;
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	FLAGS_CLEAR(value, 1 << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.l = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* srl (hl) [0x3E] : The contents of (hl) are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. */
static void cb_srl_phl(struct s_gb *s_gb)
{
	/* start of cb_srl_phl manual code */

	/* end of cb_srl_phl manual code */
	uint8_t value;

	value = read8bit(s_gb->gb_register.hl, s_gb);
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	FLAGS_CLEAR(value, 1 << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	write8bit(s_gb->gb_register.hl, value, s_gb);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* srl a [0x3F] : The contents of a are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. */
static void cb_srl_a(struct s_gb *s_gb)
{
	/* start of cb_srl_a manual code */

	/* end of cb_srl_a manual code */
	uint8_t value;

	value = s_gb->gb_register.a;
	if (BIT(0, value) != 0)
		FLAGS_SET(s_gb->gb_register.f, FLAGS_CARRY);
	else
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_CARRY);
	value >>= 1;
	FLAGS_CLEAR(value, 1 << 7);
	if (value != 0)
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	s_gb->gb_register.a = value;
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC reset */
	CLEAR_HALFC();
	/* CARRY affected as defined */
}

/* bit 0,b [0x40] : Tests bit 0 of b. */
static void cb_bit_0_b(struct s_gb *s_gb)
{
	/* start of cb_bit_0_b manual code */

	/* end of cb_bit_0_b manual code */
	if (BIT(0, s_gb->gb_register.b))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 0,c [0x41] : Tests bit 0 of c. */
static void cb_bit_0_c(struct s_gb *s_gb)
{
	/* start of cb_bit_0_c manual code */

	/* end of cb_bit_0_c manual code */
	if (BIT(0, s_gb->gb_register.c))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 0,d [0x42] : Tests bit 0 of d. */
static void cb_bit_0_d(struct s_gb *s_gb)
{
	/* start of cb_bit_0_d manual code */

	/* end of cb_bit_0_d manual code */
	if (BIT(0, s_gb->gb_register.d))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 0,e [0x43] : Tests bit 0 of e. */
static void cb_bit_0_e(struct s_gb *s_gb)
{
	/* start of cb_bit_0_e manual code */

	/* end of cb_bit_0_e manual code */
	if (BIT(0, s_gb->gb_register.e))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 0,h [0x44] : Tests bit 0 of h. */
static void cb_bit_0_h(struct s_gb *s_gb)
{
	/* start of cb_bit_0_h manual code */

	/* end of cb_bit_0_h manual code */
	if (BIT(0, s_gb->gb_register.h))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 0,l [0x45] : Tests bit 0 of l. */
static void cb_bit_0_l(struct s_gb *s_gb)
{
	/* start of cb_bit_0_l manual code */

	/* end of cb_bit_0_l manual code */
	if (BIT(0, s_gb->gb_register.l))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 0,(hl) [0x46] : Tests bit 0 of (hl). */
static void cb_bit_0_phl(struct s_gb *s_gb)
{
	/* start of cb_bit_0_phl manual code */

	/* end of cb_bit_0_phl manual code */
	if (BIT(0, read8bit(s_gb->gb_register.hl, s_gb)))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 0,a [0x47] : Tests bit 0 of a. */
static void cb_bit_0_a(struct s_gb *s_gb)
{
	/* start of cb_bit_0_a manual code */

	/* end of cb_bit_0_a manual code */
	if (BIT(0, s_gb->gb_register.a))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 1,b [0x48] : Tests bit 1 of b. */
static void cb_bit_1_b(struct s_gb *s_gb)
{
	/* start of cb_bit_1_b manual code */

	/* end of cb_bit_1_b manual code */
	if (BIT(1, s_gb->gb_register.b))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 1,c [0x49] : Tests bit 1 of c. */
static void cb_bit_1_c(struct s_gb *s_gb)
{
	/* start of cb_bit_1_c manual code */

	/* end of cb_bit_1_c manual code */
	if (BIT(1, s_gb->gb_register.c))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 1,d [0x4A] : Tests bit 1 of d. */
static void cb_bit_1_d(struct s_gb *s_gb)
{
	/* start of cb_bit_1_d manual code */

	/* end of cb_bit_1_d manual code */
	if (BIT(1, s_gb->gb_register.d))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 1,e [0x4B] : Tests bit 1 of e. */
static void cb_bit_1_e(struct s_gb *s_gb)
{
	/* start of cb_bit_1_e manual code */

	/* end of cb_bit_1_e manual code */
	if (BIT(1, s_gb->gb_register.e))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 1,h [0x4C] : Tests bit 1 of h. */
static void cb_bit_1_h(struct s_gb *s_gb)
{
	/* start of cb_bit_1_h manual code */

	/* end of cb_bit_1_h manual code */
	if (BIT(1, s_gb->gb_register.h))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 1,l [0x4D] : Tests bit 1 of l. */
static void cb_bit_1_l(struct s_gb *s_gb)
{
	/* start of cb_bit_1_l manual code */

	/* end of cb_bit_1_l manual code */
	if (BIT(1, s_gb->gb_register.l))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 1,(hl) [0x4E] : Tests bit 1 of (hl). */
static void cb_bit_1_phl(struct s_gb *s_gb)
{
	/* start of cb_bit_1_phl manual code */

	/* end of cb_bit_1_phl manual code */
	if (BIT(1, read8bit(s_gb->gb_register.hl, s_gb)))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 1,a [0x4F] : Tests bit 1 of a. */
static void cb_bit_1_a(struct s_gb *s_gb)
{
	/* start of cb_bit_1_a manual code */

	/* end of cb_bit_1_a manual code */
	if (BIT(1, s_gb->gb_register.a))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 2,b [0x50] : Tests bit 2 of b. */
static void cb_bit_2_b(struct s_gb *s_gb)
{
	/* start of cb_bit_2_b manual code */

	/* end of cb_bit_2_b manual code */
	if (BIT(2, s_gb->gb_register.b))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 2,c [0x51] : Tests bit 2 of c. */
static void cb_bit_2_c(struct s_gb *s_gb)
{
	/* start of cb_bit_2_c manual code */

	/* end of cb_bit_2_c manual code */
	if (BIT(2, s_gb->gb_register.c))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 2,d [0x52] : Tests bit 2 of d. */
static void cb_bit_2_d(struct s_gb *s_gb)
{
	/* start of cb_bit_2_d manual code */

	/* end of cb_bit_2_d manual code */
	if (BIT(2, s_gb->gb_register.d))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 2,e [0x53] : Tests bit 2 of e. */
static void cb_bit_2_e(struct s_gb *s_gb)
{
	/* start of cb_bit_2_e manual code */

	/* end of cb_bit_2_e manual code */
	if (BIT(2, s_gb->gb_register.e))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 2,h [0x54] : Tests bit 2 of h. */
static void cb_bit_2_h(struct s_gb *s_gb)
{
	/* start of cb_bit_2_h manual code */

	/* end of cb_bit_2_h manual code */
	if (BIT(2, s_gb->gb_register.h))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 2,l [0x55] : Tests bit 2 of l. */
static void cb_bit_2_l(struct s_gb *s_gb)
{
	/* start of cb_bit_2_l manual code */

	/* end of cb_bit_2_l manual code */
	if (BIT(2, s_gb->gb_register.l))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 2,(hl) [0x56] : Tests bit 2 of (hl). */
static void cb_bit_2_phl(struct s_gb *s_gb)
{
	/* start of cb_bit_2_phl manual code */

	/* end of cb_bit_2_phl manual code */
	if (BIT(2, read8bit(s_gb->gb_register.hl, s_gb)))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 2,a [0x57] : Tests bit 2 of a. */
static void cb_bit_2_a(struct s_gb *s_gb)
{
	/* start of cb_bit_2_a manual code */

	/* end of cb_bit_2_a manual code */
	if (BIT(2, s_gb->gb_register.a))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 3,b [0x58] : Tests bit 3 of b. */
static void cb_bit_3_b(struct s_gb *s_gb)
{
	/* start of cb_bit_3_b manual code */

	/* end of cb_bit_3_b manual code */
	if (BIT(3, s_gb->gb_register.b))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 3,c [0x59] : Tests bit 3 of c. */
static void cb_bit_3_c(struct s_gb *s_gb)
{
	/* start of cb_bit_3_c manual code */

	/* end of cb_bit_3_c manual code */
	if (BIT(3, s_gb->gb_register.c))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 3,d [0x5A] : Tests bit 3 of d. */
static void cb_bit_3_d(struct s_gb *s_gb)
{
	/* start of cb_bit_3_d manual code */

	/* end of cb_bit_3_d manual code */
	if (BIT(3, s_gb->gb_register.d))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 3,e [0x5B] : Tests bit 3 of e. */
static void cb_bit_3_e(struct s_gb *s_gb)
{
	/* start of cb_bit_3_e manual code */

	/* end of cb_bit_3_e manual code */
	if (BIT(3, s_gb->gb_register.e))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 3,h [0x5C] : Tests bit 3 of h. */
static void cb_bit_3_h(struct s_gb *s_gb)
{
	/* start of cb_bit_3_h manual code */

	/* end of cb_bit_3_h manual code */
	if (BIT(3, s_gb->gb_register.h))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 3,l [0x5D] : Tests bit 3 of l. */
static void cb_bit_3_l(struct s_gb *s_gb)
{
	/* start of cb_bit_3_l manual code */

	/* end of cb_bit_3_l manual code */
	if (BIT(3, s_gb->gb_register.l))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 3,(hl) [0x5E] : Tests bit 3 of (hl). */
static void cb_bit_3_phl(struct s_gb *s_gb)
{
	/* start of cb_bit_3_phl manual code */

	/* end of cb_bit_3_phl manual code */
	if (BIT(3, read8bit(s_gb->gb_register.hl, s_gb)))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 3,a [0x5F] : Tests bit 3 of a. */
static void cb_bit_3_a(struct s_gb *s_gb)
{
	/* start of cb_bit_3_a manual code */

	/* end of cb_bit_3_a manual code */
	if (BIT(3, s_gb->gb_register.a))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 4,b [0x60] : Tests bit 4 of b. */
static void cb_bit_4_b(struct s_gb *s_gb)
{
	/* start of cb_bit_4_b manual code */

	/* end of cb_bit_4_b manual code */
	if (BIT(4, s_gb->gb_register.b))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 4,c [0x61] : Tests bit 4 of c. */
static void cb_bit_4_c(struct s_gb *s_gb)
{
	/* start of cb_bit_4_c manual code */

	/* end of cb_bit_4_c manual code */
	if (BIT(4, s_gb->gb_register.c))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 4,d [0x62] : Tests bit 4 of d. */
static void cb_bit_4_d(struct s_gb *s_gb)
{
	/* start of cb_bit_4_d manual code */

	/* end of cb_bit_4_d manual code */
	if (BIT(4, s_gb->gb_register.d))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 4,e [0x63] : Tests bit 4 of e. */
static void cb_bit_4_e(struct s_gb *s_gb)
{
	/* start of cb_bit_4_e manual code */

	/* end of cb_bit_4_e manual code */
	if (BIT(4, s_gb->gb_register.e))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 4,h [0x64] : Tests bit 4 of h. */
static void cb_bit_4_h(struct s_gb *s_gb)
{
	/* start of cb_bit_4_h manual code */

	/* end of cb_bit_4_h manual code */
	if (BIT(4, s_gb->gb_register.h))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 4,l [0x65] : Tests bit 4 of l. */
static void cb_bit_4_l(struct s_gb *s_gb)
{
	/* start of cb_bit_4_l manual code */

	/* end of cb_bit_4_l manual code */
	if (BIT(4, s_gb->gb_register.l))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 4,(hl) [0x66] : Tests bit 4 of (hl). */
static void cb_bit_4_phl(struct s_gb *s_gb)
{
	/* start of cb_bit_4_phl manual code */

	/* end of cb_bit_4_phl manual code */
	if (BIT(4, read8bit(s_gb->gb_register.hl, s_gb)))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 4,a [0x67] : Tests bit 4 of a. */
static void cb_bit_4_a(struct s_gb *s_gb)
{
	/* start of cb_bit_4_a manual code */

	/* end of cb_bit_4_a manual code */
	if (BIT(4, s_gb->gb_register.a))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 5,b [0x68] : Tests bit 5 of b. */
static void cb_bit_5_b(struct s_gb *s_gb)
{
	/* start of cb_bit_5_b manual code */

	/* end of cb_bit_5_b manual code */
	if (BIT(5, s_gb->gb_register.b))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 5,c [0x69] : Tests bit 5 of c. */
static void cb_bit_5_c(struct s_gb *s_gb)
{
	/* start of cb_bit_5_c manual code */

	/* end of cb_bit_5_c manual code */
	if (BIT(5, s_gb->gb_register.c))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 5,d [0x6A] : Tests bit 5 of d. */
static void cb_bit_5_d(struct s_gb *s_gb)
{
	/* start of cb_bit_5_d manual code */

	/* end of cb_bit_5_d manual code */
	if (BIT(5, s_gb->gb_register.d))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 5,e [0x6B] : Tests bit 5 of e. */
static void cb_bit_5_e(struct s_gb *s_gb)
{
	/* start of cb_bit_5_e manual code */

	/* end of cb_bit_5_e manual code */
	if (BIT(5, s_gb->gb_register.e))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 5,h [0x6C] : Tests bit 5 of h. */
static void cb_bit_5_h(struct s_gb *s_gb)
{
	/* start of cb_bit_5_h manual code */

	/* end of cb_bit_5_h manual code */
	if (BIT(5, s_gb->gb_register.h))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 5,l [0x6D] : Tests bit 5 of l. */
static void cb_bit_5_l(struct s_gb *s_gb)
{
	/* start of cb_bit_5_l manual code */

	/* end of cb_bit_5_l manual code */
	if (BIT(5, s_gb->gb_register.l))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 5,(hl) [0x6E] : Tests bit 5 of (hl). */
static void cb_bit_5_phl(struct s_gb *s_gb)
{
	/* start of cb_bit_5_phl manual code */

	/* end of cb_bit_5_phl manual code */
	if (BIT(5, read8bit(s_gb->gb_register.hl, s_gb)))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 5,a [0x6F] : Tests bit 5 of a. */
static void cb_bit_5_a(struct s_gb *s_gb)
{
	/* start of cb_bit_5_a manual code */

	/* end of cb_bit_5_a manual code */
	if (BIT(5, s_gb->gb_register.a))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 6,b [0x70] : Tests bit 6 of b. */
static void cb_bit_6_b(struct s_gb *s_gb)
{
	/* start of cb_bit_6_b manual code */

	/* end of cb_bit_6_b manual code */
	if (BIT(6, s_gb->gb_register.b))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 6,c [0x71] : Tests bit 6 of c. */
static void cb_bit_6_c(struct s_gb *s_gb)
{
	/* start of cb_bit_6_c manual code */

	/* end of cb_bit_6_c manual code */
	if (BIT(6, s_gb->gb_register.c))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 6,d [0x72] : Tests bit 6 of d. */
static void cb_bit_6_d(struct s_gb *s_gb)
{
	/* start of cb_bit_6_d manual code */

	/* end of cb_bit_6_d manual code */
	if (BIT(6, s_gb->gb_register.d))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 6,e [0x73] : Tests bit 6 of e. */
static void cb_bit_6_e(struct s_gb *s_gb)
{
	/* start of cb_bit_6_e manual code */

	/* end of cb_bit_6_e manual code */
	if (BIT(6, s_gb->gb_register.e))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 6,h [0x74] : Tests bit 6 of h. */
static void cb_bit_6_h(struct s_gb *s_gb)
{
	/* start of cb_bit_6_h manual code */

	/* end of cb_bit_6_h manual code */
	if (BIT(6, s_gb->gb_register.h))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 6,l [0x75] : Tests bit 6 of l. */
static void cb_bit_6_l(struct s_gb *s_gb)
{
	/* start of cb_bit_6_l manual code */

	/* end of cb_bit_6_l manual code */
	if (BIT(6, s_gb->gb_register.l))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 6,(hl) [0x76] : Tests bit 6 of (hl). */
static void cb_bit_6_phl(struct s_gb *s_gb)
{
	/* start of cb_bit_6_phl manual code */

	/* end of cb_bit_6_phl manual code */
	if (BIT(6, read8bit(s_gb->gb_register.hl, s_gb)))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 6,a [0x77] : Tests bit 6 of a. */
static void cb_bit_6_a(struct s_gb *s_gb)
{
	/* start of cb_bit_6_a manual code */

	/* end of cb_bit_6_a manual code */
	if (BIT(6, s_gb->gb_register.a))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 7,b [0x78] : Tests bit 7 of b. */
static void cb_bit_7_b(struct s_gb *s_gb)
{
	/* start of cb_bit_7_b manual code */

	/* end of cb_bit_7_b manual code */
	if (BIT(7, s_gb->gb_register.b))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 7,c [0x79] : Tests bit 7 of c. */
static void cb_bit_7_c(struct s_gb *s_gb)
{
	/* start of cb_bit_7_c manual code */

	/* end of cb_bit_7_c manual code */
	if (BIT(7, s_gb->gb_register.c))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 7,d [0x7A] : Tests bit 7 of d. */
static void cb_bit_7_d(struct s_gb *s_gb)
{
	/* start of cb_bit_7_d manual code */

	/* end of cb_bit_7_d manual code */
	if (BIT(7, s_gb->gb_register.d))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 7,e [0x7B] : Tests bit 7 of e. */
static void cb_bit_7_e(struct s_gb *s_gb)
{
	/* start of cb_bit_7_e manual code */

	/* end of cb_bit_7_e manual code */
	if (BIT(7, s_gb->gb_register.e))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 7,h [0x7C] : Tests bit 7 of h. */
static void cb_bit_7_h(struct s_gb *s_gb)
{
	/* start of cb_bit_7_h manual code */

	/* end of cb_bit_7_h manual code */
	if (BIT(7, s_gb->gb_register.h))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 7,l [0x7D] : Tests bit 7 of l. */
static void cb_bit_7_l(struct s_gb *s_gb)
{
	/* start of cb_bit_7_l manual code */

	/* end of cb_bit_7_l manual code */
	if (BIT(7, s_gb->gb_register.l))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 7,(hl) [0x7E] : Tests bit 7 of (hl). */
static void cb_bit_7_phl(struct s_gb *s_gb)
{
	/* start of cb_bit_7_phl manual code */

	/* end of cb_bit_7_phl manual code */
	if (BIT(7, read8bit(s_gb->gb_register.hl, s_gb)))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* bit 7,a [0x7F] : Tests bit 7 of a. */
static void cb_bit_7_a(struct s_gb *s_gb)
{
	/* start of cb_bit_7_a manual code */

	/* end of cb_bit_7_a manual code */
	if (BIT(7, s_gb->gb_register.a))
		FLAGS_CLEAR(s_gb->gb_register.f, FLAGS_ZERO);
	else
		FLAGS_SET(s_gb->gb_register.f, FLAGS_ZERO);
	/* ZERO affected as defined */
	/* NEG reset */
	CLEAR_NEG();
	/* HALFC set */
	SET_HALFC();
	/* CARRY unaffected */
}

/* res 0,b [0x80] : Resets bit 0 of b. */
static void cb_res_0_b(struct s_gb *s_gb)
{
	/* start of cb_res_0_b manual code */

	/* end of cb_res_0_b manual code */
	s_gb->gb_register.b &= ~(1 << 0);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 0,c [0x81] : Resets bit 0 of c. */
static void cb_res_0_c(struct s_gb *s_gb)
{
	/* start of cb_res_0_c manual code */

	/* end of cb_res_0_c manual code */
	s_gb->gb_register.c &= ~(1 << 0);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 0,d [0x82] : Resets bit 0 of d. */
static void cb_res_0_d(struct s_gb *s_gb)
{
	/* start of cb_res_0_d manual code */

	/* end of cb_res_0_d manual code */
	s_gb->gb_register.d &= ~(1 << 0);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 0,e [0x83] : Resets bit 0 of e. */
static void cb_res_0_e(struct s_gb *s_gb)
{
	/* start of cb_res_0_e manual code */

	/* end of cb_res_0_e manual code */
	s_gb->gb_register.e &= ~(1 << 0);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 0,h [0x84] : Resets bit 0 of h. */
static void cb_res_0_h(struct s_gb *s_gb)
{
	/* start of cb_res_0_h manual code */

	/* end of cb_res_0_h manual code */
	s_gb->gb_register.h &= ~(1 << 0);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 0,l [0x85] : Resets bit 0 of l. */
static void cb_res_0_l(struct s_gb *s_gb)
{
	/* start of cb_res_0_l manual code */

	/* end of cb_res_0_l manual code */
	s_gb->gb_register.l &= ~(1 << 0);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 0,(hl) [0x86] : Resets bit 0 of (hl). */
static void cb_res_0_phl(struct s_gb *s_gb)
{
	/* start of cb_res_0_phl manual code */

	/* end of cb_res_0_phl manual code */
	write8bit(s_gb->gb_register.hl, read8bit(s_gb->gb_register.hl, s_gb) & ~(1 << 0), s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 0,a [0x87] : Resets bit 0 of a. */
static void cb_res_0_a(struct s_gb *s_gb)
{
	/* start of cb_res_0_a manual code */

	/* end of cb_res_0_a manual code */
	s_gb->gb_register.a &= ~(1 << 0);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 1,b [0x88] : Resets bit 1 of b. */
static void cb_res_1_b(struct s_gb *s_gb)
{
	/* start of cb_res_1_b manual code */

	/* end of cb_res_1_b manual code */
	s_gb->gb_register.b &= ~(1 << 1);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 1,c [0x89] : Resets bit 1 of c. */
static void cb_res_1_c(struct s_gb *s_gb)
{
	/* start of cb_res_1_c manual code */

	/* end of cb_res_1_c manual code */
	s_gb->gb_register.c &= ~(1 << 1);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 1,d [0x8A] : Resets bit 1 of d. */
static void cb_res_1_d(struct s_gb *s_gb)
{
	/* start of cb_res_1_d manual code */

	/* end of cb_res_1_d manual code */
	s_gb->gb_register.d &= ~(1 << 1);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 1,e [0x8B] : Resets bit 1 of e. */
static void cb_res_1_e(struct s_gb *s_gb)
{
	/* start of cb_res_1_e manual code */

	/* end of cb_res_1_e manual code */
	s_gb->gb_register.e &= ~(1 << 1);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 1,h [0x8C] : Resets bit 1 of h. */
static void cb_res_1_h(struct s_gb *s_gb)
{
	/* start of cb_res_1_h manual code */

	/* end of cb_res_1_h manual code */
	s_gb->gb_register.h &= ~(1 << 1);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 1,l [0x8D] : Resets bit 1 of l. */
static void cb_res_1_l(struct s_gb *s_gb)
{
	/* start of cb_res_1_l manual code */

	/* end of cb_res_1_l manual code */
	s_gb->gb_register.l &= ~(1 << 1);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 1,(hl) [0x8E] : Resets bit 1 of (hl). */
static void cb_res_1_phl(struct s_gb *s_gb)
{
	/* start of cb_res_1_phl manual code */

	/* end of cb_res_1_phl manual code */
	write8bit(s_gb->gb_register.hl, read8bit(s_gb->gb_register.hl, s_gb) & ~(1 << 1), s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 1,a [0x8F] : Resets bit 1 of a. */
static void cb_res_1_a(struct s_gb *s_gb)
{
	/* start of cb_res_1_a manual code */

	/* end of cb_res_1_a manual code */
	s_gb->gb_register.a &= ~(1 << 1);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 2,b [0x90] : Resets bit 2 of b. */
static void cb_res_2_b(struct s_gb *s_gb)
{
	/* start of cb_res_2_b manual code */

	/* end of cb_res_2_b manual code */
	s_gb->gb_register.b &= ~(1 << 2);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 2,c [0x91] : Resets bit 2 of c. */
static void cb_res_2_c(struct s_gb *s_gb)
{
	/* start of cb_res_2_c manual code */

	/* end of cb_res_2_c manual code */
	s_gb->gb_register.c &= ~(1 << 2);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 2,d [0x92] : Resets bit 2 of d. */
static void cb_res_2_d(struct s_gb *s_gb)
{
	/* start of cb_res_2_d manual code */

	/* end of cb_res_2_d manual code */
	s_gb->gb_register.d &= ~(1 << 2);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 2,e [0x93] : Resets bit 2 of e. */
static void cb_res_2_e(struct s_gb *s_gb)
{
	/* start of cb_res_2_e manual code */

	/* end of cb_res_2_e manual code */
	s_gb->gb_register.e &= ~(1 << 2);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 2,h [0x94] : Resets bit 2 of h. */
static void cb_res_2_h(struct s_gb *s_gb)
{
	/* start of cb_res_2_h manual code */

	/* end of cb_res_2_h manual code */
	s_gb->gb_register.h &= ~(1 << 2);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 2,l [0x95] : Resets bit 2 of l. */
static void cb_res_2_l(struct s_gb *s_gb)
{
	/* start of cb_res_2_l manual code */

	/* end of cb_res_2_l manual code */
	s_gb->gb_register.l &= ~(1 << 2);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 2,(hl) [0x96] : Resets bit 2 of (hl). */
static void cb_res_2_phl(struct s_gb *s_gb)
{
	/* start of cb_res_2_phl manual code */

	/* end of cb_res_2_phl manual code */
	write8bit(s_gb->gb_register.hl, read8bit(s_gb->gb_register.hl, s_gb) & ~(1 << 2), s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 2,a [0x97] : Resets bit 2 of a. */
static void cb_res_2_a(struct s_gb *s_gb)
{
	/* start of cb_res_2_a manual code */

	/* end of cb_res_2_a manual code */
	s_gb->gb_register.a &= ~(1 << 2);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 3,b [0x98] : Resets bit 3 of b. */
static void cb_res_3_b(struct s_gb *s_gb)
{
	/* start of cb_res_3_b manual code */

	/* end of cb_res_3_b manual code */
	s_gb->gb_register.b &= ~(1 << 3);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 3,c [0x99] : Resets bit 3 of c. */
static void cb_res_3_c(struct s_gb *s_gb)
{
	/* start of cb_res_3_c manual code */

	/* end of cb_res_3_c manual code */
	s_gb->gb_register.c &= ~(1 << 3);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 3,d [0x9A] : Resets bit 3 of d. */
static void cb_res_3_d(struct s_gb *s_gb)
{
	/* start of cb_res_3_d manual code */

	/* end of cb_res_3_d manual code */
	s_gb->gb_register.d &= ~(1 << 3);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 3,e [0x9B] : Resets bit 3 of e. */
static void cb_res_3_e(struct s_gb *s_gb)
{
	/* start of cb_res_3_e manual code */

	/* end of cb_res_3_e manual code */
	s_gb->gb_register.e &= ~(1 << 3);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 3,h [0x9C] : Resets bit 3 of h. */
static void cb_res_3_h(struct s_gb *s_gb)
{
	/* start of cb_res_3_h manual code */

	/* end of cb_res_3_h manual code */
	s_gb->gb_register.h &= ~(1 << 3);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 3,l [0x9D] : Resets bit 3 of l. */
static void cb_res_3_l(struct s_gb *s_gb)
{
	/* start of cb_res_3_l manual code */

	/* end of cb_res_3_l manual code */
	s_gb->gb_register.l &= ~(1 << 3);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 3,(hl) [0x9E] : Resets bit 3 of (hl). */
static void cb_res_3_phl(struct s_gb *s_gb)
{
	/* start of cb_res_3_phl manual code */

	/* end of cb_res_3_phl manual code */
	write8bit(s_gb->gb_register.hl, read8bit(s_gb->gb_register.hl, s_gb) & ~(1 << 3), s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 3,a [0x9F] : Resets bit 3 of a. */
static void cb_res_3_a(struct s_gb *s_gb)
{
	/* start of cb_res_3_a manual code */

	/* end of cb_res_3_a manual code */
	s_gb->gb_register.a &= ~(1 << 3);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 4,b [0xA0] : Resets bit 4 of b. */
static void cb_res_4_b(struct s_gb *s_gb)
{
	/* start of cb_res_4_b manual code */

	/* end of cb_res_4_b manual code */
	s_gb->gb_register.b &= ~(1 << 4);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 4,c [0xA1] : Resets bit 4 of c. */
static void cb_res_4_c(struct s_gb *s_gb)
{
	/* start of cb_res_4_c manual code */

	/* end of cb_res_4_c manual code */
	s_gb->gb_register.c &= ~(1 << 4);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 4,d [0xA2] : Resets bit 4 of d. */
static void cb_res_4_d(struct s_gb *s_gb)
{
	/* start of cb_res_4_d manual code */

	/* end of cb_res_4_d manual code */
	s_gb->gb_register.d &= ~(1 << 4);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 4,e [0xA3] : Resets bit 4 of e. */
static void cb_res_4_e(struct s_gb *s_gb)
{
	/* start of cb_res_4_e manual code */

	/* end of cb_res_4_e manual code */
	s_gb->gb_register.e &= ~(1 << 4);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 4,h [0xA4] : Resets bit 4 of h. */
static void cb_res_4_h(struct s_gb *s_gb)
{
	/* start of cb_res_4_h manual code */

	/* end of cb_res_4_h manual code */
	s_gb->gb_register.h &= ~(1 << 4);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 4,l [0xA5] : Resets bit 4 of l. */
static void cb_res_4_l(struct s_gb *s_gb)
{
	/* start of cb_res_4_l manual code */

	/* end of cb_res_4_l manual code */
	s_gb->gb_register.l &= ~(1 << 4);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 4,(hl) [0xA6] : Resets bit 4 of (hl). */
static void cb_res_4_phl(struct s_gb *s_gb)
{
	/* start of cb_res_4_phl manual code */

	/* end of cb_res_4_phl manual code */
	write8bit(s_gb->gb_register.hl, read8bit(s_gb->gb_register.hl, s_gb) & ~(1 << 4), s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 4,a [0xA7] : Resets bit 4 of a. */
static void cb_res_4_a(struct s_gb *s_gb)
{
	/* start of cb_res_4_a manual code */

	/* end of cb_res_4_a manual code */
	s_gb->gb_register.a &= ~(1 << 4);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 5,b [0xA8] : Resets bit 5 of b. */
static void cb_res_5_b(struct s_gb *s_gb)
{
	/* start of cb_res_5_b manual code */

	/* end of cb_res_5_b manual code */
	s_gb->gb_register.b &= ~(1 << 5);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 5,c [0xA9] : Resets bit 5 of c. */
static void cb_res_5_c(struct s_gb *s_gb)
{
	/* start of cb_res_5_c manual code */

	/* end of cb_res_5_c manual code */
	s_gb->gb_register.c &= ~(1 << 5);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 5,d [0xAA] : Resets bit 5 of d. */
static void cb_res_5_d(struct s_gb *s_gb)
{
	/* start of cb_res_5_d manual code */

	/* end of cb_res_5_d manual code */
	s_gb->gb_register.d &= ~(1 << 5);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 5,e [0xAB] : Resets bit 5 of e. */
static void cb_res_5_e(struct s_gb *s_gb)
{
	/* start of cb_res_5_e manual code */

	/* end of cb_res_5_e manual code */
	s_gb->gb_register.e &= ~(1 << 5);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 5,h [0xAC] : Resets bit 5 of h. */
static void cb_res_5_h(struct s_gb *s_gb)
{
	/* start of cb_res_5_h manual code */

	/* end of cb_res_5_h manual code */
	s_gb->gb_register.h &= ~(1 << 5);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 5,l [0xAD] : Resets bit 5 of l. */
static void cb_res_5_l(struct s_gb *s_gb)
{
	/* start of cb_res_5_l manual code */

	/* end of cb_res_5_l manual code */
	s_gb->gb_register.l &= ~(1 << 5);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 5,(hl) [0xAE] : Resets bit 5 of (hl). */
static void cb_res_5_phl(struct s_gb *s_gb)
{
	/* start of cb_res_5_phl manual code */

	/* end of cb_res_5_phl manual code */
	write8bit(s_gb->gb_register.hl, read8bit(s_gb->gb_register.hl, s_gb) & ~(1 << 5), s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 5,a [0xAF] : Resets bit 5 of a. */
static void cb_res_5_a(struct s_gb *s_gb)
{
	/* start of cb_res_5_a manual code */

	/* end of cb_res_5_a manual code */
	s_gb->gb_register.a &= ~(1 << 5);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 6,b [0xB0] : Resets bit 6 of b. */
static void cb_res_6_b(struct s_gb *s_gb)
{
	/* start of cb_res_6_b manual code */

	/* end of cb_res_6_b manual code */
	s_gb->gb_register.b &= ~(1 << 6);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 6,c [0xB1] : Resets bit 6 of c. */
static void cb_res_6_c(struct s_gb *s_gb)
{
	/* start of cb_res_6_c manual code */

	/* end of cb_res_6_c manual code */
	s_gb->gb_register.c &= ~(1 << 6);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 6,d [0xB2] : Resets bit 6 of d. */
static void cb_res_6_d(struct s_gb *s_gb)
{
	/* start of cb_res_6_d manual code */

	/* end of cb_res_6_d manual code */
	s_gb->gb_register.d &= ~(1 << 6);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 6,e [0xB3] : Resets bit 6 of e. */
static void cb_res_6_e(struct s_gb *s_gb)
{
	/* start of cb_res_6_e manual code */

	/* end of cb_res_6_e manual code */
	s_gb->gb_register.e &= ~(1 << 6);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 6,h [0xB4] : Resets bit 6 of h. */
static void cb_res_6_h(struct s_gb *s_gb)
{
	/* start of cb_res_6_h manual code */

	/* end of cb_res_6_h manual code */
	s_gb->gb_register.h &= ~(1 << 6);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 6,l [0xB5] : Resets bit 6 of l. */
static void cb_res_6_l(struct s_gb *s_gb)
{
	/* start of cb_res_6_l manual code */

	/* end of cb_res_6_l manual code */
	s_gb->gb_register.l &= ~(1 << 6);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 6,(hl) [0xB6] : Resets bit 6 of (hl). */
static void cb_res_6_phl(struct s_gb *s_gb)
{
	/* start of cb_res_6_phl manual code */

	/* end of cb_res_6_phl manual code */
	write8bit(s_gb->gb_register.hl, read8bit(s_gb->gb_register.hl, s_gb) & ~(1 << 6), s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 6,a [0xB7] : Resets bit 6 of a. */
static void cb_res_6_a(struct s_gb *s_gb)
{
	/* start of cb_res_6_a manual code */

	/* end of cb_res_6_a manual code */
	s_gb->gb_register.a &= ~(1 << 6);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 7,b [0xB8] : Resets bit 7 of b. */
static void cb_res_7_b(struct s_gb *s_gb)
{
	/* start of cb_res_7_b manual code */

	/* end of cb_res_7_b manual code */
	s_gb->gb_register.b &= ~(1 << 7);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 7,c [0xB9] : Resets bit 7 of c. */
static void cb_res_7_c(struct s_gb *s_gb)
{
	/* start of cb_res_7_c manual code */

	/* end of cb_res_7_c manual code */
	s_gb->gb_register.c &= ~(1 << 7);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 7,d [0xBA] : Resets bit 7 of d. */
static void cb_res_7_d(struct s_gb *s_gb)
{
	/* start of cb_res_7_d manual code */

	/* end of cb_res_7_d manual code */
	s_gb->gb_register.d &= ~(1 << 7);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 7,e [0xBB] : Resets bit 7 of e. */
static void cb_res_7_e(struct s_gb *s_gb)
{
	/* start of cb_res_7_e manual code */

	/* end of cb_res_7_e manual code */
	s_gb->gb_register.e &= ~(1 << 7);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 7,h [0xBC] : Resets bit 7 of h. */
static void cb_res_7_h(struct s_gb *s_gb)
{
	/* start of cb_res_7_h manual code */

	/* end of cb_res_7_h manual code */
	s_gb->gb_register.h &= ~(1 << 7);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 7,l [0xBD] : Resets bit 7 of l. */
static void cb_res_7_l(struct s_gb *s_gb)
{
	/* start of cb_res_7_l manual code */

	/* end of cb_res_7_l manual code */
	s_gb->gb_register.l &= ~(1 << 7);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 7,(hl) [0xBE] : Resets bit 7 of (hl). */
static void cb_res_7_phl(struct s_gb *s_gb)
{
	/* start of cb_res_7_phl manual code */

	/* end of cb_res_7_phl manual code */
	write8bit(s_gb->gb_register.hl, read8bit(s_gb->gb_register.hl, s_gb) & ~(1 << 7), s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* res 7,a [0xBF] : Resets bit 7 of a. */
static void cb_res_7_a(struct s_gb *s_gb)
{
	/* start of cb_res_7_a manual code */

	/* end of cb_res_7_a manual code */
	s_gb->gb_register.a &= ~(1 << 7);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 0,b [0xC0] : Sets bit 0 of b. */
static void cb_set_0_b(struct s_gb *s_gb)
{
	/* start of cb_set_0_b manual code */

	/* end of cb_set_0_b manual code */
	s_gb->gb_register.b |= (1 << 0);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 0,c [0xC1] : Sets bit 0 of c. */
static void cb_set_0_c(struct s_gb *s_gb)
{
	/* start of cb_set_0_c manual code */

	/* end of cb_set_0_c manual code */
	s_gb->gb_register.c |= (1 << 0);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 0,d [0xC2] : Sets bit 0 of d. */
static void cb_set_0_d(struct s_gb *s_gb)
{
	/* start of cb_set_0_d manual code */

	/* end of cb_set_0_d manual code */
	s_gb->gb_register.d |= (1 << 0);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 0,e [0xC3] : Sets bit 0 of e. */
static void cb_set_0_e(struct s_gb *s_gb)
{
	/* start of cb_set_0_e manual code */

	/* end of cb_set_0_e manual code */
	s_gb->gb_register.e |= (1 << 0);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 0,h [0xC4] : Sets bit 0 of h. */
static void cb_set_0_h(struct s_gb *s_gb)
{
	/* start of cb_set_0_h manual code */

	/* end of cb_set_0_h manual code */
	s_gb->gb_register.h |= (1 << 0);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 0,l [0xC5] : Sets bit 0 of l. */
static void cb_set_0_l(struct s_gb *s_gb)
{
	/* start of cb_set_0_l manual code */

	/* end of cb_set_0_l manual code */
	s_gb->gb_register.l |= (1 << 0);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 0,(hl) [0xC6] : Sets bit 0 of (hl). */
static void cb_set_0_phl(struct s_gb *s_gb)
{
	/* start of cb_set_0_phl manual code */

	/* end of cb_set_0_phl manual code */
	write8bit(s_gb->gb_register.hl, read8bit(s_gb->gb_register.hl, s_gb) | (1 << 0), s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 0,a [0xC7] : Sets bit 0 of a. */
static void cb_set_0_a(struct s_gb *s_gb)
{
	/* start of cb_set_0_a manual code */

	/* end of cb_set_0_a manual code */
	s_gb->gb_register.a |= (1 << 0);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 1,b [0xC8] : Sets bit 1 of b. */
static void cb_set_1_b(struct s_gb *s_gb)
{
	/* start of cb_set_1_b manual code */

	/* end of cb_set_1_b manual code */
	s_gb->gb_register.b |= (1 << 1);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 1,c [0xC9] : Sets bit 1 of c. */
static void cb_set_1_c(struct s_gb *s_gb)
{
	/* start of cb_set_1_c manual code */

	/* end of cb_set_1_c manual code */
	s_gb->gb_register.c |= (1 << 1);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 1,d [0xCA] : Sets bit 1 of d. */
static void cb_set_1_d(struct s_gb *s_gb)
{
	/* start of cb_set_1_d manual code */

	/* end of cb_set_1_d manual code */
	s_gb->gb_register.d |= (1 << 1);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 1,e [0xCB] : Sets bit 1 of e. */
static void cb_set_1_e(struct s_gb *s_gb)
{
	/* start of cb_set_1_e manual code */

	/* end of cb_set_1_e manual code */
	s_gb->gb_register.e |= (1 << 1);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 1,h [0xCC] : Sets bit 1 of h. */
static void cb_set_1_h(struct s_gb *s_gb)
{
	/* start of cb_set_1_h manual code */

	/* end of cb_set_1_h manual code */
	s_gb->gb_register.h |= (1 << 1);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 1,l [0xCD] : Sets bit 1 of l. */
static void cb_set_1_l(struct s_gb *s_gb)
{
	/* start of cb_set_1_l manual code */

	/* end of cb_set_1_l manual code */
	s_gb->gb_register.l |= (1 << 1);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 1,(hl) [0xCE] : Sets bit 1 of (hl). */
static void cb_set_1_phl(struct s_gb *s_gb)
{
	/* start of cb_set_1_phl manual code */

	/* end of cb_set_1_phl manual code */
	write8bit(s_gb->gb_register.hl, read8bit(s_gb->gb_register.hl, s_gb) | (1 << 1), s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 1,a [0xCF] : Sets bit 1 of a. */
static void cb_set_1_a(struct s_gb *s_gb)
{
	/* start of cb_set_1_a manual code */

	/* end of cb_set_1_a manual code */
	s_gb->gb_register.a |= (1 << 1);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 2,b [0xD0] : Sets bit 2 of b. */
static void cb_set_2_b(struct s_gb *s_gb)
{
	/* start of cb_set_2_b manual code */

	/* end of cb_set_2_b manual code */
	s_gb->gb_register.b |= (1 << 2);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 2,c [0xD1] : Sets bit 2 of c. */
static void cb_set_2_c(struct s_gb *s_gb)
{
	/* start of cb_set_2_c manual code */

	/* end of cb_set_2_c manual code */
	s_gb->gb_register.c |= (1 << 2);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 2,d [0xD2] : Sets bit 2 of d. */
static void cb_set_2_d(struct s_gb *s_gb)
{
	/* start of cb_set_2_d manual code */

	/* end of cb_set_2_d manual code */
	s_gb->gb_register.d |= (1 << 2);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 2,e [0xD3] : Sets bit 2 of e. */
static void cb_set_2_e(struct s_gb *s_gb)
{
	/* start of cb_set_2_e manual code */

	/* end of cb_set_2_e manual code */
	s_gb->gb_register.e |= (1 << 2);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 2,h [0xD4] : Sets bit 2 of h. */
static void cb_set_2_h(struct s_gb *s_gb)
{
	/* start of cb_set_2_h manual code */

	/* end of cb_set_2_h manual code */
	s_gb->gb_register.h |= (1 << 2);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 2,l [0xD5] : Sets bit 2 of l. */
static void cb_set_2_l(struct s_gb *s_gb)
{
	/* start of cb_set_2_l manual code */

	/* end of cb_set_2_l manual code */
	s_gb->gb_register.l |= (1 << 2);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 2,(hl) [0xD6] : Sets bit 2 of (hl). */
static void cb_set_2_phl(struct s_gb *s_gb)
{
	/* start of cb_set_2_phl manual code */

	/* end of cb_set_2_phl manual code */
	write8bit(s_gb->gb_register.hl, read8bit(s_gb->gb_register.hl, s_gb) | (1 << 2), s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 2,a [0xD7] : Sets bit 2 of a. */
static void cb_set_2_a(struct s_gb *s_gb)
{
	/* start of cb_set_2_a manual code */

	/* end of cb_set_2_a manual code */
	s_gb->gb_register.a |= (1 << 2);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 3,b [0xD8] : Sets bit 3 of b. */
static void cb_set_3_b(struct s_gb *s_gb)
{
	/* start of cb_set_3_b manual code */

	/* end of cb_set_3_b manual code */
	s_gb->gb_register.b |= (1 << 3);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 3,c [0xD9] : Sets bit 3 of c. */
static void cb_set_3_c(struct s_gb *s_gb)
{
	/* start of cb_set_3_c manual code */

	/* end of cb_set_3_c manual code */
	s_gb->gb_register.c |= (1 << 3);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 3,d [0xDA] : Sets bit 3 of d. */
static void cb_set_3_d(struct s_gb *s_gb)
{
	/* start of cb_set_3_d manual code */

	/* end of cb_set_3_d manual code */
	s_gb->gb_register.d |= (1 << 3);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 3,e [0xDB] : Sets bit 3 of e. */
static void cb_set_3_e(struct s_gb *s_gb)
{
	/* start of cb_set_3_e manual code */

	/* end of cb_set_3_e manual code */
	s_gb->gb_register.e |= (1 << 3);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 3,h [0xDC] : Sets bit 3 of h. */
static void cb_set_3_h(struct s_gb *s_gb)
{
	/* start of cb_set_3_h manual code */

	/* end of cb_set_3_h manual code */
	s_gb->gb_register.h |= (1 << 3);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 3,l [0xDD] : Sets bit 3 of l. */
static void cb_set_3_l(struct s_gb *s_gb)
{
	/* start of cb_set_3_l manual code */

	/* end of cb_set_3_l manual code */
	s_gb->gb_register.l |= (1 << 3);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 3,(hl) [0xDE] : Sets bit 3 of (hl). */
static void cb_set_3_phl(struct s_gb *s_gb)
{
	/* start of cb_set_3_phl manual code */

	/* end of cb_set_3_phl manual code */
	write8bit(s_gb->gb_register.hl, read8bit(s_gb->gb_register.hl, s_gb) | (1 << 3), s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 3,a [0xDF] : Sets bit 3 of a. */
static void cb_set_3_a(struct s_gb *s_gb)
{
	/* start of cb_set_3_a manual code */

	/* end of cb_set_3_a manual code */
	s_gb->gb_register.a |= (1 << 3);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 4,b [0xE0] : Sets bit 4 of b. */
static void cb_set_4_b(struct s_gb *s_gb)
{
	/* start of cb_set_4_b manual code */

	/* end of cb_set_4_b manual code */
	s_gb->gb_register.b |= (1 << 4);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 4,c [0xE1] : Sets bit 4 of c. */
static void cb_set_4_c(struct s_gb *s_gb)
{
	/* start of cb_set_4_c manual code */

	/* end of cb_set_4_c manual code */
	s_gb->gb_register.c |= (1 << 4);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 4,d [0xE2] : Sets bit 4 of d. */
static void cb_set_4_d(struct s_gb *s_gb)
{
	/* start of cb_set_4_d manual code */

	/* end of cb_set_4_d manual code */
	s_gb->gb_register.d |= (1 << 4);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 4,e [0xE3] : Sets bit 4 of e. */
static void cb_set_4_e(struct s_gb *s_gb)
{
	/* start of cb_set_4_e manual code */

	/* end of cb_set_4_e manual code */
	s_gb->gb_register.e |= (1 << 4);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 4,h [0xE4] : Sets bit 4 of h. */
static void cb_set_4_h(struct s_gb *s_gb)
{
	/* start of cb_set_4_h manual code */

	/* end of cb_set_4_h manual code */
	s_gb->gb_register.h |= (1 << 4);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 4,l [0xE5] : Sets bit 4 of l. */
static void cb_set_4_l(struct s_gb *s_gb)
{
	/* start of cb_set_4_l manual code */

	/* end of cb_set_4_l manual code */
	s_gb->gb_register.l |= (1 << 4);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 4,(hl) [0xE6] : Sets bit 4 of (hl). */
static void cb_set_4_phl(struct s_gb *s_gb)
{
	/* start of cb_set_4_phl manual code */

	/* end of cb_set_4_phl manual code */
	write8bit(s_gb->gb_register.hl, read8bit(s_gb->gb_register.hl, s_gb) | (1 << 4), s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 4,a [0xE7] : Sets bit 4 of a. */
static void cb_set_4_a(struct s_gb *s_gb)
{
	/* start of cb_set_4_a manual code */

	/* end of cb_set_4_a manual code */
	s_gb->gb_register.a |= (1 << 4);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 5,b [0xE8] : Sets bit 5 of b. */
static void cb_set_5_b(struct s_gb *s_gb)
{
	/* start of cb_set_5_b manual code */

	/* end of cb_set_5_b manual code */
	s_gb->gb_register.b |= (1 << 5);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 5,c [0xE9] : Sets bit 5 of c. */
static void cb_set_5_c(struct s_gb *s_gb)
{
	/* start of cb_set_5_c manual code */

	/* end of cb_set_5_c manual code */
	s_gb->gb_register.c |= (1 << 5);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 5,d [0xEA] : Sets bit 5 of d. */
static void cb_set_5_d(struct s_gb *s_gb)
{
	/* start of cb_set_5_d manual code */

	/* end of cb_set_5_d manual code */
	s_gb->gb_register.d |= (1 << 5);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 5,e [0xEB] : Sets bit 5 of e. */
static void cb_set_5_e(struct s_gb *s_gb)
{
	/* start of cb_set_5_e manual code */

	/* end of cb_set_5_e manual code */
	s_gb->gb_register.e |= (1 << 5);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 5,h [0xEC] : Sets bit 5 of h. */
static void cb_set_5_h(struct s_gb *s_gb)
{
	/* start of cb_set_5_h manual code */

	/* end of cb_set_5_h manual code */
	s_gb->gb_register.h |= (1 << 5);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 5,l [0xED] : Sets bit 5 of l. */
static void cb_set_5_l(struct s_gb *s_gb)
{
	/* start of cb_set_5_l manual code */

	/* end of cb_set_5_l manual code */
	s_gb->gb_register.l |= (1 << 5);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 5,(hl) [0xEE] : Sets bit 5 of (hl). */
static void cb_set_5_phl(struct s_gb *s_gb)
{
	/* start of cb_set_5_phl manual code */

	/* end of cb_set_5_phl manual code */
	write8bit(s_gb->gb_register.hl, read8bit(s_gb->gb_register.hl, s_gb) | (1 << 5), s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 5,a [0xEF] : Sets bit 5 of a. */
static void cb_set_5_a(struct s_gb *s_gb)
{
	/* start of cb_set_5_a manual code */

	/* end of cb_set_5_a manual code */
	s_gb->gb_register.a |= (1 << 5);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 6,b [0xF0] : Sets bit 6 of b. */
static void cb_set_6_b(struct s_gb *s_gb)
{
	/* start of cb_set_6_b manual code */

	/* end of cb_set_6_b manual code */
	s_gb->gb_register.b |= (1 << 6);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 6,c [0xF1] : Sets bit 6 of c. */
static void cb_set_6_c(struct s_gb *s_gb)
{
	/* start of cb_set_6_c manual code */

	/* end of cb_set_6_c manual code */
	s_gb->gb_register.c |= (1 << 6);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 6,d [0xF2] : Sets bit 6 of d. */
static void cb_set_6_d(struct s_gb *s_gb)
{
	/* start of cb_set_6_d manual code */

	/* end of cb_set_6_d manual code */
	s_gb->gb_register.d |= (1 << 6);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 6,e [0xF3] : Sets bit 6 of e. */
static void cb_set_6_e(struct s_gb *s_gb)
{
	/* start of cb_set_6_e manual code */

	/* end of cb_set_6_e manual code */
	s_gb->gb_register.e |= (1 << 6);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 6,h [0xF4] : Sets bit 6 of h. */
static void cb_set_6_h(struct s_gb *s_gb)
{
	/* start of cb_set_6_h manual code */

	/* end of cb_set_6_h manual code */
	s_gb->gb_register.h |= (1 << 6);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 6,l [0xF5] : Sets bit 6 of l. */
static void cb_set_6_l(struct s_gb *s_gb)
{
	/* start of cb_set_6_l manual code */

	/* end of cb_set_6_l manual code */
	s_gb->gb_register.l |= (1 << 6);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 6,(hl) [0xF6] : Sets bit 6 of (hl). */
static void cb_set_6_phl(struct s_gb *s_gb)
{
	/* start of cb_set_6_phl manual code */

	/* end of cb_set_6_phl manual code */
	write8bit(s_gb->gb_register.hl, read8bit(s_gb->gb_register.hl, s_gb) | (1 << 6), s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 6,a [0xF7] : Sets bit 6 of a. */
static void cb_set_6_a(struct s_gb *s_gb)
{
	/* start of cb_set_6_a manual code */

	/* end of cb_set_6_a manual code */
	s_gb->gb_register.a |= (1 << 6);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 7,b [0xF8] : Sets bit 7 of b. */
static void cb_set_7_b(struct s_gb *s_gb)
{
	/* start of cb_set_7_b manual code */

	/* end of cb_set_7_b manual code */
	s_gb->gb_register.b |= (1 << 7);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 7,c [0xF9] : Sets bit 7 of c. */
static void cb_set_7_c(struct s_gb *s_gb)
{
	/* start of cb_set_7_c manual code */

	/* end of cb_set_7_c manual code */
	s_gb->gb_register.c |= (1 << 7);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 7,d [0xFA] : Sets bit 7 of d. */
static void cb_set_7_d(struct s_gb *s_gb)
{
	/* start of cb_set_7_d manual code */

	/* end of cb_set_7_d manual code */
	s_gb->gb_register.d |= (1 << 7);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 7,e [0xFB] : Sets bit 7 of e. */
static void cb_set_7_e(struct s_gb *s_gb)
{
	/* start of cb_set_7_e manual code */

	/* end of cb_set_7_e manual code */
	s_gb->gb_register.e |= (1 << 7);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 7,h [0xFC] : Sets bit 7 of h. */
static void cb_set_7_h(struct s_gb *s_gb)
{
	/* start of cb_set_7_h manual code */

	/* end of cb_set_7_h manual code */
	s_gb->gb_register.h |= (1 << 7);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 7,l [0xFD] : Sets bit 7 of l. */
static void cb_set_7_l(struct s_gb *s_gb)
{
	/* start of cb_set_7_l manual code */

	/* end of cb_set_7_l manual code */
	s_gb->gb_register.l |= (1 << 7);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 7,(hl) [0xFE] : Sets bit 7 of (hl). */
static void cb_set_7_phl(struct s_gb *s_gb)
{
	/* start of cb_set_7_phl manual code */

	/* end of cb_set_7_phl manual code */
	write8bit(s_gb->gb_register.hl, read8bit(s_gb->gb_register.hl, s_gb) | (1 << 7), s_gb);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

/* set 7,a [0xFF] : Sets bit 7 of a. */
static void cb_set_7_a(struct s_gb *s_gb)
{
	/* start of cb_set_7_a manual code */

	/* end of cb_set_7_a manual code */
	s_gb->gb_register.a |= (1 << 7);
	/* ZERO unaffected */
	/* NEG unaffected */
	/* HALFC unaffected */
	/* CARRY unaffected */
}

const struct s_cpu_z80 instructions_cb[] = {
	[0x00] = {
		.opcode = 0x00,
		.value = "rlc b",
		.doc = "The contents of b are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_rlc_b,
	},
	[0x01] = {
		.opcode = 0x01,
		.value = "rlc c",
		.doc = "The contents of c are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_rlc_c,
	},
	[0x02] = {
		.opcode = 0x02,
		.value = "rlc d",
		.doc = "The contents of d are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_rlc_d,
	},
	[0x03] = {
		.opcode = 0x03,
		.value = "rlc e",
		.doc = "The contents of e are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_rlc_e,
	},
	[0x04] = {
		.opcode = 0x04,
		.value = "rlc h",
		.doc = "The contents of h are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_rlc_h,
	},
	[0x05] = {
		.opcode = 0x05,
		.value = "rlc l",
		.doc = "The contents of l are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_rlc_l,
	},
	[0x06] = {
		.opcode = 0x06,
		.value = "rlc (hl)",
		.doc = "The contents of (hl) are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.",
		.cycles = 16,
		.size = 2,
		.func = cb_rlc_phl,
	},
	[0x07] = {
		.opcode = 0x07,
		.value = "rlc a",
		.doc = "The contents of a are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_rlc_a,
	},
	[0x08] = {
		.opcode = 0x08,
		.value = "rrc b",
		.doc = "The contents of b are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_rrc_b,
	},
	[0x09] = {
		.opcode = 0x09,
		.value = "rrc c",
		.doc = "The contents of c are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_rrc_c,
	},
	[0x0A] = {
		.opcode = 0x0A,
		.value = "rrc d",
		.doc = "The contents of d are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_rrc_d,
	},
	[0x0B] = {
		.opcode = 0x0B,
		.value = "rrc e",
		.doc = "The contents of e are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_rrc_e,
	},
	[0x0C] = {
		.opcode = 0x0C,
		.value = "rrc h",
		.doc = "The contents of h are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_rrc_h,
	},
	[0x0D] = {
		.opcode = 0x0D,
		.value = "rrc l",
		.doc = "The contents of l are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_rrc_l,
	},
	[0x0E] = {
		.opcode = 0x0E,
		.value = "rrc (hl)",
		.doc = "The contents of (hl) are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.",
		.cycles = 16,
		.size = 2,
		.func = cb_rrc_phl,
	},
	[0x0F] = {
		.opcode = 0x0F,
		.value = "rrc a",
		.doc = "The contents of a are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_rrc_a,
	},
	[0x10] = {
		.opcode = 0x10,
		.value = "rl b",
		.doc = "The contents of b are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_rl_b,
	},
	[0x11] = {
		.opcode = 0x11,
		.value = "rl c",
		.doc = "The contents of c are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_rl_c,
	},
	[0x12] = {
		.opcode = 0x12,
		.value = "rl d",
		.doc = "The contents of d are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_rl_d,
	},
	[0x13] = {
		.opcode = 0x13,
		.value = "rl e",
		.doc = "The contents of e are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_rl_e,
	},
	[0x14] = {
		.opcode = 0x14,
		.value = "rl h",
		.doc = "The contents of h are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_rl_h,
	},
	[0x15] = {
		.opcode = 0x15,
		.value = "rl l",
		.doc = "The contents of l are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_rl_l,
	},
	[0x16] = {
		.opcode = 0x16,
		.value = "rl (hl)",
		.doc = "The contents of (hl) are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.",
		.cycles = 16,
		.size = 2,
		.func = cb_rl_phl,
	},
	[0x17] = {
		.opcode = 0x17,
		.value = "rl a",
		.doc = "The contents of a are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_rl_a,
	},
	[0x18] = {
		.opcode = 0x18,
		.value = "rr b",
		.doc = "The contents of b are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_rr_b,
	},
	[0x19] = {
		.opcode = 0x19,
		.value = "rr c",
		.doc = "The contents of c are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_rr_c,
	},
	[0x1A] = {
		.opcode = 0x1A,
		.value = "rr d",
		.doc = "The contents of d are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_rr_d,
	},
	[0x1B] = {
		.opcode = 0x1B,
		.value = "rr e",
		.doc = "The contents of e are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_rr_e,
	},
	[0x1C] = {
		.opcode = 0x1C,
		.value = "rr h",
		.doc = "The contents of h are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_rr_h,
	},
	[0x1D] = {
		.opcode = 0x1D,
		.value = "rr l",
		.doc = "The contents of l are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_rr_l,
	},
	[0x1E] = {
		.opcode = 0x1E,
		.value = "rr (hl)",
		.doc = "The contents of (hl) are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.",
		.cycles = 16,
		.size = 2,
		.func = cb_rr_phl,
	},
	[0x1F] = {
		.opcode = 0x1F,
		.value = "rr a",
		.doc = "The contents of a are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_rr_a,
	},
	[0x20] = {
		.opcode = 0x20,
		.value = "sla b",
		.doc = "The contents of b are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_sla_b,
	},
	[0x21] = {
		.opcode = 0x21,
		.value = "sla c",
		.doc = "The contents of c are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_sla_c,
	},
	[0x22] = {
		.opcode = 0x22,
		.value = "sla d",
		.doc = "The contents of d are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_sla_d,
	},
	[0x23] = {
		.opcode = 0x23,
		.value = "sla e",
		.doc = "The contents of e are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_sla_e,
	},
	[0x24] = {
		.opcode = 0x24,
		.value = "sla h",
		.doc = "The contents of h are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_sla_h,
	},
	[0x25] = {
		.opcode = 0x25,
		.value = "sla l",
		.doc = "The contents of l are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_sla_l,
	},
	[0x26] = {
		.opcode = 0x26,
		.value = "sla (hl)",
		.doc = "The contents of (hl) are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.",
		.cycles = 16,
		.size = 2,
		.func = cb_sla_phl,
	},
	[0x27] = {
		.opcode = 0x27,
		.value = "sla a",
		.doc = "The contents of a are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.",
		.cycles = 8,
		.size = 2,
		.func = cb_sla_a,
	},
	[0x28] = {
		.opcode = 0x28,
		.value = "sra b",
		.doc = "The contents of b are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.",
		.cycles = 8,
		.size = 2,
		.func = cb_sra_b,
	},
	[0x29] = {
		.opcode = 0x29,
		.value = "sra c",
		.doc = "The contents of c are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.",
		.cycles = 8,
		.size = 2,
		.func = cb_sra_c,
	},
	[0x2A] = {
		.opcode = 0x2A,
		.value = "sra d",
		.doc = "The contents of d are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.",
		.cycles = 8,
		.size = 2,
		.func = cb_sra_d,
	},
	[0x2B] = {
		.opcode = 0x2B,
		.value = "sra e",
		.doc = "The contents of e are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.",
		.cycles = 8,
		.size = 2,
		.func = cb_sra_e,
	},
	[0x2C] = {
		.opcode = 0x2C,
		.value = "sra h",
		.doc = "The contents of h are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.",
		.cycles = 8,
		.size = 2,
		.func = cb_sra_h,
	},
	[0x2D] = {
		.opcode = 0x2D,
		.value = "sra l",
		.doc = "The contents of l are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.",
		.cycles = 8,
		.size = 2,
		.func = cb_sra_l,
	},
	[0x2E] = {
		.opcode = 0x2E,
		.value = "sra (hl)",
		.doc = "The contents of (hl) are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.",
		.cycles = 16,
		.size = 2,
		.func = cb_sra_phl,
	},
	[0x2F] = {
		.opcode = 0x2F,
		.value = "sra a",
		.doc = "The contents of a are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.",
		.cycles = 8,
		.size = 2,
		.func = cb_sra_a,
	},
	[0x30] = {
		.opcode = 0x30,
		.value = "swap b",
		.doc = "Swap upper and lower nibbles of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_swap_b,
	},
	[0x31] = {
		.opcode = 0x31,
		.value = "swap c",
		.doc = "Swap upper and lower nibbles of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_swap_c,
	},
	[0x32] = {
		.opcode = 0x32,
		.value = "swap d",
		.doc = "Swap upper and lower nibbles of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_swap_d,
	},
	[0x33] = {
		.opcode = 0x33,
		.value = "swap e",
		.doc = "Swap upper and lower nibbles of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_swap_e,
	},
	[0x34] = {
		.opcode = 0x34,
		.value = "swap h",
		.doc = "Swap upper and lower nibbles of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_swap_h,
	},
	[0x35] = {
		.opcode = 0x35,
		.value = "swap l",
		.doc = "Swap upper and lower nibbles of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_swap_l,
	},
	[0x36] = {
		.opcode = 0x36,
		.value = "swap (hl)",
		.doc = "Swap upper and lower nibbles of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_swap_phl,
	},
	[0x37] = {
		.opcode = 0x37,
		.value = "swap a",
		.doc = "Swap upper and lower nibbles of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_swap_a,
	},
	[0x38] = {
		.opcode = 0x38,
		.value = "srl b",
		.doc = "The contents of b are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_srl_b,
	},
	[0x39] = {
		.opcode = 0x39,
		.value = "srl c",
		.doc = "The contents of c are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_srl_c,
	},
	[0x3A] = {
		.opcode = 0x3A,
		.value = "srl d",
		.doc = "The contents of d are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_srl_d,
	},
	[0x3B] = {
		.opcode = 0x3B,
		.value = "srl e",
		.doc = "The contents of e are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_srl_e,
	},
	[0x3C] = {
		.opcode = 0x3C,
		.value = "srl h",
		.doc = "The contents of h are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_srl_h,
	},
	[0x3D] = {
		.opcode = 0x3D,
		.value = "srl l",
		.doc = "The contents of l are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_srl_l,
	},
	[0x3E] = {
		.opcode = 0x3E,
		.value = "srl (hl)",
		.doc = "The contents of (hl) are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.",
		.cycles = 16,
		.size = 2,
		.func = cb_srl_phl,
	},
	[0x3F] = {
		.opcode = 0x3F,
		.value = "srl a",
		.doc = "The contents of a are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.",
		.cycles = 8,
		.size = 2,
		.func = cb_srl_a,
	},
	[0x40] = {
		.opcode = 0x40,
		.value = "bit 0,b",
		.doc = "Tests bit 0 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_0_b,
	},
	[0x41] = {
		.opcode = 0x41,
		.value = "bit 0,c",
		.doc = "Tests bit 0 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_0_c,
	},
	[0x42] = {
		.opcode = 0x42,
		.value = "bit 0,d",
		.doc = "Tests bit 0 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_0_d,
	},
	[0x43] = {
		.opcode = 0x43,
		.value = "bit 0,e",
		.doc = "Tests bit 0 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_0_e,
	},
	[0x44] = {
		.opcode = 0x44,
		.value = "bit 0,h",
		.doc = "Tests bit 0 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_0_h,
	},
	[0x45] = {
		.opcode = 0x45,
		.value = "bit 0,l",
		.doc = "Tests bit 0 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_0_l,
	},
	[0x46] = {
		.opcode = 0x46,
		.value = "bit 0,(hl)",
		.doc = "Tests bit 0 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_bit_0_phl,
	},
	[0x47] = {
		.opcode = 0x47,
		.value = "bit 0,a",
		.doc = "Tests bit 0 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_0_a,
	},
	[0x48] = {
		.opcode = 0x48,
		.value = "bit 1,b",
		.doc = "Tests bit 1 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_1_b,
	},
	[0x49] = {
		.opcode = 0x49,
		.value = "bit 1,c",
		.doc = "Tests bit 1 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_1_c,
	},
	[0x4A] = {
		.opcode = 0x4A,
		.value = "bit 1,d",
		.doc = "Tests bit 1 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_1_d,
	},
	[0x4B] = {
		.opcode = 0x4B,
		.value = "bit 1,e",
		.doc = "Tests bit 1 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_1_e,
	},
	[0x4C] = {
		.opcode = 0x4C,
		.value = "bit 1,h",
		.doc = "Tests bit 1 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_1_h,
	},
	[0x4D] = {
		.opcode = 0x4D,
		.value = "bit 1,l",
		.doc = "Tests bit 1 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_1_l,
	},
	[0x4E] = {
		.opcode = 0x4E,
		.value = "bit 1,(hl)",
		.doc = "Tests bit 1 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_bit_1_phl,
	},
	[0x4F] = {
		.opcode = 0x4F,
		.value = "bit 1,a",
		.doc = "Tests bit 1 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_1_a,
	},
	[0x50] = {
		.opcode = 0x50,
		.value = "bit 2,b",
		.doc = "Tests bit 2 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_2_b,
	},
	[0x51] = {
		.opcode = 0x51,
		.value = "bit 2,c",
		.doc = "Tests bit 2 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_2_c,
	},
	[0x52] = {
		.opcode = 0x52,
		.value = "bit 2,d",
		.doc = "Tests bit 2 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_2_d,
	},
	[0x53] = {
		.opcode = 0x53,
		.value = "bit 2,e",
		.doc = "Tests bit 2 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_2_e,
	},
	[0x54] = {
		.opcode = 0x54,
		.value = "bit 2,h",
		.doc = "Tests bit 2 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_2_h,
	},
	[0x55] = {
		.opcode = 0x55,
		.value = "bit 2,l",
		.doc = "Tests bit 2 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_2_l,
	},
	[0x56] = {
		.opcode = 0x56,
		.value = "bit 2,(hl)",
		.doc = "Tests bit 2 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_bit_2_phl,
	},
	[0x57] = {
		.opcode = 0x57,
		.value = "bit 2,a",
		.doc = "Tests bit 2 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_2_a,
	},
	[0x58] = {
		.opcode = 0x58,
		.value = "bit 3,b",
		.doc = "Tests bit 3 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_3_b,
	},
	[0x59] = {
		.opcode = 0x59,
		.value = "bit 3,c",
		.doc = "Tests bit 3 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_3_c,
	},
	[0x5A] = {
		.opcode = 0x5A,
		.value = "bit 3,d",
		.doc = "Tests bit 3 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_3_d,
	},
	[0x5B] = {
		.opcode = 0x5B,
		.value = "bit 3,e",
		.doc = "Tests bit 3 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_3_e,
	},
	[0x5C] = {
		.opcode = 0x5C,
		.value = "bit 3,h",
		.doc = "Tests bit 3 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_3_h,
	},
	[0x5D] = {
		.opcode = 0x5D,
		.value = "bit 3,l",
		.doc = "Tests bit 3 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_3_l,
	},
	[0x5E] = {
		.opcode = 0x5E,
		.value = "bit 3,(hl)",
		.doc = "Tests bit 3 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_bit_3_phl,
	},
	[0x5F] = {
		.opcode = 0x5F,
		.value = "bit 3,a",
		.doc = "Tests bit 3 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_3_a,
	},
	[0x60] = {
		.opcode = 0x60,
		.value = "bit 4,b",
		.doc = "Tests bit 4 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_4_b,
	},
	[0x61] = {
		.opcode = 0x61,
		.value = "bit 4,c",
		.doc = "Tests bit 4 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_4_c,
	},
	[0x62] = {
		.opcode = 0x62,
		.value = "bit 4,d",
		.doc = "Tests bit 4 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_4_d,
	},
	[0x63] = {
		.opcode = 0x63,
		.value = "bit 4,e",
		.doc = "Tests bit 4 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_4_e,
	},
	[0x64] = {
		.opcode = 0x64,
		.value = "bit 4,h",
		.doc = "Tests bit 4 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_4_h,
	},
	[0x65] = {
		.opcode = 0x65,
		.value = "bit 4,l",
		.doc = "Tests bit 4 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_4_l,
	},
	[0x66] = {
		.opcode = 0x66,
		.value = "bit 4,(hl)",
		.doc = "Tests bit 4 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_bit_4_phl,
	},
	[0x67] = {
		.opcode = 0x67,
		.value = "bit 4,a",
		.doc = "Tests bit 4 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_4_a,
	},
	[0x68] = {
		.opcode = 0x68,
		.value = "bit 5,b",
		.doc = "Tests bit 5 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_5_b,
	},
	[0x69] = {
		.opcode = 0x69,
		.value = "bit 5,c",
		.doc = "Tests bit 5 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_5_c,
	},
	[0x6A] = {
		.opcode = 0x6A,
		.value = "bit 5,d",
		.doc = "Tests bit 5 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_5_d,
	},
	[0x6B] = {
		.opcode = 0x6B,
		.value = "bit 5,e",
		.doc = "Tests bit 5 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_5_e,
	},
	[0x6C] = {
		.opcode = 0x6C,
		.value = "bit 5,h",
		.doc = "Tests bit 5 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_5_h,
	},
	[0x6D] = {
		.opcode = 0x6D,
		.value = "bit 5,l",
		.doc = "Tests bit 5 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_5_l,
	},
	[0x6E] = {
		.opcode = 0x6E,
		.value = "bit 5,(hl)",
		.doc = "Tests bit 5 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_bit_5_phl,
	},
	[0x6F] = {
		.opcode = 0x6F,
		.value = "bit 5,a",
		.doc = "Tests bit 5 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_5_a,
	},
	[0x70] = {
		.opcode = 0x70,
		.value = "bit 6,b",
		.doc = "Tests bit 6 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_6_b,
	},
	[0x71] = {
		.opcode = 0x71,
		.value = "bit 6,c",
		.doc = "Tests bit 6 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_6_c,
	},
	[0x72] = {
		.opcode = 0x72,
		.value = "bit 6,d",
		.doc = "Tests bit 6 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_6_d,
	},
	[0x73] = {
		.opcode = 0x73,
		.value = "bit 6,e",
		.doc = "Tests bit 6 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_6_e,
	},
	[0x74] = {
		.opcode = 0x74,
		.value = "bit 6,h",
		.doc = "Tests bit 6 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_6_h,
	},
	[0x75] = {
		.opcode = 0x75,
		.value = "bit 6,l",
		.doc = "Tests bit 6 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_6_l,
	},
	[0x76] = {
		.opcode = 0x76,
		.value = "bit 6,(hl)",
		.doc = "Tests bit 6 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_bit_6_phl,
	},
	[0x77] = {
		.opcode = 0x77,
		.value = "bit 6,a",
		.doc = "Tests bit 6 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_6_a,
	},
	[0x78] = {
		.opcode = 0x78,
		.value = "bit 7,b",
		.doc = "Tests bit 7 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_7_b,
	},
	[0x79] = {
		.opcode = 0x79,
		.value = "bit 7,c",
		.doc = "Tests bit 7 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_7_c,
	},
	[0x7A] = {
		.opcode = 0x7A,
		.value = "bit 7,d",
		.doc = "Tests bit 7 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_7_d,
	},
	[0x7B] = {
		.opcode = 0x7B,
		.value = "bit 7,e",
		.doc = "Tests bit 7 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_7_e,
	},
	[0x7C] = {
		.opcode = 0x7C,
		.value = "bit 7,h",
		.doc = "Tests bit 7 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_7_h,
	},
	[0x7D] = {
		.opcode = 0x7D,
		.value = "bit 7,l",
		.doc = "Tests bit 7 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_7_l,
	},
	[0x7E] = {
		.opcode = 0x7E,
		.value = "bit 7,(hl)",
		.doc = "Tests bit 7 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_bit_7_phl,
	},
	[0x7F] = {
		.opcode = 0x7F,
		.value = "bit 7,a",
		.doc = "Tests bit 7 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_bit_7_a,
	},
	[0x80] = {
		.opcode = 0x80,
		.value = "res 0,b",
		.doc = "Resets bit 0 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_0_b,
	},
	[0x81] = {
		.opcode = 0x81,
		.value = "res 0,c",
		.doc = "Resets bit 0 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_0_c,
	},
	[0x82] = {
		.opcode = 0x82,
		.value = "res 0,d",
		.doc = "Resets bit 0 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_0_d,
	},
	[0x83] = {
		.opcode = 0x83,
		.value = "res 0,e",
		.doc = "Resets bit 0 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_0_e,
	},
	[0x84] = {
		.opcode = 0x84,
		.value = "res 0,h",
		.doc = "Resets bit 0 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_0_h,
	},
	[0x85] = {
		.opcode = 0x85,
		.value = "res 0,l",
		.doc = "Resets bit 0 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_0_l,
	},
	[0x86] = {
		.opcode = 0x86,
		.value = "res 0,(hl)",
		.doc = "Resets bit 0 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_res_0_phl,
	},
	[0x87] = {
		.opcode = 0x87,
		.value = "res 0,a",
		.doc = "Resets bit 0 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_0_a,
	},
	[0x88] = {
		.opcode = 0x88,
		.value = "res 1,b",
		.doc = "Resets bit 1 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_1_b,
	},
	[0x89] = {
		.opcode = 0x89,
		.value = "res 1,c",
		.doc = "Resets bit 1 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_1_c,
	},
	[0x8A] = {
		.opcode = 0x8A,
		.value = "res 1,d",
		.doc = "Resets bit 1 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_1_d,
	},
	[0x8B] = {
		.opcode = 0x8B,
		.value = "res 1,e",
		.doc = "Resets bit 1 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_1_e,
	},
	[0x8C] = {
		.opcode = 0x8C,
		.value = "res 1,h",
		.doc = "Resets bit 1 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_1_h,
	},
	[0x8D] = {
		.opcode = 0x8D,
		.value = "res 1,l",
		.doc = "Resets bit 1 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_1_l,
	},
	[0x8E] = {
		.opcode = 0x8E,
		.value = "res 1,(hl)",
		.doc = "Resets bit 1 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_res_1_phl,
	},
	[0x8F] = {
		.opcode = 0x8F,
		.value = "res 1,a",
		.doc = "Resets bit 1 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_1_a,
	},
	[0x90] = {
		.opcode = 0x90,
		.value = "res 2,b",
		.doc = "Resets bit 2 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_2_b,
	},
	[0x91] = {
		.opcode = 0x91,
		.value = "res 2,c",
		.doc = "Resets bit 2 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_2_c,
	},
	[0x92] = {
		.opcode = 0x92,
		.value = "res 2,d",
		.doc = "Resets bit 2 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_2_d,
	},
	[0x93] = {
		.opcode = 0x93,
		.value = "res 2,e",
		.doc = "Resets bit 2 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_2_e,
	},
	[0x94] = {
		.opcode = 0x94,
		.value = "res 2,h",
		.doc = "Resets bit 2 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_2_h,
	},
	[0x95] = {
		.opcode = 0x95,
		.value = "res 2,l",
		.doc = "Resets bit 2 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_2_l,
	},
	[0x96] = {
		.opcode = 0x96,
		.value = "res 2,(hl)",
		.doc = "Resets bit 2 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_res_2_phl,
	},
	[0x97] = {
		.opcode = 0x97,
		.value = "res 2,a",
		.doc = "Resets bit 2 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_2_a,
	},
	[0x98] = {
		.opcode = 0x98,
		.value = "res 3,b",
		.doc = "Resets bit 3 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_3_b,
	},
	[0x99] = {
		.opcode = 0x99,
		.value = "res 3,c",
		.doc = "Resets bit 3 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_3_c,
	},
	[0x9A] = {
		.opcode = 0x9A,
		.value = "res 3,d",
		.doc = "Resets bit 3 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_3_d,
	},
	[0x9B] = {
		.opcode = 0x9B,
		.value = "res 3,e",
		.doc = "Resets bit 3 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_3_e,
	},
	[0x9C] = {
		.opcode = 0x9C,
		.value = "res 3,h",
		.doc = "Resets bit 3 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_3_h,
	},
	[0x9D] = {
		.opcode = 0x9D,
		.value = "res 3,l",
		.doc = "Resets bit 3 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_3_l,
	},
	[0x9E] = {
		.opcode = 0x9E,
		.value = "res 3,(hl)",
		.doc = "Resets bit 3 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_res_3_phl,
	},
	[0x9F] = {
		.opcode = 0x9F,
		.value = "res 3,a",
		.doc = "Resets bit 3 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_3_a,
	},
	[0xA0] = {
		.opcode = 0xA0,
		.value = "res 4,b",
		.doc = "Resets bit 4 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_4_b,
	},
	[0xA1] = {
		.opcode = 0xA1,
		.value = "res 4,c",
		.doc = "Resets bit 4 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_4_c,
	},
	[0xA2] = {
		.opcode = 0xA2,
		.value = "res 4,d",
		.doc = "Resets bit 4 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_4_d,
	},
	[0xA3] = {
		.opcode = 0xA3,
		.value = "res 4,e",
		.doc = "Resets bit 4 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_4_e,
	},
	[0xA4] = {
		.opcode = 0xA4,
		.value = "res 4,h",
		.doc = "Resets bit 4 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_4_h,
	},
	[0xA5] = {
		.opcode = 0xA5,
		.value = "res 4,l",
		.doc = "Resets bit 4 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_4_l,
	},
	[0xA6] = {
		.opcode = 0xA6,
		.value = "res 4,(hl)",
		.doc = "Resets bit 4 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_res_4_phl,
	},
	[0xA7] = {
		.opcode = 0xA7,
		.value = "res 4,a",
		.doc = "Resets bit 4 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_4_a,
	},
	[0xA8] = {
		.opcode = 0xA8,
		.value = "res 5,b",
		.doc = "Resets bit 5 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_5_b,
	},
	[0xA9] = {
		.opcode = 0xA9,
		.value = "res 5,c",
		.doc = "Resets bit 5 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_5_c,
	},
	[0xAA] = {
		.opcode = 0xAA,
		.value = "res 5,d",
		.doc = "Resets bit 5 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_5_d,
	},
	[0xAB] = {
		.opcode = 0xAB,
		.value = "res 5,e",
		.doc = "Resets bit 5 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_5_e,
	},
	[0xAC] = {
		.opcode = 0xAC,
		.value = "res 5,h",
		.doc = "Resets bit 5 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_5_h,
	},
	[0xAD] = {
		.opcode = 0xAD,
		.value = "res 5,l",
		.doc = "Resets bit 5 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_5_l,
	},
	[0xAE] = {
		.opcode = 0xAE,
		.value = "res 5,(hl)",
		.doc = "Resets bit 5 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_res_5_phl,
	},
	[0xAF] = {
		.opcode = 0xAF,
		.value = "res 5,a",
		.doc = "Resets bit 5 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_5_a,
	},
	[0xB0] = {
		.opcode = 0xB0,
		.value = "res 6,b",
		.doc = "Resets bit 6 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_6_b,
	},
	[0xB1] = {
		.opcode = 0xB1,
		.value = "res 6,c",
		.doc = "Resets bit 6 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_6_c,
	},
	[0xB2] = {
		.opcode = 0xB2,
		.value = "res 6,d",
		.doc = "Resets bit 6 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_6_d,
	},
	[0xB3] = {
		.opcode = 0xB3,
		.value = "res 6,e",
		.doc = "Resets bit 6 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_6_e,
	},
	[0xB4] = {
		.opcode = 0xB4,
		.value = "res 6,h",
		.doc = "Resets bit 6 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_6_h,
	},
	[0xB5] = {
		.opcode = 0xB5,
		.value = "res 6,l",
		.doc = "Resets bit 6 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_6_l,
	},
	[0xB6] = {
		.opcode = 0xB6,
		.value = "res 6,(hl)",
		.doc = "Resets bit 6 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_res_6_phl,
	},
	[0xB7] = {
		.opcode = 0xB7,
		.value = "res 6,a",
		.doc = "Resets bit 6 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_6_a,
	},
	[0xB8] = {
		.opcode = 0xB8,
		.value = "res 7,b",
		.doc = "Resets bit 7 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_7_b,
	},
	[0xB9] = {
		.opcode = 0xB9,
		.value = "res 7,c",
		.doc = "Resets bit 7 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_7_c,
	},
	[0xBA] = {
		.opcode = 0xBA,
		.value = "res 7,d",
		.doc = "Resets bit 7 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_7_d,
	},
	[0xBB] = {
		.opcode = 0xBB,
		.value = "res 7,e",
		.doc = "Resets bit 7 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_7_e,
	},
	[0xBC] = {
		.opcode = 0xBC,
		.value = "res 7,h",
		.doc = "Resets bit 7 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_7_h,
	},
	[0xBD] = {
		.opcode = 0xBD,
		.value = "res 7,l",
		.doc = "Resets bit 7 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_7_l,
	},
	[0xBE] = {
		.opcode = 0xBE,
		.value = "res 7,(hl)",
		.doc = "Resets bit 7 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_res_7_phl,
	},
	[0xBF] = {
		.opcode = 0xBF,
		.value = "res 7,a",
		.doc = "Resets bit 7 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_res_7_a,
	},
	[0xC0] = {
		.opcode = 0xC0,
		.value = "set 0,b",
		.doc = "Sets bit 0 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_0_b,
	},
	[0xC1] = {
		.opcode = 0xC1,
		.value = "set 0,c",
		.doc = "Sets bit 0 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_0_c,
	},
	[0xC2] = {
		.opcode = 0xC2,
		.value = "set 0,d",
		.doc = "Sets bit 0 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_0_d,
	},
	[0xC3] = {
		.opcode = 0xC3,
		.value = "set 0,e",
		.doc = "Sets bit 0 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_0_e,
	},
	[0xC4] = {
		.opcode = 0xC4,
		.value = "set 0,h",
		.doc = "Sets bit 0 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_0_h,
	},
	[0xC5] = {
		.opcode = 0xC5,
		.value = "set 0,l",
		.doc = "Sets bit 0 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_0_l,
	},
	[0xC6] = {
		.opcode = 0xC6,
		.value = "set 0,(hl)",
		.doc = "Sets bit 0 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_set_0_phl,
	},
	[0xC7] = {
		.opcode = 0xC7,
		.value = "set 0,a",
		.doc = "Sets bit 0 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_0_a,
	},
	[0xC8] = {
		.opcode = 0xC8,
		.value = "set 1,b",
		.doc = "Sets bit 1 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_1_b,
	},
	[0xC9] = {
		.opcode = 0xC9,
		.value = "set 1,c",
		.doc = "Sets bit 1 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_1_c,
	},
	[0xCA] = {
		.opcode = 0xCA,
		.value = "set 1,d",
		.doc = "Sets bit 1 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_1_d,
	},
	[0xCB] = {
		.opcode = 0xCB,
		.value = "set 1,e",
		.doc = "Sets bit 1 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_1_e,
	},
	[0xCC] = {
		.opcode = 0xCC,
		.value = "set 1,h",
		.doc = "Sets bit 1 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_1_h,
	},
	[0xCD] = {
		.opcode = 0xCD,
		.value = "set 1,l",
		.doc = "Sets bit 1 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_1_l,
	},
	[0xCE] = {
		.opcode = 0xCE,
		.value = "set 1,(hl)",
		.doc = "Sets bit 1 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_set_1_phl,
	},
	[0xCF] = {
		.opcode = 0xCF,
		.value = "set 1,a",
		.doc = "Sets bit 1 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_1_a,
	},
	[0xD0] = {
		.opcode = 0xD0,
		.value = "set 2,b",
		.doc = "Sets bit 2 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_2_b,
	},
	[0xD1] = {
		.opcode = 0xD1,
		.value = "set 2,c",
		.doc = "Sets bit 2 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_2_c,
	},
	[0xD2] = {
		.opcode = 0xD2,
		.value = "set 2,d",
		.doc = "Sets bit 2 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_2_d,
	},
	[0xD3] = {
		.opcode = 0xD3,
		.value = "set 2,e",
		.doc = "Sets bit 2 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_2_e,
	},
	[0xD4] = {
		.opcode = 0xD4,
		.value = "set 2,h",
		.doc = "Sets bit 2 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_2_h,
	},
	[0xD5] = {
		.opcode = 0xD5,
		.value = "set 2,l",
		.doc = "Sets bit 2 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_2_l,
	},
	[0xD6] = {
		.opcode = 0xD6,
		.value = "set 2,(hl)",
		.doc = "Sets bit 2 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_set_2_phl,
	},
	[0xD7] = {
		.opcode = 0xD7,
		.value = "set 2,a",
		.doc = "Sets bit 2 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_2_a,
	},
	[0xD8] = {
		.opcode = 0xD8,
		.value = "set 3,b",
		.doc = "Sets bit 3 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_3_b,
	},
	[0xD9] = {
		.opcode = 0xD9,
		.value = "set 3,c",
		.doc = "Sets bit 3 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_3_c,
	},
	[0xDA] = {
		.opcode = 0xDA,
		.value = "set 3,d",
		.doc = "Sets bit 3 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_3_d,
	},
	[0xDB] = {
		.opcode = 0xDB,
		.value = "set 3,e",
		.doc = "Sets bit 3 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_3_e,
	},
	[0xDC] = {
		.opcode = 0xDC,
		.value = "set 3,h",
		.doc = "Sets bit 3 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_3_h,
	},
	[0xDD] = {
		.opcode = 0xDD,
		.value = "set 3,l",
		.doc = "Sets bit 3 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_3_l,
	},
	[0xDE] = {
		.opcode = 0xDE,
		.value = "set 3,(hl)",
		.doc = "Sets bit 3 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_set_3_phl,
	},
	[0xDF] = {
		.opcode = 0xDF,
		.value = "set 3,a",
		.doc = "Sets bit 3 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_3_a,
	},
	[0xE0] = {
		.opcode = 0xE0,
		.value = "set 4,b",
		.doc = "Sets bit 4 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_4_b,
	},
	[0xE1] = {
		.opcode = 0xE1,
		.value = "set 4,c",
		.doc = "Sets bit 4 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_4_c,
	},
	[0xE2] = {
		.opcode = 0xE2,
		.value = "set 4,d",
		.doc = "Sets bit 4 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_4_d,
	},
	[0xE3] = {
		.opcode = 0xE3,
		.value = "set 4,e",
		.doc = "Sets bit 4 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_4_e,
	},
	[0xE4] = {
		.opcode = 0xE4,
		.value = "set 4,h",
		.doc = "Sets bit 4 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_4_h,
	},
	[0xE5] = {
		.opcode = 0xE5,
		.value = "set 4,l",
		.doc = "Sets bit 4 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_4_l,
	},
	[0xE6] = {
		.opcode = 0xE6,
		.value = "set 4,(hl)",
		.doc = "Sets bit 4 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_set_4_phl,
	},
	[0xE7] = {
		.opcode = 0xE7,
		.value = "set 4,a",
		.doc = "Sets bit 4 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_4_a,
	},
	[0xE8] = {
		.opcode = 0xE8,
		.value = "set 5,b",
		.doc = "Sets bit 5 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_5_b,
	},
	[0xE9] = {
		.opcode = 0xE9,
		.value = "set 5,c",
		.doc = "Sets bit 5 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_5_c,
	},
	[0xEA] = {
		.opcode = 0xEA,
		.value = "set 5,d",
		.doc = "Sets bit 5 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_5_d,
	},
	[0xEB] = {
		.opcode = 0xEB,
		.value = "set 5,e",
		.doc = "Sets bit 5 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_5_e,
	},
	[0xEC] = {
		.opcode = 0xEC,
		.value = "set 5,h",
		.doc = "Sets bit 5 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_5_h,
	},
	[0xED] = {
		.opcode = 0xED,
		.value = "set 5,l",
		.doc = "Sets bit 5 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_5_l,
	},
	[0xEE] = {
		.opcode = 0xEE,
		.value = "set 5,(hl)",
		.doc = "Sets bit 5 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_set_5_phl,
	},
	[0xEF] = {
		.opcode = 0xEF,
		.value = "set 5,a",
		.doc = "Sets bit 5 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_5_a,
	},
	[0xF0] = {
		.opcode = 0xF0,
		.value = "set 6,b",
		.doc = "Sets bit 6 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_6_b,
	},
	[0xF1] = {
		.opcode = 0xF1,
		.value = "set 6,c",
		.doc = "Sets bit 6 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_6_c,
	},
	[0xF2] = {
		.opcode = 0xF2,
		.value = "set 6,d",
		.doc = "Sets bit 6 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_6_d,
	},
	[0xF3] = {
		.opcode = 0xF3,
		.value = "set 6,e",
		.doc = "Sets bit 6 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_6_e,
	},
	[0xF4] = {
		.opcode = 0xF4,
		.value = "set 6,h",
		.doc = "Sets bit 6 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_6_h,
	},
	[0xF5] = {
		.opcode = 0xF5,
		.value = "set 6,l",
		.doc = "Sets bit 6 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_6_l,
	},
	[0xF6] = {
		.opcode = 0xF6,
		.value = "set 6,(hl)",
		.doc = "Sets bit 6 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_set_6_phl,
	},
	[0xF7] = {
		.opcode = 0xF7,
		.value = "set 6,a",
		.doc = "Sets bit 6 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_6_a,
	},
	[0xF8] = {
		.opcode = 0xF8,
		.value = "set 7,b",
		.doc = "Sets bit 7 of b.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_7_b,
	},
	[0xF9] = {
		.opcode = 0xF9,
		.value = "set 7,c",
		.doc = "Sets bit 7 of c.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_7_c,
	},
	[0xFA] = {
		.opcode = 0xFA,
		.value = "set 7,d",
		.doc = "Sets bit 7 of d.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_7_d,
	},
	[0xFB] = {
		.opcode = 0xFB,
		.value = "set 7,e",
		.doc = "Sets bit 7 of e.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_7_e,
	},
	[0xFC] = {
		.opcode = 0xFC,
		.value = "set 7,h",
		.doc = "Sets bit 7 of h.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_7_h,
	},
	[0xFD] = {
		.opcode = 0xFD,
		.value = "set 7,l",
		.doc = "Sets bit 7 of l.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_7_l,
	},
	[0xFE] = {
		.opcode = 0xFE,
		.value = "set 7,(hl)",
		.doc = "Sets bit 7 of (hl).",
		.cycles = 16,
		.size = 2,
		.func = cb_set_7_phl,
	},
	[0xFF] = {
		.opcode = 0xFF,
		.value = "set 7,a",
		.doc = "Sets bit 7 of a.",
		.cycles = 8,
		.size = 2,
		.func = cb_set_7_a,
	},
};

