/*
 * AUTOGENERATED CODE - jeudi 23 novembre 2017, 17:47:44 (UTC+0100)
 * edit by hand, only between "start of xxx manual code" and
 * "end of xxx manual code" comments.
 */
#include "cpu.h"


/* base instruction set */
/* start of op code function definitions */
/* nop [0x00] : No operation is performed. */
static void nop(struct s_gb *s_gb)
{
	/* start of nop manual code */

	/* end of nop manual code */
}

/* ld bc,** [0x01] : Loads ** into bc. */
static void ld_bc_xx(struct s_gb *s_gb)
{
	/* start of ld_bc_xx manual code */

	/* end of ld_bc_xx manual code */
}

/* ld (bc),a [0x02] : Stores a into the memory location pointed to by bc. */
static void ld_pbc_a(struct s_gb *s_gb)
{
	/* start of ld_pbc_a manual code */

	/* end of ld_pbc_a manual code */
}

/* inc bc [0x03] : Adds one to bc. */
static void inc_bc(struct s_gb *s_gb)
{
	/* start of inc_bc manual code */

	/* end of inc_bc manual code */
}

/* inc b [0x04] : Adds one to b. */
static void inc_b(struct s_gb *s_gb)
{
	/* start of inc_b manual code */

	/* end of inc_b manual code */
}

/* dec b [0x05] : Subtracts one from b. */
static void dec_b(struct s_gb *s_gb)
{
	/* start of dec_b manual code */

	/* end of dec_b manual code */
}

/* ld b,* [0x06] : Loads * into b. */
static void ld_b_x(struct s_gb *s_gb)
{
	/* start of ld_b_x manual code */

	/* end of ld_b_x manual code */
}

/* rlca [0x07] : The contents of a are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. */
static void rlca(struct s_gb *s_gb)
{
	/* start of rlca manual code */

	/* end of rlca manual code */
}

/* ex af,af' [0x08] : Exchanges the 16-bit contents of af and af'. */
static void ex_af_afx(struct s_gb *s_gb)
{
	/* start of ex_af_afx manual code */

	/* end of ex_af_afx manual code */
}

/* add hl,bc [0x09] : The value of bc is added to hl. */
static void add_hl_bc(struct s_gb *s_gb)
{
	/* start of add_hl_bc manual code */

	/* end of add_hl_bc manual code */
}

/* ld a,(bc) [0x0A] : Loads the value pointed to by bc into a. */
static void ld_a_pbc(struct s_gb *s_gb)
{
	/* start of ld_a_pbc manual code */

	/* end of ld_a_pbc manual code */
}

/* dec bc [0x0B] : Subtracts one from bc. */
static void dec_bc(struct s_gb *s_gb)
{
	/* start of dec_bc manual code */

	/* end of dec_bc manual code */
}

/* inc c [0x0C] : Adds one to c. */
static void inc_c(struct s_gb *s_gb)
{
	/* start of inc_c manual code */

	/* end of inc_c manual code */
}

/* dec c [0x0D] : Subtracts one from c. */
static void dec_c(struct s_gb *s_gb)
{
	/* start of dec_c manual code */

	/* end of dec_c manual code */
}

/* ld c,* [0x0E] : Loads * into c. */
static void ld_c_x(struct s_gb *s_gb)
{
	/* start of ld_c_x manual code */

	/* end of ld_c_x manual code */
}

/* rrca [0x0F] : The contents of a are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. */
static void rrca(struct s_gb *s_gb)
{
	/* start of rrca manual code */

	/* end of rrca manual code */
}

/* djnz * [0x10] : The b register is decremented, and if not zero, the signed value * is added to pc. The jump is measured from the start of the instruction opcode. */
static void djnz_x(struct s_gb *s_gb)
{
	/* start of djnz_x manual code */

	/* end of djnz_x manual code */
}

/* ld de,** [0x11] : Loads ** into de. */
static void ld_de_xx(struct s_gb *s_gb)
{
	/* start of ld_de_xx manual code */

	/* end of ld_de_xx manual code */
}

/* ld (de),a [0x12] : Stores a into the memory location pointed to by de. */
static void ld_pde_a(struct s_gb *s_gb)
{
	/* start of ld_pde_a manual code */

	/* end of ld_pde_a manual code */
}

/* inc de [0x13] : Adds one to de. */
static void inc_de(struct s_gb *s_gb)
{
	/* start of inc_de manual code */

	/* end of inc_de manual code */
}

/* inc d [0x14] : Adds one to d. */
static void inc_d(struct s_gb *s_gb)
{
	/* start of inc_d manual code */

	/* end of inc_d manual code */
}

/* dec d [0x15] : Subtracts one from d. */
static void dec_d(struct s_gb *s_gb)
{
	/* start of dec_d manual code */

	/* end of dec_d manual code */
}

/* ld d,* [0x16] : Loads * into d. */
static void ld_d_x(struct s_gb *s_gb)
{
	/* start of ld_d_x manual code */

	/* end of ld_d_x manual code */
}

/* rla [0x17] : The contents of a are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. */
static void rla(struct s_gb *s_gb)
{
	/* start of rla manual code */

	/* end of rla manual code */
}

/* jr * [0x18] : The signed value * is added to pc. The jump is measured from the start of the instruction opcode. */
static void jr_x(struct s_gb *s_gb)
{
	/* start of jr_x manual code */

	/* end of jr_x manual code */
}

/* add hl,de [0x19] : The value of de is added to hl. */
static void add_hl_de(struct s_gb *s_gb)
{
	/* start of add_hl_de manual code */

	/* end of add_hl_de manual code */
}

/* ld a,(de) [0x1A] : Loads the value pointed to by de into a. */
static void ld_a_pde(struct s_gb *s_gb)
{
	/* start of ld_a_pde manual code */

	/* end of ld_a_pde manual code */
}

/* dec de [0x1B] : Subtracts one from de. */
static void dec_de(struct s_gb *s_gb)
{
	/* start of dec_de manual code */

	/* end of dec_de manual code */
}

/* inc e [0x1C] : Adds one to e. */
static void inc_e(struct s_gb *s_gb)
{
	/* start of inc_e manual code */

	/* end of inc_e manual code */
}

/* dec e [0x1D] : Subtracts one from e. */
static void dec_e(struct s_gb *s_gb)
{
	/* start of dec_e manual code */

	/* end of dec_e manual code */
}

/* ld e,* [0x1E] : Loads * into e. */
static void ld_e_x(struct s_gb *s_gb)
{
	/* start of ld_e_x manual code */

	/* end of ld_e_x manual code */
}

/* rra [0x1F] : The contents of a are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. */
static void rra(struct s_gb *s_gb)
{
	/* start of rra manual code */

	/* end of rra manual code */
}

/* jr nz,* [0x20] : If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode. */
static void jr_nz_x(struct s_gb *s_gb)
{
	/* start of jr_nz_x manual code */

	/* end of jr_nz_x manual code */
}

/* ld hl,** [0x21] : Loads ** into hl. */
static void ld_hl_xx(struct s_gb *s_gb)
{
	/* start of ld_hl_xx manual code */

	/* end of ld_hl_xx manual code */
}

/* ld (**),hl [0x22] : Stores hl into the memory location pointed to by **. */
static void ld_pxx_hl(struct s_gb *s_gb)
{
	/* start of ld_pxx_hl manual code */

	/* end of ld_pxx_hl manual code */
}

/* inc hl [0x23] : Adds one to hl. */
static void inc_hl(struct s_gb *s_gb)
{
	/* start of inc_hl manual code */

	/* end of inc_hl manual code */
}

/* inc h [0x24] : Adds one to h. */
static void inc_h(struct s_gb *s_gb)
{
	/* start of inc_h manual code */

	/* end of inc_h manual code */
}

/* dec h [0x25] : Subtracts one from h. */
static void dec_h(struct s_gb *s_gb)
{
	/* start of dec_h manual code */

	/* end of dec_h manual code */
}

/* ld h,* [0x26] : Loads * into h. */
static void ld_h_x(struct s_gb *s_gb)
{
	/* start of ld_h_x manual code */

	/* end of ld_h_x manual code */
}

/* daa [0x27] : Adjusts a for BCD addition and subtraction operations. */
static void daa(struct s_gb *s_gb)
{
	/* start of daa manual code */

	/* end of daa manual code */
}

/* jr z,* [0x28] : If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode. */
static void jr_z_x(struct s_gb *s_gb)
{
	/* start of jr_z_x manual code */

	/* end of jr_z_x manual code */
}

/* add hl,hl [0x29] : The value of hl is added to hl. */
static void add_hl_hl(struct s_gb *s_gb)
{
	/* start of add_hl_hl manual code */

	/* end of add_hl_hl manual code */
}

/* ld hl,(**) [0x2A] : Loads the value pointed to by ** into hl. */
static void ld_hl_pxx(struct s_gb *s_gb)
{
	/* start of ld_hl_pxx manual code */

	/* end of ld_hl_pxx manual code */
}

/* dec hl [0x2B] : Subtracts one from hl. */
static void dec_hl(struct s_gb *s_gb)
{
	/* start of dec_hl manual code */

	/* end of dec_hl manual code */
}

/* inc l [0x2C] : Adds one to l. */
static void inc_l(struct s_gb *s_gb)
{
	/* start of inc_l manual code */

	/* end of inc_l manual code */
}

/* dec l [0x2D] : Subtracts one from l. */
static void dec_l(struct s_gb *s_gb)
{
	/* start of dec_l manual code */

	/* end of dec_l manual code */
}

/* ld l,* [0x2E] : Loads * into l. */
static void ld_l_x(struct s_gb *s_gb)
{
	/* start of ld_l_x manual code */

	/* end of ld_l_x manual code */
}

/* cpl [0x2F] : The contents of a are inverted (one's complement). */
static void cpl(struct s_gb *s_gb)
{
	/* start of cpl manual code */

	/* end of cpl manual code */
}

/* jr nc,* [0x30] : If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode. */
static void jr_nc_x(struct s_gb *s_gb)
{
	/* start of jr_nc_x manual code */

	/* end of jr_nc_x manual code */
}

/* ld sp,** [0x31] : Loads ** into sp. */
static void ld_sp_xx(struct s_gb *s_gb)
{
	/* start of ld_sp_xx manual code */

	/* end of ld_sp_xx manual code */
}

/* ld (**),a [0x32] : Stores a into the memory location pointed to by **. */
static void ld_pxx_a(struct s_gb *s_gb)
{
	/* start of ld_pxx_a manual code */

	/* end of ld_pxx_a manual code */
}

/* inc sp [0x33] : Adds one to sp. */
static void inc_sp(struct s_gb *s_gb)
{
	/* start of inc_sp manual code */

	/* end of inc_sp manual code */
}

/* inc (hl) [0x34] : Adds one to (hl). */
static void inc_phl(struct s_gb *s_gb)
{
	/* start of inc_phl manual code */

	/* end of inc_phl manual code */
}

/* dec (hl) [0x35] : Subtracts one from (hl). */
static void dec_phl(struct s_gb *s_gb)
{
	/* start of dec_phl manual code */

	/* end of dec_phl manual code */
}

/* ld (hl),* [0x36] : Loads * into (hl). */
static void ld_phl_x(struct s_gb *s_gb)
{
	/* start of ld_phl_x manual code */

	/* end of ld_phl_x manual code */
}

/* scf [0x37] : Sets the carry flag. */
static void scf(struct s_gb *s_gb)
{
	/* start of scf manual code */

	/* end of scf manual code */
}

/* jr c,* [0x38] : If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode. */
static void jr_c_x(struct s_gb *s_gb)
{
	/* start of jr_c_x manual code */

	/* end of jr_c_x manual code */
}

/* add hl,sp [0x39] : The value of hl is added to hl. */
static void add_hl_sp(struct s_gb *s_gb)
{
	/* start of add_hl_sp manual code */

	/* end of add_hl_sp manual code */
}

/* ld a,(**) [0x3A] : Loads the value pointed to by ** into a. */
static void ld_a_pxx(struct s_gb *s_gb)
{
	/* start of ld_a_pxx manual code */

	/* end of ld_a_pxx manual code */
}

/* dec sp [0x3B] : Subtracts one from sp. */
static void dec_sp(struct s_gb *s_gb)
{
	/* start of dec_sp manual code */

	/* end of dec_sp manual code */
}

/* inc a [0x3C] : Adds one to a. */
static void inc_a(struct s_gb *s_gb)
{
	/* start of inc_a manual code */

	/* end of inc_a manual code */
}

/* dec a [0x3D] : Subtracts one from a. */
static void dec_a(struct s_gb *s_gb)
{
	/* start of dec_a manual code */

	/* end of dec_a manual code */
}

/* ld a,* [0x3E] : Loads * into a. */
static void ld_a_x(struct s_gb *s_gb)
{
	/* start of ld_a_x manual code */

	/* end of ld_a_x manual code */
}

/* ccf [0x3F] : Inverts the carry flag. */
static void ccf(struct s_gb *s_gb)
{
	/* start of ccf manual code */

	/* end of ccf manual code */
}

/* ld b,b [0x40] : The contents of b are loaded into b. */
static void ld_b_b(struct s_gb *s_gb)
{
	/* start of ld_b_b manual code */

	/* end of ld_b_b manual code */
}

/* ld b,c [0x41] : The contents of c are loaded into b. */
static void ld_b_c(struct s_gb *s_gb)
{
	/* start of ld_b_c manual code */

	/* end of ld_b_c manual code */
}

/* ld b,d [0x42] : The contents of d are loaded into b. */
static void ld_b_d(struct s_gb *s_gb)
{
	/* start of ld_b_d manual code */

	/* end of ld_b_d manual code */
}

/* ld b,e [0x43] : The contents of e are loaded into b. */
static void ld_b_e(struct s_gb *s_gb)
{
	/* start of ld_b_e manual code */

	/* end of ld_b_e manual code */
}

/* ld b,h [0x44] : The contents of h are loaded into b. */
static void ld_b_h(struct s_gb *s_gb)
{
	/* start of ld_b_h manual code */

	/* end of ld_b_h manual code */
}

/* ld b,l [0x45] : The contents of l are loaded into b. */
static void ld_b_l(struct s_gb *s_gb)
{
	/* start of ld_b_l manual code */

	/* end of ld_b_l manual code */
}

/* ld b,(hl) [0x46] : The contents of (hl) are loaded into b. */
static void ld_b_phl(struct s_gb *s_gb)
{
	/* start of ld_b_phl manual code */

	/* end of ld_b_phl manual code */
}

/* ld b,a [0x47] : The contents of a are loaded into b. */
static void ld_b_a(struct s_gb *s_gb)
{
	/* start of ld_b_a manual code */

	/* end of ld_b_a manual code */
}

/* ld c,b [0x48] : The contents of b are loaded into c. */
static void ld_c_b(struct s_gb *s_gb)
{
	/* start of ld_c_b manual code */

	/* end of ld_c_b manual code */
}

/* ld c,c [0x49] : The contents of c are loaded into c. */
static void ld_c_c(struct s_gb *s_gb)
{
	/* start of ld_c_c manual code */

	/* end of ld_c_c manual code */
}

/* ld c,d [0x4A] : The contents of d are loaded into c. */
static void ld_c_d(struct s_gb *s_gb)
{
	/* start of ld_c_d manual code */

	/* end of ld_c_d manual code */
}

/* ld c,e [0x4B] : The contents of e are loaded into c. */
static void ld_c_e(struct s_gb *s_gb)
{
	/* start of ld_c_e manual code */

	/* end of ld_c_e manual code */
}

/* ld c,h [0x4C] : The contents of h are loaded into c. */
static void ld_c_h(struct s_gb *s_gb)
{
	/* start of ld_c_h manual code */

	/* end of ld_c_h manual code */
}

/* ld c,l [0x4D] : The contents of l are loaded into c. */
static void ld_c_l(struct s_gb *s_gb)
{
	/* start of ld_c_l manual code */

	/* end of ld_c_l manual code */
}

/* ld c,(hl) [0x4E] : The contents of (hl) are loaded into c. */
static void ld_c_phl(struct s_gb *s_gb)
{
	/* start of ld_c_phl manual code */

	/* end of ld_c_phl manual code */
}

/* ld c,a [0x4F] : The contents of a are loaded into c. */
static void ld_c_a(struct s_gb *s_gb)
{
	/* start of ld_c_a manual code */

	/* end of ld_c_a manual code */
}

/* ld d,b [0x50] : The contents of b are loaded into d. */
static void ld_d_b(struct s_gb *s_gb)
{
	/* start of ld_d_b manual code */

	/* end of ld_d_b manual code */
}

/* ld d,c [0x51] : The contents of c are loaded into d. */
static void ld_d_c(struct s_gb *s_gb)
{
	/* start of ld_d_c manual code */

	/* end of ld_d_c manual code */
}

/* ld d,d [0x52] : The contents of d are loaded into d. */
static void ld_d_d(struct s_gb *s_gb)
{
	/* start of ld_d_d manual code */

	/* end of ld_d_d manual code */
}

/* ld d,e [0x53] : The contents of e are loaded into d. */
static void ld_d_e(struct s_gb *s_gb)
{
	/* start of ld_d_e manual code */

	/* end of ld_d_e manual code */
}

/* ld d,h [0x54] : The contents of h are loaded into d. */
static void ld_d_h(struct s_gb *s_gb)
{
	/* start of ld_d_h manual code */

	/* end of ld_d_h manual code */
}

/* ld d,l [0x55] : The contents of l are loaded into d. */
static void ld_d_l(struct s_gb *s_gb)
{
	/* start of ld_d_l manual code */

	/* end of ld_d_l manual code */
}

/* ld d,(hl) [0x56] : The contents of (hl) are loaded into d. */
static void ld_d_phl(struct s_gb *s_gb)
{
	/* start of ld_d_phl manual code */

	/* end of ld_d_phl manual code */
}

/* ld d,a [0x57] : The contents of a are loaded into d. */
static void ld_d_a(struct s_gb *s_gb)
{
	/* start of ld_d_a manual code */

	/* end of ld_d_a manual code */
}

/* ld e,b [0x58] : The contents of b are loaded into e. */
static void ld_e_b(struct s_gb *s_gb)
{
	/* start of ld_e_b manual code */

	/* end of ld_e_b manual code */
}

/* ld e,c [0x59] : The contents of c are loaded into e. */
static void ld_e_c(struct s_gb *s_gb)
{
	/* start of ld_e_c manual code */

	/* end of ld_e_c manual code */
}

/* ld e,d [0x5A] : The contents of d are loaded into e. */
static void ld_e_d(struct s_gb *s_gb)
{
	/* start of ld_e_d manual code */

	/* end of ld_e_d manual code */
}

/* ld e,e [0x5B] : The contents of e are loaded into e. */
static void ld_e_e(struct s_gb *s_gb)
{
	/* start of ld_e_e manual code */

	/* end of ld_e_e manual code */
}

/* ld e,h [0x5C] : The contents of h are loaded into e. */
static void ld_e_h(struct s_gb *s_gb)
{
	/* start of ld_e_h manual code */

	/* end of ld_e_h manual code */
}

/* ld e,l [0x5D] : The contents of l are loaded into e. */
static void ld_e_l(struct s_gb *s_gb)
{
	/* start of ld_e_l manual code */

	/* end of ld_e_l manual code */
}

/* ld e,(hl) [0x5E] : The contents of (hl) are loaded into e. */
static void ld_e_phl(struct s_gb *s_gb)
{
	/* start of ld_e_phl manual code */

	/* end of ld_e_phl manual code */
}

/* ld e,a [0x5F] : The contents of a are loaded into e. */
static void ld_e_a(struct s_gb *s_gb)
{
	/* start of ld_e_a manual code */

	/* end of ld_e_a manual code */
}

/* ld h,b [0x60] : The contents of b are loaded into h. */
static void ld_h_b(struct s_gb *s_gb)
{
	/* start of ld_h_b manual code */

	/* end of ld_h_b manual code */
}

/* ld h,c [0x61] : The contents of c are loaded into h. */
static void ld_h_c(struct s_gb *s_gb)
{
	/* start of ld_h_c manual code */

	/* end of ld_h_c manual code */
}

/* ld h,d [0x62] : The contents of d are loaded into h. */
static void ld_h_d(struct s_gb *s_gb)
{
	/* start of ld_h_d manual code */

	/* end of ld_h_d manual code */
}

/* ld h,e [0x63] : The contents of e are loaded into h. */
static void ld_h_e(struct s_gb *s_gb)
{
	/* start of ld_h_e manual code */

	/* end of ld_h_e manual code */
}

/* ld h,h [0x64] : The contents of h are loaded into h. */
static void ld_h_h(struct s_gb *s_gb)
{
	/* start of ld_h_h manual code */

	/* end of ld_h_h manual code */
}

/* ld h,l [0x65] : The contents of l are loaded into h. */
static void ld_h_l(struct s_gb *s_gb)
{
	/* start of ld_h_l manual code */

	/* end of ld_h_l manual code */
}

/* ld h,(hl) [0x66] : The contents of (hl) are loaded into h. */
static void ld_h_phl(struct s_gb *s_gb)
{
	/* start of ld_h_phl manual code */

	/* end of ld_h_phl manual code */
}

/* ld h,a [0x67] : The contents of a are loaded into h. */
static void ld_h_a(struct s_gb *s_gb)
{
	/* start of ld_h_a manual code */

	/* end of ld_h_a manual code */
}

/* ld l,b [0x68] : The contents of b are loaded into l. */
static void ld_l_b(struct s_gb *s_gb)
{
	/* start of ld_l_b manual code */

	/* end of ld_l_b manual code */
}

/* ld l,c [0x69] : The contents of c are loaded into l. */
static void ld_l_c(struct s_gb *s_gb)
{
	/* start of ld_l_c manual code */

	/* end of ld_l_c manual code */
}

/* ld l,d [0x6A] : The contents of d are loaded into l. */
static void ld_l_d(struct s_gb *s_gb)
{
	/* start of ld_l_d manual code */

	/* end of ld_l_d manual code */
}

/* ld l,e [0x6B] : The contents of e are loaded into l. */
static void ld_l_e(struct s_gb *s_gb)
{
	/* start of ld_l_e manual code */

	/* end of ld_l_e manual code */
}

/* ld l,h [0x6C] : The contents of h are loaded into l. */
static void ld_l_h(struct s_gb *s_gb)
{
	/* start of ld_l_h manual code */

	/* end of ld_l_h manual code */
}

/* ld l,l [0x6D] : The contents of l are loaded into l. */
static void ld_l_l(struct s_gb *s_gb)
{
	/* start of ld_l_l manual code */

	/* end of ld_l_l manual code */
}

/* ld l,(hl) [0x6E] : The contents of (hl) are loaded into l. */
static void ld_l_phl(struct s_gb *s_gb)
{
	/* start of ld_l_phl manual code */

	/* end of ld_l_phl manual code */
}

/* ld l,a [0x6F] : The contents of a are loaded into l. */
static void ld_l_a(struct s_gb *s_gb)
{
	/* start of ld_l_a manual code */

	/* end of ld_l_a manual code */
}

/* ld (hl),b [0x70] : The contents of b are loaded into (hl). */
static void ld_phl_b(struct s_gb *s_gb)
{
	/* start of ld_phl_b manual code */

	/* end of ld_phl_b manual code */
}

/* ld (hl),c [0x71] : The contents of c are loaded into (hl). */
static void ld_phl_c(struct s_gb *s_gb)
{
	/* start of ld_phl_c manual code */

	/* end of ld_phl_c manual code */
}

/* ld (hl),d [0x72] : The contents of d are loaded into (hl). */
static void ld_phl_d(struct s_gb *s_gb)
{
	/* start of ld_phl_d manual code */

	/* end of ld_phl_d manual code */
}

/* ld (hl),e [0x73] : The contents of e are loaded into (hl). */
static void ld_phl_e(struct s_gb *s_gb)
{
	/* start of ld_phl_e manual code */

	/* end of ld_phl_e manual code */
}

/* ld (hl),h [0x74] : The contents of h are loaded into (hl). */
static void ld_phl_h(struct s_gb *s_gb)
{
	/* start of ld_phl_h manual code */

	/* end of ld_phl_h manual code */
}

/* ld (hl),l [0x75] : The contents of l are loaded into (hl). */
static void ld_phl_l(struct s_gb *s_gb)
{
	/* start of ld_phl_l manual code */

	/* end of ld_phl_l manual code */
}

/* halt [0x76] : Suspends CPU operation until an interrupt or reset occurs. */
static void halt(struct s_gb *s_gb)
{
	/* start of halt manual code */

	/* end of halt manual code */
}

/* ld (hl),a [0x77] : The contents of a are loaded into (hl). */
static void ld_phl_a(struct s_gb *s_gb)
{
	/* start of ld_phl_a manual code */

	/* end of ld_phl_a manual code */
}

/* ld a,b [0x78] : The contents of b are loaded into a. */
static void ld_a_b(struct s_gb *s_gb)
{
	/* start of ld_a_b manual code */

	/* end of ld_a_b manual code */
}

/* ld a,c [0x79] : The contents of c are loaded into a. */
static void ld_a_c(struct s_gb *s_gb)
{
	/* start of ld_a_c manual code */

	/* end of ld_a_c manual code */
}

/* ld a,d [0x7A] : The contents of d are loaded into a. */
static void ld_a_d(struct s_gb *s_gb)
{
	/* start of ld_a_d manual code */

	/* end of ld_a_d manual code */
}

/* ld a,e [0x7B] : The contents of e are loaded into a. */
static void ld_a_e(struct s_gb *s_gb)
{
	/* start of ld_a_e manual code */

	/* end of ld_a_e manual code */
}

/* ld a,h [0x7C] : The contents of h are loaded into a. */
static void ld_a_h(struct s_gb *s_gb)
{
	/* start of ld_a_h manual code */

	/* end of ld_a_h manual code */
}

/* ld a,l [0x7D] : The contents of l are loaded into a. */
static void ld_a_l(struct s_gb *s_gb)
{
	/* start of ld_a_l manual code */

	/* end of ld_a_l manual code */
}

/* ld a,(hl) [0x7E] : The contents of (hl) are loaded into a. */
static void ld_a_phl(struct s_gb *s_gb)
{
	/* start of ld_a_phl manual code */

	/* end of ld_a_phl manual code */
}

/* ld a,a [0x7F] : The contents of a are loaded into a. */
static void ld_a_a(struct s_gb *s_gb)
{
	/* start of ld_a_a manual code */

	/* end of ld_a_a manual code */
}

/* add a,b [0x80] : Adds b to a. */
static void add_a_b(struct s_gb *s_gb)
{
	/* start of add_a_b manual code */

	/* end of add_a_b manual code */
}

/* add a,c [0x81] : Adds c to a. */
static void add_a_c(struct s_gb *s_gb)
{
	/* start of add_a_c manual code */

	/* end of add_a_c manual code */
}

/* add a,d [0x82] : Adds d to a. */
static void add_a_d(struct s_gb *s_gb)
{
	/* start of add_a_d manual code */

	/* end of add_a_d manual code */
}

/* add a,e [0x83] : Adds e to a. */
static void add_a_e(struct s_gb *s_gb)
{
	/* start of add_a_e manual code */

	/* end of add_a_e manual code */
}

/* add a,h [0x84] : Adds h to a. */
static void add_a_h(struct s_gb *s_gb)
{
	/* start of add_a_h manual code */

	/* end of add_a_h manual code */
}

/* add a,l [0x85] : Adds l to a. */
static void add_a_l(struct s_gb *s_gb)
{
	/* start of add_a_l manual code */

	/* end of add_a_l manual code */
}

/* add a,(hl) [0x86] : Adds (hl) to a. */
static void add_a_phl(struct s_gb *s_gb)
{
	/* start of add_a_phl manual code */

	/* end of add_a_phl manual code */
}

/* add a,a [0x87] : Adds a to a. */
static void add_a_a(struct s_gb *s_gb)
{
	/* start of add_a_a manual code */

	/* end of add_a_a manual code */
}

/* adc a,b [0x88] : Adds b and the carry flag to a. */
static void adc_a_b(struct s_gb *s_gb)
{
	/* start of adc_a_b manual code */

	/* end of adc_a_b manual code */
}

/* adc a,c [0x89] : Adds c and the carry flag to a. */
static void adc_a_c(struct s_gb *s_gb)
{
	/* start of adc_a_c manual code */

	/* end of adc_a_c manual code */
}

/* adc a,d [0x8A] : Adds d and the carry flag to a. */
static void adc_a_d(struct s_gb *s_gb)
{
	/* start of adc_a_d manual code */

	/* end of adc_a_d manual code */
}

/* adc a,e [0x8B] : Adds e and the carry flag to a. */
static void adc_a_e(struct s_gb *s_gb)
{
	/* start of adc_a_e manual code */

	/* end of adc_a_e manual code */
}

/* adc a,h [0x8C] : Adds h and the carry flag to a. */
static void adc_a_h(struct s_gb *s_gb)
{
	/* start of adc_a_h manual code */

	/* end of adc_a_h manual code */
}

/* adc a,l [0x8D] : Adds l and the carry flag to a. */
static void adc_a_l(struct s_gb *s_gb)
{
	/* start of adc_a_l manual code */

	/* end of adc_a_l manual code */
}

/* adc a,(hl) [0x8E] : Adds (hl) and the carry flag to a. */
static void adc_a_phl(struct s_gb *s_gb)
{
	/* start of adc_a_phl manual code */

	/* end of adc_a_phl manual code */
}

/* adc a,a [0x8F] : Adds a and the carry flag to a. */
static void adc_a_a(struct s_gb *s_gb)
{
	/* start of adc_a_a manual code */

	/* end of adc_a_a manual code */
}

/* sub b [0x90] : Subtracts b from a. */
static void sub_b(struct s_gb *s_gb)
{
	/* start of sub_b manual code */

	/* end of sub_b manual code */
}

/* sub c [0x91] : Subtracts c from a. */
static void sub_c(struct s_gb *s_gb)
{
	/* start of sub_c manual code */

	/* end of sub_c manual code */
}

/* sub d [0x92] : Subtracts d from a. */
static void sub_d(struct s_gb *s_gb)
{
	/* start of sub_d manual code */

	/* end of sub_d manual code */
}

/* sub e [0x93] : Subtracts e from a. */
static void sub_e(struct s_gb *s_gb)
{
	/* start of sub_e manual code */

	/* end of sub_e manual code */
}

/* sub h [0x94] : Subtracts h from a. */
static void sub_h(struct s_gb *s_gb)
{
	/* start of sub_h manual code */

	/* end of sub_h manual code */
}

/* sub l [0x95] : Subtracts l from a. */
static void sub_l(struct s_gb *s_gb)
{
	/* start of sub_l manual code */

	/* end of sub_l manual code */
}

/* sub (hl) [0x96] : Subtracts (hl) from a. */
static void sub_phl(struct s_gb *s_gb)
{
	/* start of sub_phl manual code */

	/* end of sub_phl manual code */
}

/* sub a [0x97] : Subtracts a from a. */
static void sub_a(struct s_gb *s_gb)
{
	/* start of sub_a manual code */

	/* end of sub_a manual code */
}

/* sbc a,b [0x98] : Subtracts b and the carry flag from a. */
static void sbc_a_b(struct s_gb *s_gb)
{
	/* start of sbc_a_b manual code */

	/* end of sbc_a_b manual code */
}

/* sbc a,c [0x99] : Subtracts c and the carry flag from a. */
static void sbc_a_c(struct s_gb *s_gb)
{
	/* start of sbc_a_c manual code */

	/* end of sbc_a_c manual code */
}

/* sbc a,d [0x9A] : Subtracts d and the carry flag from a. */
static void sbc_a_d(struct s_gb *s_gb)
{
	/* start of sbc_a_d manual code */

	/* end of sbc_a_d manual code */
}

/* sbc a,e [0x9B] : Subtracts e and the carry flag from a. */
static void sbc_a_e(struct s_gb *s_gb)
{
	/* start of sbc_a_e manual code */

	/* end of sbc_a_e manual code */
}

/* sbc a,h [0x9C] : Subtracts h and the carry flag from a. */
static void sbc_a_h(struct s_gb *s_gb)
{
	/* start of sbc_a_h manual code */

	/* end of sbc_a_h manual code */
}

/* sbc a,l [0x9D] : Subtracts l and the carry flag from a. */
static void sbc_a_l(struct s_gb *s_gb)
{
	/* start of sbc_a_l manual code */

	/* end of sbc_a_l manual code */
}

/* sbc a,(hl) [0x9E] : Subtracts (hl) and the carry flag from a. */
static void sbc_a_phl(struct s_gb *s_gb)
{
	/* start of sbc_a_phl manual code */

	/* end of sbc_a_phl manual code */
}

/* sbc a,a [0x9F] : Subtracts a and the carry flag from a. */
static void sbc_a_a(struct s_gb *s_gb)
{
	/* start of sbc_a_a manual code */

	/* end of sbc_a_a manual code */
}

/* and b [0xA0] : Bitwise AND on a with b. */
static void and_b(struct s_gb *s_gb)
{
	/* start of and_b manual code */

	/* end of and_b manual code */
}

/* and c [0xA1] : Bitwise AND on a with c. */
static void and_c(struct s_gb *s_gb)
{
	/* start of and_c manual code */

	/* end of and_c manual code */
}

/* and d [0xA2] : Bitwise AND on a with d. */
static void and_d(struct s_gb *s_gb)
{
	/* start of and_d manual code */

	/* end of and_d manual code */
}

/* and e [0xA3] : Bitwise AND on a with e. */
static void and_e(struct s_gb *s_gb)
{
	/* start of and_e manual code */

	/* end of and_e manual code */
}

/* and h [0xA4] : Bitwise AND on a with h. */
static void and_h(struct s_gb *s_gb)
{
	/* start of and_h manual code */

	/* end of and_h manual code */
}

/* and l [0xA5] : Bitwise AND on a with l. */
static void and_l(struct s_gb *s_gb)
{
	/* start of and_l manual code */

	/* end of and_l manual code */
}

/* and (hl) [0xA6] : Bitwise AND on a with (hl). */
static void and_phl(struct s_gb *s_gb)
{
	/* start of and_phl manual code */

	/* end of and_phl manual code */
}

/* and a [0xA7] : Bitwise AND on a with a. */
static void and_a(struct s_gb *s_gb)
{
	/* start of and_a manual code */

	/* end of and_a manual code */
}

/* xor b [0xA8] : Bitwise XOR on a with b. */
static void xor_b(struct s_gb *s_gb)
{
	/* start of xor_b manual code */

	/* end of xor_b manual code */
}

/* xor c [0xA9] : Bitwise XOR on a with c. */
static void xor_c(struct s_gb *s_gb)
{
	/* start of xor_c manual code */

	/* end of xor_c manual code */
}

/* xor d [0xAA] : Bitwise XOR on a with d. */
static void xor_d(struct s_gb *s_gb)
{
	/* start of xor_d manual code */

	/* end of xor_d manual code */
}

/* xor e [0xAB] : Bitwise XOR on a with e. */
static void xor_e(struct s_gb *s_gb)
{
	/* start of xor_e manual code */

	/* end of xor_e manual code */
}

/* xor h [0xAC] : Bitwise XOR on a with h. */
static void xor_h(struct s_gb *s_gb)
{
	/* start of xor_h manual code */

	/* end of xor_h manual code */
}

/* xor l [0xAD] : Bitwise XOR on a with l. */
static void xor_l(struct s_gb *s_gb)
{
	/* start of xor_l manual code */

	/* end of xor_l manual code */
}

/* xor (hl) [0xAE] : Bitwise XOR on a with (hl). */
static void xor_phl(struct s_gb *s_gb)
{
	/* start of xor_phl manual code */

	/* end of xor_phl manual code */
}

/* xor a [0xAF] : Bitwise XOR on a with a. */
static void xor_a(struct s_gb *s_gb)
{
	/* start of xor_a manual code */

	/* end of xor_a manual code */
}

/* or b [0xB0] : Bitwise OR on a with b. */
static void or_b(struct s_gb *s_gb)
{
	/* start of or_b manual code */

	/* end of or_b manual code */
}

/* or c [0xB1] : Bitwise OR on a with c. */
static void or_c(struct s_gb *s_gb)
{
	/* start of or_c manual code */

	/* end of or_c manual code */
}

/* or d [0xB2] : Bitwise OR on a with d. */
static void or_d(struct s_gb *s_gb)
{
	/* start of or_d manual code */

	/* end of or_d manual code */
}

/* or e [0xB3] : Bitwise OR on a with e. */
static void or_e(struct s_gb *s_gb)
{
	/* start of or_e manual code */

	/* end of or_e manual code */
}

/* or h [0xB4] : Bitwise OR on a with h. */
static void or_h(struct s_gb *s_gb)
{
	/* start of or_h manual code */

	/* end of or_h manual code */
}

/* or l [0xB5] : Bitwise OR on a with l. */
static void or_l(struct s_gb *s_gb)
{
	/* start of or_l manual code */

	/* end of or_l manual code */
}

/* or (hl) [0xB6] : Bitwise OR on a with (hl). */
static void or_phl(struct s_gb *s_gb)
{
	/* start of or_phl manual code */

	/* end of or_phl manual code */
}

/* or a [0xB7] : Bitwise OR on a with a. */
static void or_a(struct s_gb *s_gb)
{
	/* start of or_a manual code */

	/* end of or_a manual code */
}

/* cp b [0xB8] : Subtracts b from a and affects flags according to the result. a is not modified. */
static void cp_b(struct s_gb *s_gb)
{
	/* start of cp_b manual code */

	/* end of cp_b manual code */
}

/* cp c [0xB9] : Subtracts c from a and affects flags according to the result. a is not modified. */
static void cp_c(struct s_gb *s_gb)
{
	/* start of cp_c manual code */

	/* end of cp_c manual code */
}

/* cp d [0xBA] : Subtracts d from a and affects flags according to the result. a is not modified. */
static void cp_d(struct s_gb *s_gb)
{
	/* start of cp_d manual code */

	/* end of cp_d manual code */
}

/* cp e [0xBB] : Subtracts e from a and affects flags according to the result. a is not modified. */
static void cp_e(struct s_gb *s_gb)
{
	/* start of cp_e manual code */

	/* end of cp_e manual code */
}

/* cp h [0xBC] : Subtracts h from a and affects flags according to the result. a is not modified. */
static void cp_h(struct s_gb *s_gb)
{
	/* start of cp_h manual code */

	/* end of cp_h manual code */
}

/* cp l [0xBD] : Subtracts l from a and affects flags according to the result. a is not modified. */
static void cp_l(struct s_gb *s_gb)
{
	/* start of cp_l manual code */

	/* end of cp_l manual code */
}

/* cp (hl) [0xBE] : Subtracts (hl) from a and affects flags according to the result. a is not modified. */
static void cp_phl(struct s_gb *s_gb)
{
	/* start of cp_phl manual code */

	/* end of cp_phl manual code */
}

/* cp a [0xBF] : Subtracts a from a and affects flags according to the result. a is not modified. */
static void cp_a(struct s_gb *s_gb)
{
	/* start of cp_a manual code */

	/* end of cp_a manual code */
}

/* ret nz [0xC0] : If condition cc is true, the top stack entry is popped into pc. */
static void ret_nz(struct s_gb *s_gb)
{
	/* start of ret_nz manual code */

	/* end of ret_nz manual code */
}

/* pop bc [0xC1] : The memory location pointed to by sp is stored into c and sp is incremented. The memory location pointed to by sp is stored into b and sp is incremented again. */
static void pop_bc(struct s_gb *s_gb)
{
	/* start of pop_bc manual code */

	/* end of pop_bc manual code */
}

/* jp nz,** [0xC2] : If condition cc is true, ** is copied to pc. */
static void jp_nz_xx(struct s_gb *s_gb)
{
	/* start of jp_nz_xx manual code */

	/* end of jp_nz_xx manual code */
}

/* jp ** [0xC3] : ** is copied to pc. */
static void jp_xx(struct s_gb *s_gb)
{
	/* start of jp_xx manual code */

	/* end of jp_xx manual code */
}

/* call nz,** [0xC4] : If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **. */
static void call_nz_xx(struct s_gb *s_gb)
{
	/* start of call_nz_xx manual code */

	/* end of call_nz_xx manual code */
}

/* push bc [0xC5] : sp is decremented and b is stored into the memory location pointed to by sp. sp is decremented again and c is stored into the memory location pointed to by sp. */
static void push_bc(struct s_gb *s_gb)
{
	/* start of push_bc manual code */

	/* end of push_bc manual code */
}

/* add a,* [0xC6] : Adds * to a. */
static void add_a_x(struct s_gb *s_gb)
{
	/* start of add_a_x manual code */

	/* end of add_a_x manual code */
}

/* rst 00h [0xC7] : The current pc value plus one is pushed onto the stack, then is loaded with 00h. */
static void rst_00h(struct s_gb *s_gb)
{
	/* start of rst_00h manual code */

	/* end of rst_00h manual code */
}

/* ret z [0xC8] : If condition cc is true, the top stack entry is popped into pc. */
static void ret_z(struct s_gb *s_gb)
{
	/* start of ret_z manual code */

	/* end of ret_z manual code */
}

/* ret [0xC9] : The top stack entry is popped into pc. */
static void ret(struct s_gb *s_gb)
{
	/* start of ret manual code */

	/* end of ret manual code */
}

/* jp z,** [0xCA] : If condition cc is true, ** is copied to pc. */
static void jp_z_xx(struct s_gb *s_gb)
{
	/* start of jp_z_xx manual code */

	/* end of jp_z_xx manual code */
}

/* call z,** [0xCB] : If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **. */
static void call_z_xx(struct s_gb *s_gb)
{
	/* start of call_z_xx manual code */

	/* end of call_z_xx manual code */
}

/* call ** [0xCC] : The current pc value plus three is pushed onto the stack, then is loaded with **. */
static void call_xx(struct s_gb *s_gb)
{
	/* start of call_xx manual code */

	/* end of call_xx manual code */
}

/* adc a,* [0xCD] : Adds * and the carry flag to a. */
static void adc_a_x(struct s_gb *s_gb)
{
	/* start of adc_a_x manual code */

	/* end of adc_a_x manual code */
}

/* rst 08h [0xCE] : The current pc value plus one is pushed onto the stack, then is loaded with 08h. */
static void rst_08h(struct s_gb *s_gb)
{
	/* start of rst_08h manual code */

	/* end of rst_08h manual code */
}

/* ret nc [0xD0] : If condition cc is true, the top stack entry is popped into pc. */
static void ret_nc(struct s_gb *s_gb)
{
	/* start of ret_nc manual code */

	/* end of ret_nc manual code */
}

/* pop de [0xD1] : The memory location pointed to by sp is stored into e and sp is incremented. The memory location pointed to by sp is stored into d and sp is incremented again. */
static void pop_de(struct s_gb *s_gb)
{
	/* start of pop_de manual code */

	/* end of pop_de manual code */
}

/* jp nc,** [0xD2] : If condition cc is true, ** is copied to pc. */
static void jp_nc_xx(struct s_gb *s_gb)
{
	/* start of jp_nc_xx manual code */

	/* end of jp_nc_xx manual code */
}

/* out (*),a [0xD3] : The value of a is written to port *. */
static void out_px_a(struct s_gb *s_gb)
{
	/* start of out_px_a manual code */

	/* end of out_px_a manual code */
}

/* call nc,** [0xD4] : If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **. */
static void call_nc_xx(struct s_gb *s_gb)
{
	/* start of call_nc_xx manual code */

	/* end of call_nc_xx manual code */
}

/* push de [0xD5] : sp is decremented and d is stored into the memory location pointed to by sp. sp is decremented again and e is stored into the memory location pointed to by sp. */
static void push_de(struct s_gb *s_gb)
{
	/* start of push_de manual code */

	/* end of push_de manual code */
}

/* sub * [0xD6] : Subtracts * from a. */
static void sub_x(struct s_gb *s_gb)
{
	/* start of sub_x manual code */

	/* end of sub_x manual code */
}

/* rst 10h [0xD7] : The current pc value plus one is pushed onto the stack, then is loaded with 10h. */
static void rst_10h(struct s_gb *s_gb)
{
	/* start of rst_10h manual code */

	/* end of rst_10h manual code */
}

/* ret c [0xD8] : If condition cc is true, the top stack entry is popped into pc. */
static void ret_c(struct s_gb *s_gb)
{
	/* start of ret_c manual code */

	/* end of ret_c manual code */
}

/* exx [0xD9] : Exchanges the 16-bit contents of bc, de, and hl with bc', de', and hl'. */
static void exx(struct s_gb *s_gb)
{
	/* start of exx manual code */

	/* end of exx manual code */
}

/* jp c,** [0xDA] : If condition cc is true, ** is copied to pc. */
static void jp_c_xx(struct s_gb *s_gb)
{
	/* start of jp_c_xx manual code */

	/* end of jp_c_xx manual code */
}

/* in a,(*) [0xDB] : A byte from port * is written to a. */
static void in_a_px(struct s_gb *s_gb)
{
	/* start of in_a_px manual code */

	/* end of in_a_px manual code */
}

/* call c,** [0xDC] : If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **. */
static void call_c_xx(struct s_gb *s_gb)
{
	/* start of call_c_xx manual code */

	/* end of call_c_xx manual code */
}

/* sbc a,* [0xDD] : Subtracts * and the carry flag from a. */
static void sbc_a_x(struct s_gb *s_gb)
{
	/* start of sbc_a_x manual code */

	/* end of sbc_a_x manual code */
}

/* rst 18h [0xDE] : The current pc value plus one is pushed onto the stack, then is loaded with 18h. */
static void rst_18h(struct s_gb *s_gb)
{
	/* start of rst_18h manual code */

	/* end of rst_18h manual code */
}

/* ret po [0xE0] : If condition cc is true, the top stack entry is popped into pc. */
static void ret_po(struct s_gb *s_gb)
{
	/* start of ret_po manual code */

	/* end of ret_po manual code */
}

/* pop hl [0xE1] : The memory location pointed to by sp is stored into l and sp is incremented. The memory location pointed to by sp is stored into h and sp is incremented again. */
static void pop_hl(struct s_gb *s_gb)
{
	/* start of pop_hl manual code */

	/* end of pop_hl manual code */
}

/* jp po,** [0xE2] : If condition cc is true, ** is copied to pc. */
static void jp_po_xx(struct s_gb *s_gb)
{
	/* start of jp_po_xx manual code */

	/* end of jp_po_xx manual code */
}

/* ex (sp),hl [0xE3] : Exchanges (sp) with l, and (sp+1) with h. */
static void ex_psp_hl(struct s_gb *s_gb)
{
	/* start of ex_psp_hl manual code */

	/* end of ex_psp_hl manual code */
}

/* call po,** [0xE4] : If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **. */
static void call_po_xx(struct s_gb *s_gb)
{
	/* start of call_po_xx manual code */

	/* end of call_po_xx manual code */
}

/* push hl [0xE5] : sp is decremented and h is stored into the memory location pointed to by sp. sp is decremented again and l is stored into the memory location pointed to by sp. */
static void push_hl(struct s_gb *s_gb)
{
	/* start of push_hl manual code */

	/* end of push_hl manual code */
}

/* and * [0xE6] : Bitwise AND on a with *. */
static void and_x(struct s_gb *s_gb)
{
	/* start of and_x manual code */

	/* end of and_x manual code */
}

/* rst 20h [0xE7] : The current pc value plus one is pushed onto the stack, then is loaded with 20h. */
static void rst_20h(struct s_gb *s_gb)
{
	/* start of rst_20h manual code */

	/* end of rst_20h manual code */
}

/* ret pe [0xE8] : If condition cc is true, the top stack entry is popped into pc. */
static void ret_pe(struct s_gb *s_gb)
{
	/* start of ret_pe manual code */

	/* end of ret_pe manual code */
}

/* jp (hl) [0xE9] : Loads the value of hl into pc. */
static void jp_phl(struct s_gb *s_gb)
{
	/* start of jp_phl manual code */

	/* end of jp_phl manual code */
}

/* jp pe,** [0xEA] : If condition cc is true, ** is copied to pc. */
static void jp_pe_xx(struct s_gb *s_gb)
{
	/* start of jp_pe_xx manual code */

	/* end of jp_pe_xx manual code */
}

/* ex de,hl [0xEB] : Exchanges the 16-bit contents of de and hl. */
static void ex_de_hl(struct s_gb *s_gb)
{
	/* start of ex_de_hl manual code */

	/* end of ex_de_hl manual code */
}

/* call pe,** [0xEC] : If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **. */
static void call_pe_xx(struct s_gb *s_gb)
{
	/* start of call_pe_xx manual code */

	/* end of call_pe_xx manual code */
}

/* xor * [0xED] : Bitwise XOR on a with *. */
static void xor_x(struct s_gb *s_gb)
{
	/* start of xor_x manual code */

	/* end of xor_x manual code */
}

/* rst 28h [0xEE] : The current pc value plus one is pushed onto the stack, then is loaded with 28h. */
static void rst_28h(struct s_gb *s_gb)
{
	/* start of rst_28h manual code */

	/* end of rst_28h manual code */
}

/* ret p [0xF0] : If condition cc is true, the top stack entry is popped into pc. */
static void ret_p(struct s_gb *s_gb)
{
	/* start of ret_p manual code */

	/* end of ret_p manual code */
}

/* pop af [0xF1] : The memory location pointed to by sp is stored into f and sp is incremented. The memory location pointed to by sp is stored into a and sp is incremented again. */
static void pop_af(struct s_gb *s_gb)
{
	/* start of pop_af manual code */

	/* end of pop_af manual code */
}

/* jp p,** [0xF2] : If condition cc is true, ** is copied to pc. */
static void jp_p_xx(struct s_gb *s_gb)
{
	/* start of jp_p_xx manual code */

	/* end of jp_p_xx manual code */
}

/* di [0xF3] : Resets both interrupt flip-flops, thus prenting maskable interrupts from triggering. */
static void di(struct s_gb *s_gb)
{
	/* start of di manual code */

	/* end of di manual code */
}

/* call p,** [0xF4] : If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **. */
static void call_p_xx(struct s_gb *s_gb)
{
	/* start of call_p_xx manual code */

	/* end of call_p_xx manual code */
}

/* push af [0xF5] : sp is decremented and a is stored into the memory location pointed to by sp. sp is decremented again and f is stored into the memory location pointed to by sp. */
static void push_af(struct s_gb *s_gb)
{
	/* start of push_af manual code */

	/* end of push_af manual code */
}

/* or * [0xF6] : Bitwise OR on a with *. */
static void or_x(struct s_gb *s_gb)
{
	/* start of or_x manual code */

	/* end of or_x manual code */
}

/* rst 30h [0xF7] : The current pc value plus one is pushed onto the stack, then is loaded with 30h. */
static void rst_30h(struct s_gb *s_gb)
{
	/* start of rst_30h manual code */

	/* end of rst_30h manual code */
}

/* ret m [0xF8] : If condition cc is true, the top stack entry is popped into pc. */
static void ret_m(struct s_gb *s_gb)
{
	/* start of ret_m manual code */

	/* end of ret_m manual code */
}

/* ld sp,hl [0xF9] : Loads the value of hl into sp. */
static void ld_sp_hl(struct s_gb *s_gb)
{
	/* start of ld_sp_hl manual code */

	/* end of ld_sp_hl manual code */
}

/* jp m,** [0xFA] : If condition cc is true, ** is copied to pc. */
static void jp_m_xx(struct s_gb *s_gb)
{
	/* start of jp_m_xx manual code */

	/* end of jp_m_xx manual code */
}

/* ei [0xFB] : Sets both interrupt flip-flops, thus allowing maskable interrupts to occur. An interrupt will not occur until after the immediatedly following instruction. */
static void ei(struct s_gb *s_gb)
{
	/* start of ei manual code */

	/* end of ei manual code */
}

/* call m,** [0xFC] : If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **. */
static void call_m_xx(struct s_gb *s_gb)
{
	/* start of call_m_xx manual code */

	/* end of call_m_xx manual code */
}

/* cp * [0xFD] : Subtracts * from a and affects flags according to the result. a is not modified. */
static void cp_x(struct s_gb *s_gb)
{
	/* start of cp_x manual code */

	/* end of cp_x manual code */
}

/* rst 38h [0xFE] : The current pc value plus one is pushed onto the stack, then is loaded with 38h. */
static void rst_38h(struct s_gb *s_gb)
{
	/* start of rst_38h manual code */

	/* end of rst_38h manual code */
}

const struct s_cpu_z80 instructions[] = {
	{
		.opcode = 0x00,
		.value = "nop",
		.doc = "No operation is performed.",
		.cycles = 4,
		.size = 1,
		.func = nop,
	},
	{
		.opcode = 0x01,
		.value = "ld bc,**",
		.doc = "Loads ** into bc.",
		.cycles = 10,
		.size = 3,
		.func = ld_bc_xx,
	},
	{
		.opcode = 0x02,
		.value = "ld (bc),a",
		.doc = "Stores a into the memory location pointed to by bc.",
		.cycles = 7,
		.size = 1,
		.func = ld_pbc_a,
	},
	{
		.opcode = 0x03,
		.value = "inc bc",
		.doc = "Adds one to bc.",
		.cycles = 6,
		.size = 1,
		.func = inc_bc,
	},
	{
		.opcode = 0x04,
		.value = "inc b",
		.doc = "Adds one to b.",
		.cycles = 4,
		.size = 1,
		.func = inc_b,
	},
	{
		.opcode = 0x05,
		.value = "dec b",
		.doc = "Subtracts one from b.",
		.cycles = 4,
		.size = 1,
		.func = dec_b,
	},
	{
		.opcode = 0x06,
		.value = "ld b,*",
		.doc = "Loads * into b.",
		.cycles = 7,
		.size = 2,
		.func = ld_b_x,
	},
	{
		.opcode = 0x07,
		.value = "rlca",
		.doc = "The contents of a are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.",
		.cycles = 4,
		.size = 1,
		.func = rlca,
	},
	{
		.opcode = 0x08,
		.value = "ex af,af'",
		.doc = "Exchanges the 16-bit contents of af and af'.",
		.cycles = 4,
		.size = 1,
		.func = ex_af_afx,
	},
	{
		.opcode = 0x09,
		.value = "add hl,bc",
		.doc = "The value of bc is added to hl.",
		.cycles = 11,
		.size = 1,
		.func = add_hl_bc,
	},
	{
		.opcode = 0x0A,
		.value = "ld a,(bc)",
		.doc = "Loads the value pointed to by bc into a.",
		.cycles = 7,
		.size = 1,
		.func = ld_a_pbc,
	},
	{
		.opcode = 0x0B,
		.value = "dec bc",
		.doc = "Subtracts one from bc.",
		.cycles = 6,
		.size = 1,
		.func = dec_bc,
	},
	{
		.opcode = 0x0C,
		.value = "inc c",
		.doc = "Adds one to c.",
		.cycles = 4,
		.size = 1,
		.func = inc_c,
	},
	{
		.opcode = 0x0D,
		.value = "dec c",
		.doc = "Subtracts one from c.",
		.cycles = 4,
		.size = 1,
		.func = dec_c,
	},
	{
		.opcode = 0x0E,
		.value = "ld c,*",
		.doc = "Loads * into c.",
		.cycles = 7,
		.size = 2,
		.func = ld_c_x,
	},
	{
		.opcode = 0x0F,
		.value = "rrca",
		.doc = "The contents of a are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.",
		.cycles = 4,
		.size = 1,
		.func = rrca,
	},
	{
		.opcode = 0x10,
		.value = "djnz *",
		.doc = "The b register is decremented, and if not zero, the signed value * is added to pc. The jump is measured from the start of the instruction opcode.",
		.cycles = 13/8,
		.size = 2,
		.func = djnz_x,
	},
	{
		.opcode = 0x11,
		.value = "ld de,**",
		.doc = "Loads ** into de.",
		.cycles = 10,
		.size = 3,
		.func = ld_de_xx,
	},
	{
		.opcode = 0x12,
		.value = "ld (de),a",
		.doc = "Stores a into the memory location pointed to by de.",
		.cycles = 7,
		.size = 1,
		.func = ld_pde_a,
	},
	{
		.opcode = 0x13,
		.value = "inc de",
		.doc = "Adds one to de.",
		.cycles = 6,
		.size = 1,
		.func = inc_de,
	},
	{
		.opcode = 0x14,
		.value = "inc d",
		.doc = "Adds one to d.",
		.cycles = 4,
		.size = 1,
		.func = inc_d,
	},
	{
		.opcode = 0x15,
		.value = "dec d",
		.doc = "Subtracts one from d.",
		.cycles = 4,
		.size = 1,
		.func = dec_d,
	},
	{
		.opcode = 0x16,
		.value = "ld d,*",
		.doc = "Loads * into d.",
		.cycles = 7,
		.size = 2,
		.func = ld_d_x,
	},
	{
		.opcode = 0x17,
		.value = "rla",
		.doc = "The contents of a are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.",
		.cycles = 4,
		.size = 1,
		.func = rla,
	},
	{
		.opcode = 0x18,
		.value = "jr *",
		.doc = "The signed value * is added to pc. The jump is measured from the start of the instruction opcode.",
		.cycles = 12,
		.size = 2,
		.func = jr_x,
	},
	{
		.opcode = 0x19,
		.value = "add hl,de",
		.doc = "The value of de is added to hl.",
		.cycles = 11,
		.size = 1,
		.func = add_hl_de,
	},
	{
		.opcode = 0x1A,
		.value = "ld a,(de)",
		.doc = "Loads the value pointed to by de into a.",
		.cycles = 7,
		.size = 1,
		.func = ld_a_pde,
	},
	{
		.opcode = 0x1B,
		.value = "dec de",
		.doc = "Subtracts one from de.",
		.cycles = 6,
		.size = 1,
		.func = dec_de,
	},
	{
		.opcode = 0x1C,
		.value = "inc e",
		.doc = "Adds one to e.",
		.cycles = 4,
		.size = 1,
		.func = inc_e,
	},
	{
		.opcode = 0x1D,
		.value = "dec e",
		.doc = "Subtracts one from e.",
		.cycles = 4,
		.size = 1,
		.func = dec_e,
	},
	{
		.opcode = 0x1E,
		.value = "ld e,*",
		.doc = "Loads * into e.",
		.cycles = 7,
		.size = 2,
		.func = ld_e_x,
	},
	{
		.opcode = 0x1F,
		.value = "rra",
		.doc = "The contents of a are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.",
		.cycles = 4,
		.size = 1,
		.func = rra,
	},
	{
		.opcode = 0x20,
		.value = "jr nz,*",
		.doc = "If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode.",
		.cycles = 12/7,
		.size = 2,
		.func = jr_nz_x,
	},
	{
		.opcode = 0x21,
		.value = "ld hl,**",
		.doc = "Loads ** into hl.",
		.cycles = 10,
		.size = 3,
		.func = ld_hl_xx,
	},
	{
		.opcode = 0x22,
		.value = "ld (**),hl",
		.doc = "Stores hl into the memory location pointed to by **.",
		.cycles = 16,
		.size = 3,
		.func = ld_pxx_hl,
	},
	{
		.opcode = 0x23,
		.value = "inc hl",
		.doc = "Adds one to hl.",
		.cycles = 6,
		.size = 1,
		.func = inc_hl,
	},
	{
		.opcode = 0x24,
		.value = "inc h",
		.doc = "Adds one to h.",
		.cycles = 4,
		.size = 1,
		.func = inc_h,
	},
	{
		.opcode = 0x25,
		.value = "dec h",
		.doc = "Subtracts one from h.",
		.cycles = 4,
		.size = 1,
		.func = dec_h,
	},
	{
		.opcode = 0x26,
		.value = "ld h,*",
		.doc = "Loads * into h.",
		.cycles = 7,
		.size = 2,
		.func = ld_h_x,
	},
	{
		.opcode = 0x27,
		.value = "daa",
		.doc = "Adjusts a for BCD addition and subtraction operations.",
		.cycles = 4,
		.size = 1,
		.func = daa,
	},
	{
		.opcode = 0x28,
		.value = "jr z,*",
		.doc = "If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode.",
		.cycles = 12/7,
		.size = 2,
		.func = jr_z_x,
	},
	{
		.opcode = 0x29,
		.value = "add hl,hl",
		.doc = "The value of hl is added to hl.",
		.cycles = 11,
		.size = 1,
		.func = add_hl_hl,
	},
	{
		.opcode = 0x2A,
		.value = "ld hl,(**)",
		.doc = "Loads the value pointed to by ** into hl.",
		.cycles = 16,
		.size = 3,
		.func = ld_hl_pxx,
	},
	{
		.opcode = 0x2B,
		.value = "dec hl",
		.doc = "Subtracts one from hl.",
		.cycles = 6,
		.size = 1,
		.func = dec_hl,
	},
	{
		.opcode = 0x2C,
		.value = "inc l",
		.doc = "Adds one to l.",
		.cycles = 4,
		.size = 1,
		.func = inc_l,
	},
	{
		.opcode = 0x2D,
		.value = "dec l",
		.doc = "Subtracts one from l.",
		.cycles = 4,
		.size = 1,
		.func = dec_l,
	},
	{
		.opcode = 0x2E,
		.value = "ld l,*",
		.doc = "Loads * into l.",
		.cycles = 7,
		.size = 2,
		.func = ld_l_x,
	},
	{
		.opcode = 0x2F,
		.value = "cpl",
		.doc = "The contents of a are inverted (one's complement).",
		.cycles = 4,
		.size = 1,
		.func = cpl,
	},
	{
		.opcode = 0x30,
		.value = "jr nc,*",
		.doc = "If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode.",
		.cycles = 12/7,
		.size = 2,
		.func = jr_nc_x,
	},
	{
		.opcode = 0x31,
		.value = "ld sp,**",
		.doc = "Loads ** into sp.",
		.cycles = 10,
		.size = 3,
		.func = ld_sp_xx,
	},
	{
		.opcode = 0x32,
		.value = "ld (**),a",
		.doc = "Stores a into the memory location pointed to by **.",
		.cycles = 13,
		.size = 3,
		.func = ld_pxx_a,
	},
	{
		.opcode = 0x33,
		.value = "inc sp",
		.doc = "Adds one to sp.",
		.cycles = 6,
		.size = 1,
		.func = inc_sp,
	},
	{
		.opcode = 0x34,
		.value = "inc (hl)",
		.doc = "Adds one to (hl).",
		.cycles = 11,
		.size = 1,
		.func = inc_phl,
	},
	{
		.opcode = 0x35,
		.value = "dec (hl)",
		.doc = "Subtracts one from (hl).",
		.cycles = 11,
		.size = 1,
		.func = dec_phl,
	},
	{
		.opcode = 0x36,
		.value = "ld (hl),*",
		.doc = "Loads * into (hl).",
		.cycles = 10,
		.size = 2,
		.func = ld_phl_x,
	},
	{
		.opcode = 0x37,
		.value = "scf",
		.doc = "Sets the carry flag.",
		.cycles = 4,
		.size = 1,
		.func = scf,
	},
	{
		.opcode = 0x38,
		.value = "jr c,*",
		.doc = "If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode.",
		.cycles = 12/7,
		.size = 2,
		.func = jr_c_x,
	},
	{
		.opcode = 0x39,
		.value = "add hl,sp",
		.doc = "The value of hl is added to hl.",
		.cycles = 11,
		.size = 1,
		.func = add_hl_sp,
	},
	{
		.opcode = 0x3A,
		.value = "ld a,(**)",
		.doc = "Loads the value pointed to by ** into a.",
		.cycles = 13,
		.size = 3,
		.func = ld_a_pxx,
	},
	{
		.opcode = 0x3B,
		.value = "dec sp",
		.doc = "Subtracts one from sp.",
		.cycles = 6,
		.size = 1,
		.func = dec_sp,
	},
	{
		.opcode = 0x3C,
		.value = "inc a",
		.doc = "Adds one to a.",
		.cycles = 4,
		.size = 1,
		.func = inc_a,
	},
	{
		.opcode = 0x3D,
		.value = "dec a",
		.doc = "Subtracts one from a.",
		.cycles = 4,
		.size = 1,
		.func = dec_a,
	},
	{
		.opcode = 0x3E,
		.value = "ld a,*",
		.doc = "Loads * into a.",
		.cycles = 7,
		.size = 2,
		.func = ld_a_x,
	},
	{
		.opcode = 0x3F,
		.value = "ccf",
		.doc = "Inverts the carry flag.",
		.cycles = 4,
		.size = 1,
		.func = ccf,
	},
	{
		.opcode = 0x40,
		.value = "ld b,b",
		.doc = "The contents of b are loaded into b.",
		.cycles = 4,
		.size = 1,
		.func = ld_b_b,
	},
	{
		.opcode = 0x41,
		.value = "ld b,c",
		.doc = "The contents of c are loaded into b.",
		.cycles = 4,
		.size = 1,
		.func = ld_b_c,
	},
	{
		.opcode = 0x42,
		.value = "ld b,d",
		.doc = "The contents of d are loaded into b.",
		.cycles = 4,
		.size = 1,
		.func = ld_b_d,
	},
	{
		.opcode = 0x43,
		.value = "ld b,e",
		.doc = "The contents of e are loaded into b.",
		.cycles = 4,
		.size = 1,
		.func = ld_b_e,
	},
	{
		.opcode = 0x44,
		.value = "ld b,h",
		.doc = "The contents of h are loaded into b.",
		.cycles = 4,
		.size = 1,
		.func = ld_b_h,
	},
	{
		.opcode = 0x45,
		.value = "ld b,l",
		.doc = "The contents of l are loaded into b.",
		.cycles = 4,
		.size = 1,
		.func = ld_b_l,
	},
	{
		.opcode = 0x46,
		.value = "ld b,(hl)",
		.doc = "The contents of (hl) are loaded into b.",
		.cycles = 7,
		.size = 1,
		.func = ld_b_phl,
	},
	{
		.opcode = 0x47,
		.value = "ld b,a",
		.doc = "The contents of a are loaded into b.",
		.cycles = 4,
		.size = 1,
		.func = ld_b_a,
	},
	{
		.opcode = 0x48,
		.value = "ld c,b",
		.doc = "The contents of b are loaded into c.",
		.cycles = 4,
		.size = 1,
		.func = ld_c_b,
	},
	{
		.opcode = 0x49,
		.value = "ld c,c",
		.doc = "The contents of c are loaded into c.",
		.cycles = 4,
		.size = 1,
		.func = ld_c_c,
	},
	{
		.opcode = 0x4A,
		.value = "ld c,d",
		.doc = "The contents of d are loaded into c.",
		.cycles = 4,
		.size = 1,
		.func = ld_c_d,
	},
	{
		.opcode = 0x4B,
		.value = "ld c,e",
		.doc = "The contents of e are loaded into c.",
		.cycles = 4,
		.size = 1,
		.func = ld_c_e,
	},
	{
		.opcode = 0x4C,
		.value = "ld c,h",
		.doc = "The contents of h are loaded into c.",
		.cycles = 4,
		.size = 1,
		.func = ld_c_h,
	},
	{
		.opcode = 0x4D,
		.value = "ld c,l",
		.doc = "The contents of l are loaded into c.",
		.cycles = 4,
		.size = 1,
		.func = ld_c_l,
	},
	{
		.opcode = 0x4E,
		.value = "ld c,(hl)",
		.doc = "The contents of (hl) are loaded into c.",
		.cycles = 7,
		.size = 1,
		.func = ld_c_phl,
	},
	{
		.opcode = 0x4F,
		.value = "ld c,a",
		.doc = "The contents of a are loaded into c.",
		.cycles = 4,
		.size = 1,
		.func = ld_c_a,
	},
	{
		.opcode = 0x50,
		.value = "ld d,b",
		.doc = "The contents of b are loaded into d.",
		.cycles = 4,
		.size = 1,
		.func = ld_d_b,
	},
	{
		.opcode = 0x51,
		.value = "ld d,c",
		.doc = "The contents of c are loaded into d.",
		.cycles = 4,
		.size = 1,
		.func = ld_d_c,
	},
	{
		.opcode = 0x52,
		.value = "ld d,d",
		.doc = "The contents of d are loaded into d.",
		.cycles = 4,
		.size = 1,
		.func = ld_d_d,
	},
	{
		.opcode = 0x53,
		.value = "ld d,e",
		.doc = "The contents of e are loaded into d.",
		.cycles = 4,
		.size = 1,
		.func = ld_d_e,
	},
	{
		.opcode = 0x54,
		.value = "ld d,h",
		.doc = "The contents of h are loaded into d.",
		.cycles = 4,
		.size = 1,
		.func = ld_d_h,
	},
	{
		.opcode = 0x55,
		.value = "ld d,l",
		.doc = "The contents of l are loaded into d.",
		.cycles = 4,
		.size = 1,
		.func = ld_d_l,
	},
	{
		.opcode = 0x56,
		.value = "ld d,(hl)",
		.doc = "The contents of (hl) are loaded into d.",
		.cycles = 7,
		.size = 1,
		.func = ld_d_phl,
	},
	{
		.opcode = 0x57,
		.value = "ld d,a",
		.doc = "The contents of a are loaded into d.",
		.cycles = 4,
		.size = 1,
		.func = ld_d_a,
	},
	{
		.opcode = 0x58,
		.value = "ld e,b",
		.doc = "The contents of b are loaded into e.",
		.cycles = 4,
		.size = 1,
		.func = ld_e_b,
	},
	{
		.opcode = 0x59,
		.value = "ld e,c",
		.doc = "The contents of c are loaded into e.",
		.cycles = 4,
		.size = 1,
		.func = ld_e_c,
	},
	{
		.opcode = 0x5A,
		.value = "ld e,d",
		.doc = "The contents of d are loaded into e.",
		.cycles = 4,
		.size = 1,
		.func = ld_e_d,
	},
	{
		.opcode = 0x5B,
		.value = "ld e,e",
		.doc = "The contents of e are loaded into e.",
		.cycles = 4,
		.size = 1,
		.func = ld_e_e,
	},
	{
		.opcode = 0x5C,
		.value = "ld e,h",
		.doc = "The contents of h are loaded into e.",
		.cycles = 4,
		.size = 1,
		.func = ld_e_h,
	},
	{
		.opcode = 0x5D,
		.value = "ld e,l",
		.doc = "The contents of l are loaded into e.",
		.cycles = 4,
		.size = 1,
		.func = ld_e_l,
	},
	{
		.opcode = 0x5E,
		.value = "ld e,(hl)",
		.doc = "The contents of (hl) are loaded into e.",
		.cycles = 7,
		.size = 1,
		.func = ld_e_phl,
	},
	{
		.opcode = 0x5F,
		.value = "ld e,a",
		.doc = "The contents of a are loaded into e.",
		.cycles = 4,
		.size = 1,
		.func = ld_e_a,
	},
	{
		.opcode = 0x60,
		.value = "ld h,b",
		.doc = "The contents of b are loaded into h.",
		.cycles = 4,
		.size = 1,
		.func = ld_h_b,
	},
	{
		.opcode = 0x61,
		.value = "ld h,c",
		.doc = "The contents of c are loaded into h.",
		.cycles = 4,
		.size = 1,
		.func = ld_h_c,
	},
	{
		.opcode = 0x62,
		.value = "ld h,d",
		.doc = "The contents of d are loaded into h.",
		.cycles = 4,
		.size = 1,
		.func = ld_h_d,
	},
	{
		.opcode = 0x63,
		.value = "ld h,e",
		.doc = "The contents of e are loaded into h.",
		.cycles = 4,
		.size = 1,
		.func = ld_h_e,
	},
	{
		.opcode = 0x64,
		.value = "ld h,h",
		.doc = "The contents of h are loaded into h.",
		.cycles = 4,
		.size = 1,
		.func = ld_h_h,
	},
	{
		.opcode = 0x65,
		.value = "ld h,l",
		.doc = "The contents of l are loaded into h.",
		.cycles = 4,
		.size = 1,
		.func = ld_h_l,
	},
	{
		.opcode = 0x66,
		.value = "ld h,(hl)",
		.doc = "The contents of (hl) are loaded into h.",
		.cycles = 7,
		.size = 1,
		.func = ld_h_phl,
	},
	{
		.opcode = 0x67,
		.value = "ld h,a",
		.doc = "The contents of a are loaded into h.",
		.cycles = 4,
		.size = 1,
		.func = ld_h_a,
	},
	{
		.opcode = 0x68,
		.value = "ld l,b",
		.doc = "The contents of b are loaded into l.",
		.cycles = 4,
		.size = 1,
		.func = ld_l_b,
	},
	{
		.opcode = 0x69,
		.value = "ld l,c",
		.doc = "The contents of c are loaded into l.",
		.cycles = 4,
		.size = 1,
		.func = ld_l_c,
	},
	{
		.opcode = 0x6A,
		.value = "ld l,d",
		.doc = "The contents of d are loaded into l.",
		.cycles = 4,
		.size = 1,
		.func = ld_l_d,
	},
	{
		.opcode = 0x6B,
		.value = "ld l,e",
		.doc = "The contents of e are loaded into l.",
		.cycles = 4,
		.size = 1,
		.func = ld_l_e,
	},
	{
		.opcode = 0x6C,
		.value = "ld l,h",
		.doc = "The contents of h are loaded into l.",
		.cycles = 4,
		.size = 1,
		.func = ld_l_h,
	},
	{
		.opcode = 0x6D,
		.value = "ld l,l",
		.doc = "The contents of l are loaded into l.",
		.cycles = 4,
		.size = 1,
		.func = ld_l_l,
	},
	{
		.opcode = 0x6E,
		.value = "ld l,(hl)",
		.doc = "The contents of (hl) are loaded into l.",
		.cycles = 7,
		.size = 1,
		.func = ld_l_phl,
	},
	{
		.opcode = 0x6F,
		.value = "ld l,a",
		.doc = "The contents of a are loaded into l.",
		.cycles = 4,
		.size = 1,
		.func = ld_l_a,
	},
	{
		.opcode = 0x70,
		.value = "ld (hl),b",
		.doc = "The contents of b are loaded into (hl).",
		.cycles = 7,
		.size = 1,
		.func = ld_phl_b,
	},
	{
		.opcode = 0x71,
		.value = "ld (hl),c",
		.doc = "The contents of c are loaded into (hl).",
		.cycles = 7,
		.size = 1,
		.func = ld_phl_c,
	},
	{
		.opcode = 0x72,
		.value = "ld (hl),d",
		.doc = "The contents of d are loaded into (hl).",
		.cycles = 7,
		.size = 1,
		.func = ld_phl_d,
	},
	{
		.opcode = 0x73,
		.value = "ld (hl),e",
		.doc = "The contents of e are loaded into (hl).",
		.cycles = 7,
		.size = 1,
		.func = ld_phl_e,
	},
	{
		.opcode = 0x74,
		.value = "ld (hl),h",
		.doc = "The contents of h are loaded into (hl).",
		.cycles = 7,
		.size = 1,
		.func = ld_phl_h,
	},
	{
		.opcode = 0x75,
		.value = "ld (hl),l",
		.doc = "The contents of l are loaded into (hl).",
		.cycles = 7,
		.size = 1,
		.func = ld_phl_l,
	},
	{
		.opcode = 0x76,
		.value = "halt",
		.doc = "Suspends CPU operation until an interrupt or reset occurs.",
		.cycles = 4,
		.size = 1,
		.func = halt,
	},
	{
		.opcode = 0x77,
		.value = "ld (hl),a",
		.doc = "The contents of a are loaded into (hl).",
		.cycles = 7,
		.size = 1,
		.func = ld_phl_a,
	},
	{
		.opcode = 0x78,
		.value = "ld a,b",
		.doc = "The contents of b are loaded into a.",
		.cycles = 4,
		.size = 1,
		.func = ld_a_b,
	},
	{
		.opcode = 0x79,
		.value = "ld a,c",
		.doc = "The contents of c are loaded into a.",
		.cycles = 4,
		.size = 1,
		.func = ld_a_c,
	},
	{
		.opcode = 0x7A,
		.value = "ld a,d",
		.doc = "The contents of d are loaded into a.",
		.cycles = 4,
		.size = 1,
		.func = ld_a_d,
	},
	{
		.opcode = 0x7B,
		.value = "ld a,e",
		.doc = "The contents of e are loaded into a.",
		.cycles = 4,
		.size = 1,
		.func = ld_a_e,
	},
	{
		.opcode = 0x7C,
		.value = "ld a,h",
		.doc = "The contents of h are loaded into a.",
		.cycles = 4,
		.size = 1,
		.func = ld_a_h,
	},
	{
		.opcode = 0x7D,
		.value = "ld a,l",
		.doc = "The contents of l are loaded into a.",
		.cycles = 4,
		.size = 1,
		.func = ld_a_l,
	},
	{
		.opcode = 0x7E,
		.value = "ld a,(hl)",
		.doc = "The contents of (hl) are loaded into a.",
		.cycles = 7,
		.size = 1,
		.func = ld_a_phl,
	},
	{
		.opcode = 0x7F,
		.value = "ld a,a",
		.doc = "The contents of a are loaded into a.",
		.cycles = 4,
		.size = 1,
		.func = ld_a_a,
	},
	{
		.opcode = 0x80,
		.value = "add a,b",
		.doc = "Adds b to a.",
		.cycles = 4,
		.size = 1,
		.func = add_a_b,
	},
	{
		.opcode = 0x81,
		.value = "add a,c",
		.doc = "Adds c to a.",
		.cycles = 4,
		.size = 1,
		.func = add_a_c,
	},
	{
		.opcode = 0x82,
		.value = "add a,d",
		.doc = "Adds d to a.",
		.cycles = 4,
		.size = 1,
		.func = add_a_d,
	},
	{
		.opcode = 0x83,
		.value = "add a,e",
		.doc = "Adds e to a.",
		.cycles = 4,
		.size = 1,
		.func = add_a_e,
	},
	{
		.opcode = 0x84,
		.value = "add a,h",
		.doc = "Adds h to a.",
		.cycles = 4,
		.size = 1,
		.func = add_a_h,
	},
	{
		.opcode = 0x85,
		.value = "add a,l",
		.doc = "Adds l to a.",
		.cycles = 4,
		.size = 1,
		.func = add_a_l,
	},
	{
		.opcode = 0x86,
		.value = "add a,(hl)",
		.doc = "Adds (hl) to a.",
		.cycles = 7,
		.size = 1,
		.func = add_a_phl,
	},
	{
		.opcode = 0x87,
		.value = "add a,a",
		.doc = "Adds a to a.",
		.cycles = 4,
		.size = 1,
		.func = add_a_a,
	},
	{
		.opcode = 0x88,
		.value = "adc a,b",
		.doc = "Adds b and the carry flag to a.",
		.cycles = 4,
		.size = 1,
		.func = adc_a_b,
	},
	{
		.opcode = 0x89,
		.value = "adc a,c",
		.doc = "Adds c and the carry flag to a.",
		.cycles = 4,
		.size = 1,
		.func = adc_a_c,
	},
	{
		.opcode = 0x8A,
		.value = "adc a,d",
		.doc = "Adds d and the carry flag to a.",
		.cycles = 4,
		.size = 1,
		.func = adc_a_d,
	},
	{
		.opcode = 0x8B,
		.value = "adc a,e",
		.doc = "Adds e and the carry flag to a.",
		.cycles = 4,
		.size = 1,
		.func = adc_a_e,
	},
	{
		.opcode = 0x8C,
		.value = "adc a,h",
		.doc = "Adds h and the carry flag to a.",
		.cycles = 4,
		.size = 1,
		.func = adc_a_h,
	},
	{
		.opcode = 0x8D,
		.value = "adc a,l",
		.doc = "Adds l and the carry flag to a.",
		.cycles = 4,
		.size = 1,
		.func = adc_a_l,
	},
	{
		.opcode = 0x8E,
		.value = "adc a,(hl)",
		.doc = "Adds (hl) and the carry flag to a.",
		.cycles = 7,
		.size = 1,
		.func = adc_a_phl,
	},
	{
		.opcode = 0x8F,
		.value = "adc a,a",
		.doc = "Adds a and the carry flag to a.",
		.cycles = 4,
		.size = 1,
		.func = adc_a_a,
	},
	{
		.opcode = 0x90,
		.value = "sub b",
		.doc = "Subtracts b from a.",
		.cycles = 4,
		.size = 1,
		.func = sub_b,
	},
	{
		.opcode = 0x91,
		.value = "sub c",
		.doc = "Subtracts c from a.",
		.cycles = 4,
		.size = 1,
		.func = sub_c,
	},
	{
		.opcode = 0x92,
		.value = "sub d",
		.doc = "Subtracts d from a.",
		.cycles = 4,
		.size = 1,
		.func = sub_d,
	},
	{
		.opcode = 0x93,
		.value = "sub e",
		.doc = "Subtracts e from a.",
		.cycles = 4,
		.size = 1,
		.func = sub_e,
	},
	{
		.opcode = 0x94,
		.value = "sub h",
		.doc = "Subtracts h from a.",
		.cycles = 4,
		.size = 1,
		.func = sub_h,
	},
	{
		.opcode = 0x95,
		.value = "sub l",
		.doc = "Subtracts l from a.",
		.cycles = 4,
		.size = 1,
		.func = sub_l,
	},
	{
		.opcode = 0x96,
		.value = "sub (hl)",
		.doc = "Subtracts (hl) from a.",
		.cycles = 7,
		.size = 1,
		.func = sub_phl,
	},
	{
		.opcode = 0x97,
		.value = "sub a",
		.doc = "Subtracts a from a.",
		.cycles = 4,
		.size = 1,
		.func = sub_a,
	},
	{
		.opcode = 0x98,
		.value = "sbc a,b",
		.doc = "Subtracts b and the carry flag from a.",
		.cycles = 4,
		.size = 1,
		.func = sbc_a_b,
	},
	{
		.opcode = 0x99,
		.value = "sbc a,c",
		.doc = "Subtracts c and the carry flag from a.",
		.cycles = 4,
		.size = 1,
		.func = sbc_a_c,
	},
	{
		.opcode = 0x9A,
		.value = "sbc a,d",
		.doc = "Subtracts d and the carry flag from a.",
		.cycles = 4,
		.size = 1,
		.func = sbc_a_d,
	},
	{
		.opcode = 0x9B,
		.value = "sbc a,e",
		.doc = "Subtracts e and the carry flag from a.",
		.cycles = 4,
		.size = 1,
		.func = sbc_a_e,
	},
	{
		.opcode = 0x9C,
		.value = "sbc a,h",
		.doc = "Subtracts h and the carry flag from a.",
		.cycles = 4,
		.size = 1,
		.func = sbc_a_h,
	},
	{
		.opcode = 0x9D,
		.value = "sbc a,l",
		.doc = "Subtracts l and the carry flag from a.",
		.cycles = 4,
		.size = 1,
		.func = sbc_a_l,
	},
	{
		.opcode = 0x9E,
		.value = "sbc a,(hl)",
		.doc = "Subtracts (hl) and the carry flag from a.",
		.cycles = 7,
		.size = 1,
		.func = sbc_a_phl,
	},
	{
		.opcode = 0x9F,
		.value = "sbc a,a",
		.doc = "Subtracts a and the carry flag from a.",
		.cycles = 4,
		.size = 1,
		.func = sbc_a_a,
	},
	{
		.opcode = 0xA0,
		.value = "and b",
		.doc = "Bitwise AND on a with b.",
		.cycles = 4,
		.size = 1,
		.func = and_b,
	},
	{
		.opcode = 0xA1,
		.value = "and c",
		.doc = "Bitwise AND on a with c.",
		.cycles = 4,
		.size = 1,
		.func = and_c,
	},
	{
		.opcode = 0xA2,
		.value = "and d",
		.doc = "Bitwise AND on a with d.",
		.cycles = 4,
		.size = 1,
		.func = and_d,
	},
	{
		.opcode = 0xA3,
		.value = "and e",
		.doc = "Bitwise AND on a with e.",
		.cycles = 4,
		.size = 1,
		.func = and_e,
	},
	{
		.opcode = 0xA4,
		.value = "and h",
		.doc = "Bitwise AND on a with h.",
		.cycles = 4,
		.size = 1,
		.func = and_h,
	},
	{
		.opcode = 0xA5,
		.value = "and l",
		.doc = "Bitwise AND on a with l.",
		.cycles = 4,
		.size = 1,
		.func = and_l,
	},
	{
		.opcode = 0xA6,
		.value = "and (hl)",
		.doc = "Bitwise AND on a with (hl).",
		.cycles = 7,
		.size = 1,
		.func = and_phl,
	},
	{
		.opcode = 0xA7,
		.value = "and a",
		.doc = "Bitwise AND on a with a.",
		.cycles = 4,
		.size = 1,
		.func = and_a,
	},
	{
		.opcode = 0xA8,
		.value = "xor b",
		.doc = "Bitwise XOR on a with b.",
		.cycles = 4,
		.size = 1,
		.func = xor_b,
	},
	{
		.opcode = 0xA9,
		.value = "xor c",
		.doc = "Bitwise XOR on a with c.",
		.cycles = 4,
		.size = 1,
		.func = xor_c,
	},
	{
		.opcode = 0xAA,
		.value = "xor d",
		.doc = "Bitwise XOR on a with d.",
		.cycles = 4,
		.size = 1,
		.func = xor_d,
	},
	{
		.opcode = 0xAB,
		.value = "xor e",
		.doc = "Bitwise XOR on a with e.",
		.cycles = 4,
		.size = 1,
		.func = xor_e,
	},
	{
		.opcode = 0xAC,
		.value = "xor h",
		.doc = "Bitwise XOR on a with h.",
		.cycles = 4,
		.size = 1,
		.func = xor_h,
	},
	{
		.opcode = 0xAD,
		.value = "xor l",
		.doc = "Bitwise XOR on a with l.",
		.cycles = 4,
		.size = 1,
		.func = xor_l,
	},
	{
		.opcode = 0xAE,
		.value = "xor (hl)",
		.doc = "Bitwise XOR on a with (hl).",
		.cycles = 7,
		.size = 1,
		.func = xor_phl,
	},
	{
		.opcode = 0xAF,
		.value = "xor a",
		.doc = "Bitwise XOR on a with a.",
		.cycles = 4,
		.size = 1,
		.func = xor_a,
	},
	{
		.opcode = 0xB0,
		.value = "or b",
		.doc = "Bitwise OR on a with b.",
		.cycles = 4,
		.size = 1,
		.func = or_b,
	},
	{
		.opcode = 0xB1,
		.value = "or c",
		.doc = "Bitwise OR on a with c.",
		.cycles = 4,
		.size = 1,
		.func = or_c,
	},
	{
		.opcode = 0xB2,
		.value = "or d",
		.doc = "Bitwise OR on a with d.",
		.cycles = 4,
		.size = 1,
		.func = or_d,
	},
	{
		.opcode = 0xB3,
		.value = "or e",
		.doc = "Bitwise OR on a with e.",
		.cycles = 4,
		.size = 1,
		.func = or_e,
	},
	{
		.opcode = 0xB4,
		.value = "or h",
		.doc = "Bitwise OR on a with h.",
		.cycles = 4,
		.size = 1,
		.func = or_h,
	},
	{
		.opcode = 0xB5,
		.value = "or l",
		.doc = "Bitwise OR on a with l.",
		.cycles = 4,
		.size = 1,
		.func = or_l,
	},
	{
		.opcode = 0xB6,
		.value = "or (hl)",
		.doc = "Bitwise OR on a with (hl).",
		.cycles = 7,
		.size = 1,
		.func = or_phl,
	},
	{
		.opcode = 0xB7,
		.value = "or a",
		.doc = "Bitwise OR on a with a.",
		.cycles = 4,
		.size = 1,
		.func = or_a,
	},
	{
		.opcode = 0xB8,
		.value = "cp b",
		.doc = "Subtracts b from a and affects flags according to the result. a is not modified.",
		.cycles = 4,
		.size = 1,
		.func = cp_b,
	},
	{
		.opcode = 0xB9,
		.value = "cp c",
		.doc = "Subtracts c from a and affects flags according to the result. a is not modified.",
		.cycles = 4,
		.size = 1,
		.func = cp_c,
	},
	{
		.opcode = 0xBA,
		.value = "cp d",
		.doc = "Subtracts d from a and affects flags according to the result. a is not modified.",
		.cycles = 4,
		.size = 1,
		.func = cp_d,
	},
	{
		.opcode = 0xBB,
		.value = "cp e",
		.doc = "Subtracts e from a and affects flags according to the result. a is not modified.",
		.cycles = 4,
		.size = 1,
		.func = cp_e,
	},
	{
		.opcode = 0xBC,
		.value = "cp h",
		.doc = "Subtracts h from a and affects flags according to the result. a is not modified.",
		.cycles = 4,
		.size = 1,
		.func = cp_h,
	},
	{
		.opcode = 0xBD,
		.value = "cp l",
		.doc = "Subtracts l from a and affects flags according to the result. a is not modified.",
		.cycles = 4,
		.size = 1,
		.func = cp_l,
	},
	{
		.opcode = 0xBE,
		.value = "cp (hl)",
		.doc = "Subtracts (hl) from a and affects flags according to the result. a is not modified.",
		.cycles = 7,
		.size = 1,
		.func = cp_phl,
	},
	{
		.opcode = 0xBF,
		.value = "cp a",
		.doc = "Subtracts a from a and affects flags according to the result. a is not modified.",
		.cycles = 4,
		.size = 1,
		.func = cp_a,
	},
	{
		.opcode = 0xC0,
		.value = "ret nz",
		.doc = "If condition cc is true, the top stack entry is popped into pc.",
		.cycles = 11/5,
		.size = 1,
		.func = ret_nz,
	},
	{
		.opcode = 0xC1,
		.value = "pop bc",
		.doc = "The memory location pointed to by sp is stored into c and sp is incremented. The memory location pointed to by sp is stored into b and sp is incremented again.",
		.cycles = 10,
		.size = 1,
		.func = pop_bc,
	},
	{
		.opcode = 0xC2,
		.value = "jp nz,**",
		.doc = "If condition cc is true, ** is copied to pc.",
		.cycles = 10,
		.size = 3,
		.func = jp_nz_xx,
	},
	{
		.opcode = 0xC3,
		.value = "jp **",
		.doc = "** is copied to pc.",
		.cycles = 10,
		.size = 3,
		.func = jp_xx,
	},
	{
		.opcode = 0xC4,
		.value = "call nz,**",
		.doc = "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.",
		.cycles = 17/10,
		.size = 3,
		.func = call_nz_xx,
	},
	{
		.opcode = 0xC5,
		.value = "push bc",
		.doc = "sp is decremented and b is stored into the memory location pointed to by sp. sp is decremented again and c is stored into the memory location pointed to by sp.",
		.cycles = 11,
		.size = 1,
		.func = push_bc,
	},
	{
		.opcode = 0xC6,
		.value = "add a,*",
		.doc = "Adds * to a.",
		.cycles = 7,
		.size = 2,
		.func = add_a_x,
	},
	{
		.opcode = 0xC7,
		.value = "rst 00h",
		.doc = "The current pc value plus one is pushed onto the stack, then is loaded with 00h.",
		.cycles = 11,
		.size = 1,
		.func = rst_00h,
	},
	{
		.opcode = 0xC8,
		.value = "ret z",
		.doc = "If condition cc is true, the top stack entry is popped into pc.",
		.cycles = 11/5,
		.size = 1,
		.func = ret_z,
	},
	{
		.opcode = 0xC9,
		.value = "ret",
		.doc = "The top stack entry is popped into pc.",
		.cycles = 10,
		.size = 1,
		.func = ret,
	},
	{
		.opcode = 0xCA,
		.value = "jp z,**",
		.doc = "If condition cc is true, ** is copied to pc.",
		.cycles = 10,
		.size = 3,
		.func = jp_z_xx,
	},
	{
		.opcode = 0xCB,
		.value = "call z,**",
		.doc = "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.",
		.cycles = 17/10,
		.size = 3,
		.func = call_z_xx,
	},
	{
		.opcode = 0xCC,
		.value = "call **",
		.doc = "The current pc value plus three is pushed onto the stack, then is loaded with **.",
		.cycles = 17,
		.size = 3,
		.func = call_xx,
	},
	{
		.opcode = 0xCD,
		.value = "adc a,*",
		.doc = "Adds * and the carry flag to a.",
		.cycles = 7,
		.size = 2,
		.func = adc_a_x,
	},
	{
		.opcode = 0xCE,
		.value = "rst 08h",
		.doc = "The current pc value plus one is pushed onto the stack, then is loaded with 08h.",
		.cycles = 11,
		.size = 1,
		.func = rst_08h,
	},
	{
		.opcode = 0xD0,
		.value = "ret nc",
		.doc = "If condition cc is true, the top stack entry is popped into pc.",
		.cycles = 11/5,
		.size = 1,
		.func = ret_nc,
	},
	{
		.opcode = 0xD1,
		.value = "pop de",
		.doc = "The memory location pointed to by sp is stored into e and sp is incremented. The memory location pointed to by sp is stored into d and sp is incremented again.",
		.cycles = 10,
		.size = 1,
		.func = pop_de,
	},
	{
		.opcode = 0xD2,
		.value = "jp nc,**",
		.doc = "If condition cc is true, ** is copied to pc.",
		.cycles = 10,
		.size = 3,
		.func = jp_nc_xx,
	},
	{
		.opcode = 0xD3,
		.value = "out (*),a",
		.doc = "The value of a is written to port *.",
		.cycles = 11,
		.size = 2,
		.func = out_px_a,
	},
	{
		.opcode = 0xD4,
		.value = "call nc,**",
		.doc = "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.",
		.cycles = 17/10,
		.size = 3,
		.func = call_nc_xx,
	},
	{
		.opcode = 0xD5,
		.value = "push de",
		.doc = "sp is decremented and d is stored into the memory location pointed to by sp. sp is decremented again and e is stored into the memory location pointed to by sp.",
		.cycles = 11,
		.size = 1,
		.func = push_de,
	},
	{
		.opcode = 0xD6,
		.value = "sub *",
		.doc = "Subtracts * from a.",
		.cycles = 7,
		.size = 2,
		.func = sub_x,
	},
	{
		.opcode = 0xD7,
		.value = "rst 10h",
		.doc = "The current pc value plus one is pushed onto the stack, then is loaded with 10h.",
		.cycles = 11,
		.size = 1,
		.func = rst_10h,
	},
	{
		.opcode = 0xD8,
		.value = "ret c",
		.doc = "If condition cc is true, the top stack entry is popped into pc.",
		.cycles = 11/5,
		.size = 1,
		.func = ret_c,
	},
	{
		.opcode = 0xD9,
		.value = "exx",
		.doc = "Exchanges the 16-bit contents of bc, de, and hl with bc', de', and hl'.",
		.cycles = 4,
		.size = 1,
		.func = exx,
	},
	{
		.opcode = 0xDA,
		.value = "jp c,**",
		.doc = "If condition cc is true, ** is copied to pc.",
		.cycles = 10,
		.size = 3,
		.func = jp_c_xx,
	},
	{
		.opcode = 0xDB,
		.value = "in a,(*)",
		.doc = "A byte from port * is written to a.",
		.cycles = 11,
		.size = 2,
		.func = in_a_px,
	},
	{
		.opcode = 0xDC,
		.value = "call c,**",
		.doc = "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.",
		.cycles = 17/10,
		.size = 3,
		.func = call_c_xx,
	},
	{
		.opcode = 0xDD,
		.value = "sbc a,*",
		.doc = "Subtracts * and the carry flag from a.",
		.cycles = 7,
		.size = 2,
		.func = sbc_a_x,
	},
	{
		.opcode = 0xDE,
		.value = "rst 18h",
		.doc = "The current pc value plus one is pushed onto the stack, then is loaded with 18h.",
		.cycles = 11,
		.size = 1,
		.func = rst_18h,
	},
	{
		.opcode = 0xE0,
		.value = "ret po",
		.doc = "If condition cc is true, the top stack entry is popped into pc.",
		.cycles = 11/5,
		.size = 1,
		.func = ret_po,
	},
	{
		.opcode = 0xE1,
		.value = "pop hl",
		.doc = "The memory location pointed to by sp is stored into l and sp is incremented. The memory location pointed to by sp is stored into h and sp is incremented again.",
		.cycles = 10,
		.size = 1,
		.func = pop_hl,
	},
	{
		.opcode = 0xE2,
		.value = "jp po,**",
		.doc = "If condition cc is true, ** is copied to pc.",
		.cycles = 10,
		.size = 3,
		.func = jp_po_xx,
	},
	{
		.opcode = 0xE3,
		.value = "ex (sp),hl",
		.doc = "Exchanges (sp) with l, and (sp+1) with h.",
		.cycles = 19,
		.size = 1,
		.func = ex_psp_hl,
	},
	{
		.opcode = 0xE4,
		.value = "call po,**",
		.doc = "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.",
		.cycles = 17/10,
		.size = 3,
		.func = call_po_xx,
	},
	{
		.opcode = 0xE5,
		.value = "push hl",
		.doc = "sp is decremented and h is stored into the memory location pointed to by sp. sp is decremented again and l is stored into the memory location pointed to by sp.",
		.cycles = 11,
		.size = 1,
		.func = push_hl,
	},
	{
		.opcode = 0xE6,
		.value = "and *",
		.doc = "Bitwise AND on a with *.",
		.cycles = 7,
		.size = 2,
		.func = and_x,
	},
	{
		.opcode = 0xE7,
		.value = "rst 20h",
		.doc = "The current pc value plus one is pushed onto the stack, then is loaded with 20h.",
		.cycles = 11,
		.size = 1,
		.func = rst_20h,
	},
	{
		.opcode = 0xE8,
		.value = "ret pe",
		.doc = "If condition cc is true, the top stack entry is popped into pc.",
		.cycles = 11/5,
		.size = 1,
		.func = ret_pe,
	},
	{
		.opcode = 0xE9,
		.value = "jp (hl)",
		.doc = "Loads the value of hl into pc.",
		.cycles = 4,
		.size = 1,
		.func = jp_phl,
	},
	{
		.opcode = 0xEA,
		.value = "jp pe,**",
		.doc = "If condition cc is true, ** is copied to pc.",
		.cycles = 10,
		.size = 3,
		.func = jp_pe_xx,
	},
	{
		.opcode = 0xEB,
		.value = "ex de,hl",
		.doc = "Exchanges the 16-bit contents of de and hl.",
		.cycles = 4,
		.size = 1,
		.func = ex_de_hl,
	},
	{
		.opcode = 0xEC,
		.value = "call pe,**",
		.doc = "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.",
		.cycles = 17/10,
		.size = 3,
		.func = call_pe_xx,
	},
	{
		.opcode = 0xED,
		.value = "xor *",
		.doc = "Bitwise XOR on a with *.",
		.cycles = 7,
		.size = 2,
		.func = xor_x,
	},
	{
		.opcode = 0xEE,
		.value = "rst 28h",
		.doc = "The current pc value plus one is pushed onto the stack, then is loaded with 28h.",
		.cycles = 11,
		.size = 1,
		.func = rst_28h,
	},
	{
		.opcode = 0xF0,
		.value = "ret p",
		.doc = "If condition cc is true, the top stack entry is popped into pc.",
		.cycles = 11/5,
		.size = 1,
		.func = ret_p,
	},
	{
		.opcode = 0xF1,
		.value = "pop af",
		.doc = "The memory location pointed to by sp is stored into f and sp is incremented. The memory location pointed to by sp is stored into a and sp is incremented again.",
		.cycles = 10,
		.size = 1,
		.func = pop_af,
	},
	{
		.opcode = 0xF2,
		.value = "jp p,**",
		.doc = "If condition cc is true, ** is copied to pc.",
		.cycles = 10,
		.size = 3,
		.func = jp_p_xx,
	},
	{
		.opcode = 0xF3,
		.value = "di",
		.doc = "Resets both interrupt flip-flops, thus prenting maskable interrupts from triggering.",
		.cycles = 4,
		.size = 1,
		.func = di,
	},
	{
		.opcode = 0xF4,
		.value = "call p,**",
		.doc = "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.",
		.cycles = 17/10,
		.size = 3,
		.func = call_p_xx,
	},
	{
		.opcode = 0xF5,
		.value = "push af",
		.doc = "sp is decremented and a is stored into the memory location pointed to by sp. sp is decremented again and f is stored into the memory location pointed to by sp.",
		.cycles = 11,
		.size = 1,
		.func = push_af,
	},
	{
		.opcode = 0xF6,
		.value = "or *",
		.doc = "Bitwise OR on a with *.",
		.cycles = 7,
		.size = 2,
		.func = or_x,
	},
	{
		.opcode = 0xF7,
		.value = "rst 30h",
		.doc = "The current pc value plus one is pushed onto the stack, then is loaded with 30h.",
		.cycles = 11,
		.size = 1,
		.func = rst_30h,
	},
	{
		.opcode = 0xF8,
		.value = "ret m",
		.doc = "If condition cc is true, the top stack entry is popped into pc.",
		.cycles = 11/5,
		.size = 1,
		.func = ret_m,
	},
	{
		.opcode = 0xF9,
		.value = "ld sp,hl",
		.doc = "Loads the value of hl into sp.",
		.cycles = 6,
		.size = 1,
		.func = ld_sp_hl,
	},
	{
		.opcode = 0xFA,
		.value = "jp m,**",
		.doc = "If condition cc is true, ** is copied to pc.",
		.cycles = 10,
		.size = 3,
		.func = jp_m_xx,
	},
	{
		.opcode = 0xFB,
		.value = "ei",
		.doc = "Sets both interrupt flip-flops, thus allowing maskable interrupts to occur. An interrupt will not occur until after the immediatedly following instruction.",
		.cycles = 4,
		.size = 1,
		.func = ei,
	},
	{
		.opcode = 0xFC,
		.value = "call m,**",
		.doc = "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.",
		.cycles = 17/10,
		.size = 3,
		.func = call_m_xx,
	},
	{
		.opcode = 0xFD,
		.value = "cp *",
		.doc = "Subtracts * from a and affects flags according to the result. a is not modified.",
		.cycles = 7,
		.size = 2,
		.func = cp_x,
	},
	{
		.opcode = 0xFE,
		.value = "rst 38h",
		.doc = "The current pc value plus one is pushed onto the stack, then is loaded with 38h.",
		.cycles = 11,
		.size = 1,
		.func = rst_38h,
	},
};


