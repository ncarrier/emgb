#include <stdlib.h>
#include <string.h>

#include "memory.h"
#include "joypad.h"
#include "special_registers.h"
#include "rom.h"
#include "io.h"
#include "utils.h"
#include "log.h"

#define BIOS_PATH "bios.gb"

static void mcb_handle_banking(struct memory *memory, uint16_t addr,
		uint8_t value)
{
	char low5;

	low5 = value & 0x1f;
	if (addr >= 0x2000 && addr < 0x4000) {
		if (memory->rom_bank_0_rom.rom_header.cartridge_type == 1) {
			memory->mbc_rom_bank &= 0xe0;
			memory->mbc_rom_bank |= low5;
			/*
			 * printf("Lo BANK change. value => %x\n",
			 *		memory->mcb_rom_banking);
			*/
		}
	} else if (addr >= 0x4000 && addr < 0x6000) {
		/* hiRom bank change */
		if (memory->rom_banking_flag) {
			memory->mbc_rom_bank &= 0x1f;
			value &= 0xe0;
			memory->mbc_rom_bank |= value;
			/*
			 * printf("Hi BANK change. value => %x\n",
			 *		MCB_romBanking);
			 */

		}
	} else if (addr >= 0x6000 && addr < 0x8000) {
		/* change rom/ram bank */
		memory->rom_banking_flag = !(value & 0x01);

	}
	if (memory->mbc_rom_bank == 0)
		memory->mbc_rom_bank = 1;
}

/*
 * default bios
 * this one comes from the SameBoy project (git@github.com:LIJI32/SameBoy.git),
 * on commit bc55531
 * it is loaded if no bios.gb could be found in the current directory.
 * LICENSE.dmg.bios reproduces it COPYRIGHT notice (MIT)
 */
static const uint8_t bios_gb[] = {
	0x31, 0xfe, 0xff, 0x21, 0x00, 0x80, 0x22, 0xcb, 0x6c, 0x28, 0xfb, 0x3e,
	0x80, 0xe0, 0x26, 0xe0, 0x11, 0x3e, 0xf3, 0xe0, 0x12, 0xe0, 0x25, 0x3e,
	0x77, 0xe0, 0x24, 0x3e, 0xfc, 0xe0, 0x47, 0x11, 0x04, 0x01, 0x21, 0x10,
	0x80, 0x1a, 0x47, 0xcd, 0x82, 0x00, 0xcd, 0x82, 0x00, 0x13, 0x7b, 0xee,
	0x34, 0x20, 0xf2, 0x11, 0xb1, 0x00, 0x0e, 0x08, 0x1a, 0x13, 0x22, 0x23,
	0x0d, 0x20, 0xf9, 0x3e, 0x19, 0xea, 0x10, 0x99, 0x21, 0x2f, 0x99, 0x0e,
	0x0c, 0x3d, 0x28, 0x08, 0x32, 0x0d, 0x20, 0xf9, 0x2e, 0x0f, 0x18, 0xf5,
	0x3e, 0x91, 0xe0, 0x40, 0x06, 0x2d, 0xcd, 0xa3, 0x00, 0x3e, 0x83, 0xcd,
	0xaa, 0x00, 0x06, 0x05, 0xcd, 0xa3, 0x00, 0x3e, 0xc1, 0xcd, 0xaa, 0x00,
	0x06, 0x46, 0xcd, 0xa3, 0x00, 0x21, 0xb0, 0x01, 0xe5, 0xf1, 0x21, 0x4d,
	0x01, 0x01, 0x13, 0x00, 0x11, 0xd8, 0x00, 0xc3, 0xfe, 0x00, 0x3e, 0x04,
	0x0e, 0x00, 0xcb, 0x20, 0xf5, 0xcb, 0x11, 0xf1, 0xcb, 0x11, 0x3d, 0x20,
	0xf5, 0x79, 0x22, 0x23, 0x22, 0x23, 0xc9, 0xe5, 0x21, 0x0f, 0xff, 0xcb,
	0x86, 0xcb, 0x46, 0x28, 0xfc, 0xe1, 0xc9, 0xcd, 0x97, 0x00, 0x05, 0x20,
	0xfa, 0xc9, 0xe0, 0x13, 0x3e, 0x87, 0xe0, 0x14, 0xc9, 0x3c, 0x42, 0xb9,
	0xa5, 0xb9, 0xa5, 0x42, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xe0, 0x50
};

static void load_bios(struct memory *memory)
{
	FILE cleanup(cleanup_file)*f = NULL;
	size_t sret;

	f = fopen(BIOS_PATH, "rbe");
	if (f == NULL)
		goto default_bios;
	sret = fread(memory->bios, 1, BIOS_SIZE, f);
	if (sret != BIOS_SIZE)
		goto default_bios;

	puts("Loaded "BIOS_PATH".");

	return;
default_bios:

	memcpy(memory->bios, bios_gb, BIOS_SIZE);

	puts("Loaded internal bios.");
}

void memory_init(struct memory *memory, struct timer *timer)
{
	memset(memory, 0, sizeof(*memory));

	load_bios(memory);
	memory->bios_finished = false;
	memory->mbc_rom_bank = 1;
	memory->timer = timer;

	memory->div_counter = 0xff;

	/*
	 * TODO what follows shouldn't be useful anymore since we load the bios
	 * now
	 */
	write8bit(memory, 0xFF05, 0x00);
	write8bit(memory, 0xFF06, 0x00);
	write8bit(memory, 0xFF07, 0x08);
	write8bit(memory, 0xFF10, 0x80);
	write8bit(memory, 0xFF11, 0xBF);
	write8bit(memory, 0xFF12, 0xF3);
	write8bit(memory, 0xFF14, 0xBF);
	write8bit(memory, 0xFF16, 0x3F);
	write8bit(memory, 0xFF17, 0x00);
	write8bit(memory, 0xFF19, 0xBF);
	write8bit(memory, 0xFF1A, 0x7F);
	write8bit(memory, 0xFF1B, 0xFF);
	write8bit(memory, 0xFF1C, 0x9F);
	write8bit(memory, 0xFF1E, 0xBF);
	write8bit(memory, 0xFF20, 0xFF);
	write8bit(memory, 0xFF21, 0x00);
	write8bit(memory, 0xFF22, 0x00);
	write8bit(memory, 0xFF23, 0xBF);
	write8bit(memory, 0xFF24, 0x77);
	write8bit(memory, 0xFF25, 0xF3);
	write8bit(memory, 0xFF26, 0xF1);
	write8bit(memory, 0xFF40, 0x91);
	write8bit(memory, 0xFF42, 0x00);
	write8bit(memory, 0xFF43, 0x00);
	write8bit(memory, 0xFF45, 0x00);
	write8bit(memory, 0xFF47, 0xFC);
	write8bit(memory, 0xFF48, 0xFF);
	write8bit(memory, 0xFF49, 0xFF);
	write8bit(memory, 0xFF4A, 0x00);
	write8bit(memory, 0xFF4B, 0x00);
	write8bit(memory, 0xFFFF, 0x00);
}

void write16bit(struct memory *memory, uint16_t addr, uint16_t value)
{
	write8bit(memory, addr, value & 0x00ffu);
	write8bit(memory, addr + 1, (value & 0xff00u) >> 8);
}

uint16_t read16bit(struct memory *memory, uint16_t addr)
{
	uint16_t res;

	res = read8bit(memory, addr);
	res |= read8bit(memory, addr + 1) << 8;

	return res;
}

static bool in_switchable_rom_bank(uint16_t addr)
{
	return addr >= 0x4000 && addr < 0x8000;
}

void memory_update(struct memory *mem, unsigned cycles)
{
	if (mem->div_counter < (int)cycles) {
		if (mem->spec_reg.div == 0xff)
			mem->spec_reg.div = 0;
		else
			mem->spec_reg.div++;
		mem->div_counter += 0x100 - cycles;
	} else {
		mem->div_counter -= cycles;
	}
}

uint8_t read8bit(struct memory *mem, uint16_t addr)
{
	if (in_switchable_rom_bank(addr) && mem->mbc_rom_bank != 0)
		return mem->extra_rom_banks[(mem->mbc_rom_bank - 2)
				* ROM_BANK_SIZE + addr];
	if (addr < BIOS_SIZE && !mem->bios_finished)
		return mem->bios[addr];

	return mem->raw[addr];
}

void write8bit(struct memory *memory, uint16_t addr, uint8_t value)
{
	if (addr < 0x8000) {
		mcb_handle_banking(memory, addr, value);
	} else if (addr >= 0xFF00 && addr < 0xFF4C) {
		io_ctrl(memory, memory->timer, addr);
	} else if (addr == 0xFF50) {
		printf("bios_finished\n");
		memory->bios_finished = true;
	}

	memory->raw[addr] = value;
}

void push(struct memory *memory, uint16_t *sp, uint16_t value)
{
	*sp -= 2;
	write16bit(memory, *sp, value);
}

uint16_t pop(struct memory *memory, uint16_t *sp)
{
	uint16_t value;

	value = read16bit(memory, *sp);
	*sp += 2;

	return value;
}
